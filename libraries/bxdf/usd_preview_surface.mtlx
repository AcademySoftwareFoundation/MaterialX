<?xml version="1.0"?>
<materialx version="1.38">

  <!-- ======================================================================== -->
  <!-- USD Preview Surface node definitions                                     -->
  <!-- The following definitions are based on the specification defined here:   -->
  <!-- https://graphics.pixar.com/usd/release/spec_usdpreviewsurface.html       -->
  <!-- ======================================================================== -->

  <!-- Node: UsdPreviewSurface -->
  <nodedef name="ND_UsdPreviewSurface_surfaceshader" node="UsdPreviewSurface" nodegroup="pbr" doc="USD preview surface shader" version="2.3" isdefaultversion="true">
    <input name="diffuseColor" type="color3" value="0.18, 0.18, 0.18" uimin="0,0,0" uimax="1,1,1" 
           doc="Diffuse color. When using metallic workflow this is interpreted as albedo."/>
    <input name="emissiveColor" type="color3" value="0, 0, 0" uimin="0,0,0" uisoftmax="1,1,1" 
           doc="Emissive component."/>
    <input name="useSpecularWorkflow" type="integer" value="0" 
           doc="This node can fundamentally operate in two modes : Specular workflow where you provide a texture/value to the specularColor input. Or, Metallic workflow where you provide a texture/value to the metallic input."/>
    <input name="specularColor" type="color3" value="0, 0, 0" uimin="0,0,0" uimax="1,1,1" 
           doc="Specular color to be used. Enabled when useSpecularWorkflow = 1. This is the color at 0 incidence. Edge color is assumed white. Transition between the two colors according to Schlick fresnel approximation."/>
    <input name="metallic" type="float" value="0" uimin="0.0" uimax="1.0" 
           doc="Use 1 for metallic surfaces and 0 for non-metallic. Enabled when useSpecularWorkflow = 0. If metallic is 1, then both F0 (reflectivity at 0 degree incidence) and edge F90 reflectivity will simply be the Albedo . If metallic is 0, then Albedo is ignored in the calculation of F0 and F90; F0 is derived from ior via  and F90 is white. In between, we interpolate."/>
    <input name="roughness" type="float" value="0.5" uimin="0.0" uimax="1.0" 
           doc="Roughness for the specular lobe. The value ranges from 0 to 1, which goes from a perfectly specular surface at 0.0 to maximum roughness of the specular lobe. This value is usually squared before use with a GGX or Beckmann lobe. Note that roughness applies only to the specular lobe, and the transmissive lobe (if any) always assumes roughness 0.0."/>
    <input name="clearcoat" type="float" value="0" uimin="0.0" uimax="1.0" 
           doc="Second specular lobe amount. The color is white."/>
    <input name="clearcoatRoughness" type="float" value="0.01" uimin="0.0" uimax="1.0" 
           doc="Roughness for the second specular lobe."/>
    <input name="opacity" type="float" value="1" uimin="0.0" uimax="1.0" 
           doc="When opacity is 1.0 then the gprim is fully opaque, if it is smaller than 1.0 then the prim is translucent, when it is 0 the gprim is transparent. Note that even a fully transparent object still receives lighting as, for example, perfectly clear glass still has a specular response."/>
    <input name="opacityThreshold" type="float" value="0" uimin="0.0" uimax="1.0" 
           doc="The opacityThreshold input is useful for creating geometric cut-outs based on the opacity input. A value of 0.0 indicates that no masking is applied to the opacity input, while a value greater than 0.0 indicates that rendering of the surface is limited to the areas where the opacity is greater or equal to that value."/>
    <input name="ior" type="float" value="1.5" uimin="0.0" uisoftmax="3.0" 
           doc="ndex of Refraction to be used for translucent objects and objects with specular components, including the clearcoat if clearcoat > 0."/>
    <input name="normal" type="vector3" value="0, 0, 1" 
           doc="Expects normal in tangent space [(-1,-1,-1), (1,1,1)]. This means your texture reader implementation should provide data to this node that is properly scaled and ready to be consumed as a tangent space normal. The default input is ( 0,0,1 ) which allows for no transformation to be performed. This differs from the default for tangent space normalmap input which is ( 0.5, 0.5, 1 )."/>
    <input name="displacement" type="float" value="0" 
           doc="Displacement in the direction of the normal."/>
    <input name="occlusion" type="float" value="1" uimin="0.0" uimax="1.0" 
           doc="Extra information about the occlusion of different parts of the mesh that this material is applied to. Occlusion only makes sense as a surface-varying signal, and pathtracers will likely choose to ignore it. An occlusion value of 0.0 means the surface point is fully occluded by other parts of the surface, and a value of 1.0 means the surface point is completely unoccluded by other parts of the surface."/>
    <output name="out" type="surfaceshader" />
  </nodedef>

  <!-- Node: UsdUVTexture -->
  <nodedef name="ND_UsdUVTexture" node="UsdUVTexture" nodegroup="texture2d" version="2.2" inherit="ND_UsdUVTexture_23" 
           doc="USD texture reader version 2.2. Refer to 2.3 version for additional documentation. ">
    <output name="r" type="float" />
    <output name="g" type="float" />
    <output name="b" type="float" />
    <output name="a" type="float" />
    <output name="rgb" type="color3" />  
    <output name="rgba" type="color4" />
  </nodedef>

  <nodedef name="ND_UsdUVTexture_23" node="UsdUVTexture" nodegroup="texture2d" version="2.3" isdefaultversion="true"
           doc="USD color texture reader version 2.3." >
    <input name="file" type="filename" uniform="true" 
           doc="Path to the color texture."/>
    <input name="st" type="vector2" defaultgeomprop="UV0" 
           doc="exture coordinate to use to fetch this texture. This node defines a mathematical/cartesian mapping from st to uv to image space: the (0, 0) st coordinate maps to a (0, 0) uv coordinate that samples the lower-left-hand corner of the texture image, as viewed on a monitor, while the (1, 1) st coordinate maps to a (1, 1) uv coordinate that samples the upper-right-hand corner of the texture image, as viewed on a monitor."/>
    <input name="wrapS" type="string" value="periodic" enum="black,clamp,periodic,mirror" uniform="true" 
           doc="Wrap mode when reading this texture.Possible Values: { black : Reader returns black outside unit square, clamp : extend edge values outside unit square, repeat : repeat texture outside unit square, mirror : flip and repeat texture outside unit square }"/>
    <input name="wrapT" type="string" value="periodic" enum="black,clamp,periodic,mirror" uniform="true" 
           doc="Wrap mode when reading this texture. Same options and caveats as wrapS."/>           
    <input name="fallback" type="color4" value="0, 0, 0, 1" 
           doc="Fallback value used when texture can not be read. Default is ( 0, 0, 0, 1 ) for color texture."/>
    <input name="scale" type="color4" value="1, 1, 1, 1" uniform="true" 
           doc="Scale to be applied to all components of the texture. Output is textureValue * scale + bias. Default is (1, 1, 1, 1) for color texture."/>
    <input name="bias" type="color4" value="0, 0, 0, 0" uniform="true" 
           doc="Bias to be applied to all components of the texture. Output is textureValue * scale + bias. Default is (0, 0, 0, 0) for color texture."/>
    <output name="r" type="float" />
    <output name="g" type="float" />
    <output name="b" type="float" />
    <output name="a" type="float" />
    <output name="rgb" type="color3" />
  </nodedef>

  <nodedef name="ND_UsdUVTexture_23_NormalMap" node="UsdUvTexture" nodegroup="texture2d" version="2.3" isdefaultversion="true" 
           doc="USD normal map texture reader version 2.3.">
    <input name="file" type="filename" uniform="true" 
           doc="Path to the normal map texture."/>
    <input name="st" type="vector2" defaultgeomprop="UV0" 
           doc="exture coordinate to use to fetch this texture. This node defines a mathematical/cartesian mapping from st to uv to image space: the (0, 0) st coordinate maps to a (0, 0) uv coordinate that samples the lower-left-hand corner of the texture image, as viewed on a monitor, while the (1, 1) st coordinate maps to a (1, 1) uv coordinate that samples the upper-right-hand corner of the texture image, as viewed on a monitor."/>
    <input name="wrapS" type="string" value="periodic" enum="black,clamp,periodic,mirror" uniform="true" 
           doc="Wrap mode when reading this texture.Possible Values: { black : Reader returns black outside unit square, clamp : extend edge values outside unit square, repeat : repeat texture outside unit square, mirror : flip and repeat texture outside unit square }"/>
    <input name="wrapT" type="string" value="periodic" enum="black,clamp,periodic,mirror" uniform="true" 
           doc="Wrap mode when reading this texture. Same options and caveats as wrapS."/>
    <input name="fallback" type="vector3" value="0.5, 0.5, 1" 
           doc="Fallback value used when texture can not be read. Default is ( 0.5, 0.5, 1.0 ) for normal maps."/>
    <input name="scale" type="vector3" value="2, 2, 2" uniform="true" 
           doc="Scale to be applied to all components of the texture. Output is textureValue * scale + bias. Default is (2, 2, 2) for normal maps"/>           
    <input name="bias" type="vector3" value="-1, -1, -1" uniform="true" 
           doc="Bias to be applied to all components of the texture. Output is textureValue * scale + bias. Default is (-1, -1, 1) for normal maps"/>
    <output name="r" type="float" />
    <output name="g" type="float" />
    <output name="b" type="float" />
    <output name="a" type="float"  />
    <output name="rgb" type="vector3" />
  </nodedef>

  <!-- Node: UsdPrimvarReader -->
  <nodedef name="ND_UsdPrimvarReader_integer" nodegroup="geometric" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="integer" value="0" />
    <output name="out" type="integer" />
  </nodedef>
  <nodedef name="ND_UsdPrimvarReader_boolean" nodegroup="geometric" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="boolean" value="false" />
    <output name="out" type="boolean" />
  </nodedef>
  <nodedef name="ND_UsdPrimvarReader_string" nodegroup="geometric" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="string" value="" />
    <output name="out" type="string" />
  </nodedef>
  <nodedef name="ND_UsdPrimvarReader_float" nodegroup="geometric" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="float" value="0" />
    <output name="out" type="float" />
  </nodedef>
  <nodedef name="ND_UsdPrimvarReader_vector2" nodegroup="geometric" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="vector2" value="0, 0" />
    <output name="out" type="vector2" />
  </nodedef>
  <nodedef name="ND_UsdPrimvarReader_vector3" nodegroup="geometric" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="vector3" value="0, 0, 0" />
    <output name="out" type="vector3" />
  </nodedef>
  <nodedef name="ND_UsdPrimvarReader_vector4" nodegroup="geometric" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="vector4" value="0, 0, 0, 0" />
    <output name="out" type="vector4" />
  </nodedef>
  <!-- TODO: Getting primvar of matrix type is not supported in MaterialX standard library.
  <nodedef name="ND_UsdPrimvarReader_matrix44" node="UsdPrimvarReader">
    <input name="varname" type="string" />
    <input name="fallback" type="matrix44" value="1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1" />
    <output name="out" type="matrix44" />
  </nodedef>
  -->

  <!-- Node: UsdTransform2d -->
  <nodedef name="ND_UsdTransform2d" nodegroup="math" node="UsdTransform2d">
    <input name="in" type="vector2" />
    <input name="rotation" type="float" value="0" />
    <input name="scale" type="vector2" value="1, 1" />
    <input name="translation" type="vector2" value="0, 0" />
    <output name="out" type="vector2" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- USD Preview Surface nodegraph implementations                            -->
  <!-- ======================================================================== -->

  <!-- Node: UsdPreviewSurface -->
  <nodegraph name="IMP_UsdPreviewSurface_surfaceshader" nodedef="ND_UsdPreviewSurface_surfaceshader">

    <!-- Compute the per-pixel surface normal -->
    <multiply name="scale_normal" type="vector3">
      <input name="in1" type="vector3" interfacename="normal" />
      <input name="in2" type="float" value="0.5" />
    </multiply>
    <add name="bias_normal" type="vector3">
      <input name="in1" type="vector3" nodename="scale_normal" />
      <input name="in2" type="float" value="0.5" />
    </add>
    <normalmap name="surface_normal" type="vector3">
      <input name="in" type="vector3" nodename="bias_normal" />
    </normalmap>

    <!-- Diffuse Layer -->
    <oren_nayar_diffuse_bsdf name="diffuse_bsdf" type="BSDF">
      <input name="weight" type="float" value="1" />
      <input name="color" type="color3" interfacename="diffuseColor" />
      <input name="roughness" type="float" value="0" />
      <input name="normal" type="vector3" nodename="surface_normal" />
    </oren_nayar_diffuse_bsdf>

    <!-- Transmission Layer -->
    <dielectric_bsdf name="transmission_bsdf" type="BSDF">
      <input name="weight" type="float" value="1" />
      <input name="tint" type="color3" value="1, 1, 1" />
      <input name="ior" type="float" interfacename="ior" />
      <input name="roughness" type="vector2" value="0.0, 0.0" />
      <input name="normal" type="vector3" nodename="surface_normal" />
      <input name="scatter_mode" type="string" value="T" />
    </dielectric_bsdf>
    <mix name="transmission_mix" type="BSDF">
      <input name="fg" type="BSDF" nodename="diffuse_bsdf" />
      <input name="bg" type="BSDF" nodename="transmission_bsdf" />
      <input name="mix" type="float" interfacename="opacity" />
    </mix>

    <!-- Specular Workflow -->
    <roughness_anisotropy name="specular_roughness" type="vector2">
      <input name="roughness" type="float" interfacename="roughness" />
      <input name="anisotropy" type="float" value="0" />
    </roughness_anisotropy>
    <generalized_schlick_bsdf name="specular_bsdf1" type="BSDF">
      <input name="weight" type="float" value="1" />
      <input name="color0" type="color3" interfacename="specularColor" />
      <input name="color90" type="color3" value="1, 1, 1" />
      <input name="roughness" type="vector2" nodename="specular_roughness" />
      <input name="normal" type="vector3" nodename="surface_normal" />
    </generalized_schlick_bsdf>
    <layer name="specular_workflow_bsdf" type="BSDF">
      <input name="top" type="BSDF" nodename="specular_bsdf1" />
      <input name="base" type="BSDF" nodename="transmission_mix" />
    </layer>

    <!-- Metalness Workflow -->
    <subtract name="one_minus_ior" type="float">
      <input name="in1" type="float" value="1" />
      <input name="in2" type="float" interfacename="ior" />
    </subtract>
    <add name="one_plus_ior" type="float">
      <input name="in1" type="float" value="1" />
      <input name="in2" type="float" interfacename="ior" />
    </add>
    <divide name="div_ior" type="float">
      <input name="in1" type="float" nodename="one_minus_ior" />
      <input name="in2" type="float" nodename="one_plus_ior" />
    </divide>
    <multiply name="F0" type="float">
      <input name="in1" type="float" nodename="div_ior" />
      <input name="in2" type="float" nodename="div_ior" />
    </multiply>
    <generalized_schlick_bsdf name="specular_bsdf2" type="BSDF">
      <input name="weight" type="float" value="1" />
      <input name="color0" type="color3" nodename="F0" channels="rrr" />
      <input name="color90" type="color3" value="1, 1, 1" />
      <input name="roughness" type="vector2" nodename="specular_roughness" />
      <input name="normal" type="vector3" nodename="surface_normal" />
    </generalized_schlick_bsdf>
    <layer name="metalness_specular_bsdf" type="BSDF">
      <input name="top" type="BSDF" nodename="specular_bsdf2" />
      <input name="base" type="BSDF" nodename="transmission_mix" />
    </layer>
    <artistic_ior name="artistic_ior" type="multioutput">
      <input name="reflectivity" type="color3" interfacename="diffuseColor" />
      <input name="edge_color" type="color3" interfacename="diffuseColor" />
    </artistic_ior>
    <conductor_bsdf name="metalness_metal_bsdf" type="BSDF">
      <input name="weight" type="float" value="1" />
      <input name="ior" type="color3" nodename="artistic_ior" output="ior" />
      <input name="extinction" type="color3" nodename="artistic_ior" output="extinction" />
      <input name="roughness" type="vector2" nodename="specular_roughness" />
      <input name="normal" type="vector3" nodename="surface_normal" />
    </conductor_bsdf>
    <mix name="metalness_workflow_bsdf" type="BSDF">
      <input name="fg" type="BSDF" nodename="metalness_metal_bsdf" />
      <input name="bg" type="BSDF" nodename="metalness_specular_bsdf" />
      <input name="mix" type="float" interfacename="metallic" />
    </mix>

    <!-- Select Specular/Metalness workflow -->
    <convert name="use_specular_workflow_float" type="float">
      <input name="in" type="integer" interfacename="useSpecularWorkflow" />
    </convert>
    <mix name="workflow_selector_bsdf" type="BSDF">
      <input name="fg" type="BSDF" nodename="specular_workflow_bsdf" />
      <input name="bg" type="BSDF" nodename="metalness_workflow_bsdf" />
      <input name="mix" type="float" nodename="use_specular_workflow_float" />
    </mix>

    <!-- Clearcoat Layer -->
    <roughness_anisotropy name="coat_roughness" type="vector2">
      <input name="roughness" type="float" interfacename="clearcoatRoughness" />
      <input name="anisotropy" type="float" value="0" />
    </roughness_anisotropy>
    <dielectric_bsdf name="coat_dielectric_bsdf" type="BSDF">
      <input name="weight" type="float" interfacename="clearcoat" />
      <input name="tint" type="color3" value="1, 1, 1" />
      <input name="ior" type="float" value="1.5" />
      <input name="roughness" type="vector2" nodename="coat_roughness" />
      <input name="normal" type="vector3" nodename="surface_normal" />
    </dielectric_bsdf>
    <layer name="coat_bsdf" type="BSDF">
      <input name="top" type="BSDF" nodename="coat_dielectric_bsdf" />
      <input name="base" type="BSDF" nodename="workflow_selector_bsdf" />
    </layer>

    <!-- Emission Layer -->
    <uniform_edf name="emission_edf" type="EDF">
      <input name="color" type="color3" interfacename="emissiveColor" />
    </uniform_edf>

    <!-- Surface Shader Constructor -->
    <clamp name="opacity_clamped" type="float">
      <input name="in" type="float" interfacename="opacity" />
      <input name="low" type="float" value="0.00001" />
      <input name="high" type="float" value="1.0" />
    </clamp>
    <ifgreater name="cutout_opacity" type="float">
      <input name="value1" type="float" nodename="opacity_clamped" />
      <input name="value2" type="float" interfacename="opacityThreshold" />
      <input name="in1" type="float" value="1" />
      <input name="in2" type="float" value="0" />
    </ifgreater>
    <surface name="surface_constructor" type="surfaceshader">
      <input name="bsdf" type="BSDF" nodename="coat_bsdf" />
      <input name="edf" type="EDF" nodename="emission_edf" />
      <input name="opacity" type="float" nodename="cutout_opacity" />
    </surface>

    <!-- Output -->
    <output name="out" type="surfaceshader" nodename="surface_constructor" />
  </nodegraph>

  <!-- Node: UsdUVTexture -->
  <nodegraph name="IMP_UsdUVTexture_22" nodedef="ND_UsdUVTexture">
    <image name="image_reader" type="color4">
      <input name="file" type="filename" interfacename="file" />
      <input name="default" type="color4" interfacename="fallback" />
      <input name="texcoord" type="vector2" interfacename="st" />
      <input name="uaddressmode" type="string" interfacename="wrapS" />
      <input name="vaddressmode" type="string" interfacename="wrapT" />
    </image>
    <multiply name="image_scale" type="color4">
      <input name="in1" type="color4" nodename="image_reader" />
      <input name="in2" type="color4" interfacename="scale" />
    </multiply>
    <add name="image_bias" type="color4">
      <input name="in1" type="color4" nodename="image_scale" />
      <input name="in2" type="color4" interfacename="bias" />
    </add>
    <output name="r" type="float" nodename="image_bias" channels="r" />
    <output name="g" type="float" nodename="image_bias" channels="g" />
    <output name="b" type="float" nodename="image_bias" channels="b" />
    <output name="a" type="float" nodename="image_bias" channels="a" />
    <output name="rgb" type="color3" nodename="image_bias" channels="rgb" />
    <output name="rgba" type="color4" nodename="image_bias" />
  </nodegraph>

  <nodegraph name="IMP_UsdUVTexture_23" nodedef="ND_UsdUVTexture_23">
    <image name="image_reader" type="color4">
      <input name="file" type="filename" interfacename="file" />
      <input name="default" type="color4" interfacename="fallback" />
      <input name="texcoord" type="vector2" interfacename="st" />
      <input name="uaddressmode" type="string" interfacename="wrapS" />
      <input name="vaddressmode" type="string" interfacename="wrapT" />
    </image>
    <multiply name="image_scale" type="color4">
      <input name="in1" type="color4" nodename="image_reader" />
      <input name="in2" type="color4" interfacename="scale" />
    </multiply>
    <add name="image_bias" type="color4">
      <input name="in1" type="color4" nodename="image_scale" />
      <input name="in2" type="color4" interfacename="bias" />
    </add>
    <output name="r" type="float" nodename="image_bias" channels="r" />
    <output name="g" type="float" nodename="image_bias" channels="g" />
    <output name="b" type="float" nodename="image_bias" channels="b" />
    <output name="a" type="float" nodename="image_bias" channels="a" />
    <output name="rgb" type="color3" nodename="image_bias" channels="rgb" />
  </nodegraph>

  <nodegraph name="IMP_UsdUVTexture_23_NormalMap" nodedef="ND_UsdUVTexture_23_NormalMap">
    <input name="file" type="filename" uniform="true" value="" />
    <input name="st" type="vector2" value="0, 0" />
    <input name="wrapS" type="string" uniform="true" value="periodic" />
    <input name="wrapT" type="string" uniform="true" value="periodic" />
    <input name="fallback" type="vector3" value="0.5, 0.5, 1" />
    <input name="scale" type="vector3" value="2, 2, 2" />
    <input name="bias" type="vector3" value="-1, -1, -1" />
    <image name="image" type="vector3" >
      <input name="file" type="filename" uniform="true" interfacename="file" />
      <input name="default" type="vector3" interfacename="fallback" value="0.5, 0.5, 1" />
      <input name="texcoord" type="vector2" interfacename="st" value="0, 0" />
      <input name="uaddressmode" type="string" uniform="true" interfacename="wrapS" value="periodic" />
      <input name="vaddressmode" type="string" uniform="true" interfacename="wrapT" value="periodic" />
    </image>
    <add name="image_bias" type="vector3">
      <input name="in1" type="vector3" nodename="image_scale" />
      <input name="in2" type="vector3" interfacename="bias" value="-1, -1, -1" />
    </add>
    <multiply name="image_scale" type="vector3">
      <input name="in1" type="vector3" nodename="image" />
      <input name="in2" type="vector3" interfacename="scale" value="2, 2, 2" />
    </multiply>
    <constant name="constant" type="float">
      <input name="value" type="float" value="1" />
    </constant>
    <output name="r" type="float" nodename="image_bias" channels="x" />
    <output name="g" type="float" nodename="image_bias" channels="y"  />
    <output name="b" type="float" nodename="image_bias" channels="z"  />
    <output name="a" type="float" nodename="constant" />
    <output name="rgb" type="vector3" nodename="image_bias" />
  </nodegraph>

  <!-- Node: UsdPrimvarReader -->
  <nodegraph name="IMP_UsdPrimvarReader_integer" nodedef="ND_UsdPrimvarReader_integer">
    <geompropvalue name="primvar" type="integer">
      <input name="geomprop" type="string" interfacename="varname" />
      <input name="default" type="integer" interfacename="fallback" />
    </geompropvalue>
    <output name="out" type="integer" nodename="primvar" />
  </nodegraph>
  <nodegraph name="IMP_UsdPrimvarReader_boolean" nodedef="ND_UsdPrimvarReader_boolean">
    <geompropvalue name="primvar" type="boolean">
      <input name="geomprop" type="string" interfacename="varname" />
      <input name="default" type="boolean" interfacename="fallback" />
    </geompropvalue>
    <output name="out" type="boolean" nodename="primvar" />
  </nodegraph>
  <nodegraph name="IMP_UsdPrimvarReader_string" nodedef="ND_UsdPrimvarReader_string">
    <geompropvalue name="primvar" type="string">
      <input name="geomprop" type="string" interfacename="varname" />
      <input name="default" type="string" interfacename="fallback" />
    </geompropvalue>
    <output name="out" type="string" nodename="primvar" />
  </nodegraph>
  <nodegraph name="IMP_UsdPrimvarReader_float" nodedef="ND_UsdPrimvarReader_float">
    <geompropvalue name="primvar" type="float">
      <input name="geomprop" type="string" interfacename="varname" />
      <input name="default" type="float" interfacename="fallback" />
    </geompropvalue>
    <output name="out" type="float" nodename="primvar" />
  </nodegraph>
  <nodegraph name="IMP_UsdPrimvarReader_vector2" nodedef="ND_UsdPrimvarReader_vector2">
    <geompropvalue name="primvar" type="vector2">
      <input name="geomprop" type="string" interfacename="varname" />
      <input name="default" type="vector2" interfacename="fallback" />
    </geompropvalue>
    <output name="out" type="vector2" nodename="primvar" />
  </nodegraph>
  <nodegraph name="IMP_UsdPrimvarReader_vector3" nodedef="ND_UsdPrimvarReader_vector3">
    <geompropvalue name="primvar" type="vector3">
      <input name="geomprop" type="string" interfacename="varname" />
      <input name="default" type="vector3" interfacename="fallback" />
    </geompropvalue>
    <output name="out" type="vector3" nodename="primvar" />
  </nodegraph>
  <nodegraph name="IMP_UsdPrimvarReader_vector4" nodedef="ND_UsdPrimvarReader_vector4">
    <geompropvalue name="primvar" type="vector4">
      <input name="geomprop" type="string" interfacename="varname" />
      <input name="default" type="vector4" interfacename="fallback" />
    </geompropvalue>
    <output name="out" type="vector4" nodename="primvar" />
  </nodegraph>

  <!-- Node: UsdTransform2d -->
  <nodegraph name="IMP_UsdTransform2d" nodedef="ND_UsdTransform2d">
    <place2d name="placement" type="vector2">
      <input name="texcoord" type="vector2" interfacename="in" />
      <input name="scale" type="vector2" interfacename="scale" />
      <input name="rotate" type="float" interfacename="rotation" />
      <input name="offset" type="vector2" interfacename="translation" />
    </place2d>
    <output name="out" type="vector2" nodename="placement" />
  </nodegraph>

</materialx>
