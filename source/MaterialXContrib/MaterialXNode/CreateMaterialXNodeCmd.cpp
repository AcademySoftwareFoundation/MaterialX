#include "CreateMaterialXNodeCmd.h"
#include "MaterialXNode.h"
#include "MaterialXUtil.h"
#include "MayaUtil.h"
#include "Plugin.h"

#include <MaterialXFormat/XmlIo.h>

#include <maya/MArgParser.h>
#include <maya/MSelectionList.h>
#include <maya/MFnDependencyNode.h>
#include <maya/MSyntax.h>
#include <maya/MArgDatabase.h>
#include <maya/MStringArray.h>
#include <maya/MFnNumericAttribute.h>
#include <maya/MFnTypedAttribute.h>
#include <maya/MGlobal.h>

#include <maya/MViewport2Renderer.h>
#include <maya/MFragmentManager.h>

#include <algorithm>
#include <sstream>

namespace mx = MaterialX;

namespace
{
const char* const kDocumentFlag     = "d";
const char* const kElementFlag      = "e";

const char* const kTextureFlag      = "t";
const char* const kTextureFlagLong  = "asTexture";

const char* const kOgsXmlFlag       = "x";
const char* const kOgsXmlFlagLong   = "ogsXml";

void registerDebugFragment(const std::string& ogsXmlFileName)
{
    // Use the fragment from an explicitly provided file instead of
    // the one generated by MaterialXData - this can be used for debugging.
    //
    MHWRender::MRenderer* const theRenderer = MHWRender::MRenderer::theRenderer();
    MHWRender::MFragmentManager* const fragmentManager =
        theRenderer ? theRenderer->getFragmentManager() : nullptr;

    if (!fragmentManager)
    {
        throw std::runtime_error("Failed to get the VP2 fragment manager");
    }

    // If explicit XML file specified use it.
    const mx::FilePath ogsXmlPath =
        Plugin::instance().getResourceSearchPath().find(ogsXmlFileName);

    if (ogsXmlPath.isEmpty())
    {
        throw mx::Exception("Failed to find the explicitly provided fragment file.");
    }

    constexpr bool hidden = false;
    const MString registeredFragment =
        fragmentManager->addShadeFragmentFromFile(ogsXmlPath.asString().c_str(), hidden);

    if (registeredFragment.length() == 0)
    {
        throw mx::Exception("Failed to register debug fragment from file.");
    }
}
} // anonymous namespace

MString CreateMaterialXNodeCmd::NAME("createMaterialXNode");

CreateMaterialXNodeCmd::CreateMaterialXNodeCmd()
{
}

CreateMaterialXNodeCmd::~CreateMaterialXNodeCmd()
{
}

MStatus CreateMaterialXNodeCmd::doIt( const MArgList &args )
{
    // Parse the shader node
    //
    MArgParser parser(syntax(), args);

    MStatus status;
    MArgDatabase argData(syntax(), args, &status);
    if (!status)
        return status;

    MString elementPath;
    try
    {
        MString documentFilePath;
        if (parser.isFlagSet(kDocumentFlag))
        {
            CHECK_MSTATUS(argData.getFlagArgument(kDocumentFlag, 0, documentFilePath));
        }

        if (documentFilePath.length() == 0)
        {
            throw mx::Exception("MaterialX document file path is empty.");
        }

        if (parser.isFlagSet(kElementFlag))
        {
            CHECK_MSTATUS(argData.getFlagArgument(kElementFlag, 0, elementPath));
        }

        mx::DocumentPtr document = MaterialXMaya::loadDocument(
            documentFilePath.asChar(), Plugin::instance().getLibrarySearchPath()
        );

        std::unique_ptr<MaterialXData> materialXData{
            new MaterialXData(document,
                              elementPath.asChar(),
                              Plugin::instance().getLibrarySearchPath())
        };

        MString ogsXmlFileName;
        if (parser.isFlagSet(kOgsXmlFlag))
        {
            CHECK_MSTATUS(argData.getFlagArgument(kOgsXmlFlag, 0, ogsXmlFileName));
        }

        if (ogsXmlFileName.length() > 0)
        {
            ::registerDebugFragment(ogsXmlFileName.asChar());
        }
        else
        {
            MaterialXMaya::registerFragment(
                materialXData->getFragmentName(), materialXData->getFragmentSource()
            );
        }

        elementPath.set(materialXData->getElementPath().c_str());
        if (elementPath.length() == 0)
        {
            throw mx::Exception("The element specified is not renderable.");
        }

        // Decide what kind of node we want to create
        bool asTexture = false;
        if (parser.isFlagSet(kTextureFlag))
        {
            CHECK_MSTATUS(argData.getFlagArgument(kTextureFlag, 0, asTexture));
        }
        else
        {
            asTexture = !materialXData->elementIsAShader();
        }

        // Create the MaterialX node
        MObject node = _dgModifier.createNode(
            asTexture ? MaterialXTextureNode::MATERIALX_TEXTURE_NODE_TYPEID
            : MaterialXSurfaceNode::MATERIALX_SURFACE_NODE_TYPEID
        );

        // Generate a valid Maya node name from the path string
        {
            const std::string nodeName = mx::createValidName(elementPath.asChar());
            _dgModifier.renameNode(node, nodeName.c_str());
        }

        MFnDependencyNode depNode(node);
        auto materialXNode = dynamic_cast<MaterialXNode*>(depNode.userNode());
        if (!materialXNode)
        {
            throw mx::Exception("Unexpected DG node type.");
        }

        materialXNode->setData(documentFilePath, elementPath, std::move(materialXData));
        materialXNode->createOutputAttr(_dgModifier);

        _dgModifier.doIt();

        MString message("Created ");
        message += materialXNode->typeName();
        message += " node: ";
        message += materialXNode->name();
        MGlobal::displayInfo(message);
        return MS::kSuccess;
    }
    catch (std::exception& e)
    {
        MString message("Failed to create MaterialX node: ");
        message += MString(e.what());
        MGlobal::displayError(message);
        return MS::kFailure;
    }
 }

MSyntax CreateMaterialXNodeCmd::newSyntax()
{
    MSyntax syntax;
    syntax.addFlag(kDocumentFlag, MaterialXNode::DOCUMENT_ATTRIBUTE_LONG_NAME.asChar(), MSyntax::kString);
    syntax.addFlag(kElementFlag, MaterialXNode::ELEMENT_ATTRIBUTE_LONG_NAME.asChar(), MSyntax::kString);
    syntax.addFlag(kOgsXmlFlag, kOgsXmlFlagLong, MSyntax::kString);
    syntax.addFlag(kTextureFlag, kTextureFlagLong, MSyntax::kBoolean);
    return syntax;
}

void* CreateMaterialXNodeCmd::creator()
{
    return new CreateMaterialXNodeCmd();
}
