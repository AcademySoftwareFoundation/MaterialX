#ifndef MATERIALX_GLSLVALIDATOR_H
#define MATERIALX_GLSLVALIDATOR_H

#include <MaterialXShaderGen/HwShader.h>
#include <MaterialXView/Image/ImageHandler.h>
#include <vector>
#include <string>
#include <unordered_map>

namespace MaterialX
{

/// Error string list type
using ShaderValidationErrorList = std::vector<std::string>;

/// @class @GlslValidator
/// Helper class to perform validation of GLSL source code generated by the GLSL code generator.
///
/// There are two main interfaces which can be used. One which takes in a HwShader and one which
/// allows for explicit setting of shader stage code.
///
/// The main services provided are:
///     - Validation: All shader stages are compiled and atteched to a GLSL shader program.
///     - Introspection: The compiled shader program is examined for uniforms and attributes.
///     - Binding: Uniforms and attributes which match the predefined variables generated the GLSL code generator
///       will have values assigned to this. This includes matrices, attribute streams, and textures.
///     - Rendering: The program with bound inputs will be used to drawing geometry to an offscreen buffer.
///     An interface is provided to save this offscreen buffer to disk using an externally defined image handler.
///
class GlslValidator
{
  public:
    /// Structure to hold information about program inputs
    struct ProgramInput
    {
        static int INVALID_OPENGL_TYPE;

        /// Program location. -1 means an invalid location
        int _location;
        /// OpenGL type of the input. -1 means an invalid type
        int _type;
        /// Size.
        int _size;

        /// Program input constructor
        ProgramInput(int inputLocation, int inputType, int inputSize)
        : _location(inputLocation)
        , _type(inputType)
        , _size(inputSize)
        {}
    };
    /// Program input structure shared pointer type
    using ProgramInputPtr = std::shared_ptr<ProgramInput>;
    /// Program input shaded pointer map type
    using ProgramInputMap = std::unordered_map<std::string, ProgramInputPtr>;

    /// Constructor
    GlslValidator();

    /// Destructor
    virtual ~GlslValidator();

    /// @name Setup
    /// @{

    /// Internal initialization of stages and OpenGL contstructs
    /// required for program validation and rendering.
    /// An exception is thrown on failure.
    /// The exception will contain a list of initialization errors.
    void initialize();

    /// Set up code stages to validate based on an input hardware shader.
    /// @param shader Hardware shader to use
    void setStages(const HwShaderPtr shader);

    /// This method can be used to incrementally set the code stages before validation.
    /// @param code Shader code string for a given stage
    /// @param stage Shader stage. See stages allowed in the class HwShader.
    void setStage(const std::string& code, size_t stage);

    /// Get code string for a given stage
    /// @return Shader stage string. String is empty if not found.
    const std::string getStage(size_t stage) const;

    /// Get the number of stages
    /// @return Stage count
    size_t numStages() const
    {
        return HwShader::NUM_STAGES;
    }

    /// Clear out any existing stages
    void clearStages();

    /// @}
    /// @name Program handling
    /// @{

    /// Create the shader program from stages specified
    /// An exception is thrown if the program cannot be created.
    /// The exception will contain a list of program creation errors.
    /// @return Program identifier. 
    unsigned int createProgram();

    /// Get list of program input uniforms. 
    /// The program must have been created successfully first.
    /// An exception is thrown if the parsing of the program for uniforms cannot be performed.
    /// @return Program uniforms list.
    const ProgramInputMap& getUniformsList();

    /// Get list of program input attributes. 
    /// The program must have been created successfully first.
    /// An exception is thrown if the parsing of the program for attribute cannot be performed.
    /// @return Program attributes list.
    const ProgramInputMap& getAttributesList();

    /// Delete any currently created shader program
    void deleteProgram();

    /// @}
    /// @name Visualization
    /// @{

    /// Render to buffer
    void render();

    /// Save buffer to disk
    /// @param fileName Name of file to save rendered image to.
    /// @param imageHandler Handler used to save image
    /// @return true if successful
    void save(std::string& fileName, const ImageHandlerPtr imageHandler);

    /// @}

  protected:
    /// Internal cleanup of stages and OpenGL constructs
    void cleanup();

    /// Check if there is a valid set of stages to build program from
    bool haveValidStages() const;

    /// @name Target handling
    /// @{

    /// Create a offscreen target used for rendering.
    bool createTarget();
    /// Delete any created offscreen target.
    void deleteTarget();
    /// Bind or unbind any created offscree target.
    bool bindTarget(bool bind);

    /// @}
    /// @name Program introspection
    /// @{

    /// Update a list of program input uniforms
    const ProgramInputMap& updateUniformsList();

    /// Update a list of program input attributes
    const ProgramInputMap& updateAttributesList();

    /// Clear out any cached input lists
    void clearInputLists();

    /// Index used to access cached attribute buffers
    enum AttributeIndex {
        POSITION3_ATTRIBUTE = 0,/// 3 float position attribute 
        NORMAL3_ATTRIBUTE,      /// 3 float normal attribute 
        TANGENT3_ATTRIBUTE,     /// 3 float tangent attribute
        BITANGENT3_ATTRIBUTE,   /// 3 float bitangent attribute 
        TEXCOORD2_ATTRIBUTE,    /// 2 float texture coordinate attribute
        COLOR4_ATTRIBUTE,       /// 4 float color attribute 
        ATTRIBUTE_COUNT         /// Number of attribute types
    };
    /// Bind attribute buffers by scanning for a given attribute identifier.
    /// If either an exact match for the identifier, or the identifier is a prefix of an attribute name then 
    /// a hardware buffer of the given attribute type is created and bound to the program location
    /// for the attribute.
    /// @param bufferData Block of buffer data 
    /// @param bufferSize Size of buffer data.
    /// @param attributeId Identifier of program attribute to search for
    /// @param attributeIndex Indicator for type of buffer to create
    /// @param floatCount Number of floats per channel in the buffer
    /// @param exactMatch Check for exact identifier matches
    bool bindAttribute(const float *bufferData, size_t bufferSize,
                       const std::string& attributeId,
                       const GlslValidator::AttributeIndex attributeIndex,
                       unsigned int floatCount,
                       bool exactMatch);

    /// @}
    /// @name Program bindings
    /// @{

    /// Bind inputs
    void bindInputs();

    /// Bind viewing information
    void bindViewInformation();

    /// Bind input geometry streams
    void bindGeometry();

    /// Unbind any bound geometry
    void unbindGeometry();

    /// Bind any input textures
    void bindTextures();

    /// Unbind input textures
    void unbindTextures();

    /// Bind time and frame uniforms
    void bindTimeAndFrame();

  private:
    /// Find the locations in the program which start with a given variable name
    /// @param variable Variable to search for
    /// @param variableList List of program inputs to search
    /// @param foundList Returned list of found program inputs. Empty if none found
    /// @param exactMatch Search for exact variable name match.
    void findProgramInputs(const std::string& variable,
                              const ProgramInputMap& variableList,
                              ProgramInputMap& foundList,
                              bool exactMatch);

    /// Dummy texture for testing with
    void createDummyTexture(bool colored);

    /// Utility to check for OpenGL context errors.
    /// Will throw an ExceptionShaderValidationError exception which will list of the errors found
    /// if any errors encountered.
    void checkErrors();
      
    /// Stages used to create program
    std::string _stages[HwShader::NUM_STAGES];

    /// Generated program. A non-zero number indicates a valid shader program.
    unsigned int _programId;

    /// Hardware color target (texture)
    unsigned int _colorTarget;

    /// Hardware depth target (texture)
    unsigned int _depthTarget;

    /// Hardware frame buffer object
    unsigned int _frameBuffer;

    /// Width of the frame buffer / targets to use. 
    unsigned int _frameBufferWidth;
    /// Height of the frame buffer / targets to use. 
    unsigned int _frameBufferHeight;

    /// Attribute buffer resource handles
    std::vector<unsigned int> _attributeBufferIds;
    
    /// Attribute indexing buffer handle
    unsigned int _indexBuffer;
    /// Size of index buffer
    unsigned int _indexBufferSize;
    
    /// Attribute vertex array handle
    unsigned int _vertexArray;

    /// List of program input uniforms
    ProgramInputMap _uniformList;
    /// List of program input attributes
    ProgramInputMap _attributeList;

    /// Dummy texture
    unsigned int _dummyTexture;

    /// Hardware shader (if any) used for program creation
    HwShaderPtr _hwShader;

    /// Flag to indicate if validator has been initialized properly.
    bool _initialized;

    static unsigned int UNDEFINED_OPENGL_RESOURCE_ID;
    static int UNDEFINED_OPENGL_PROGRAM_LOCATION;
};

/// @class @ExceptionShaderValidationError
/// An exception that is thrown when shader validation fails.
/// An error log of shader errors is cached as part of the exception.
/// For example, if shader compilation fails, then a list of compilation errors is cached.
class ExceptionShaderValidationError : public Exception
{
public:
    ExceptionShaderValidationError(const string& msg, const ShaderValidationErrorList& errorList) :
        Exception(msg),
        _errorLog(errorList)
    {
    }

    ExceptionShaderValidationError(const ExceptionShaderValidationError& e) :
        Exception(e)
    {
        _errorLog = e._errorLog;
    }

    ExceptionShaderValidationError& operator=(const ExceptionShaderValidationError& e)         
    {
        Exception::operator=(e);
        _errorLog = e._errorLog;
        return *this;
    }

    virtual ~ExceptionShaderValidationError() throw()
    {
    }

    ShaderValidationErrorList _errorLog;
};

} // namespace MaterialX
#endif
