#include "OgsFragment.h"

#include <MaterialXFormat/XmlIo.h>
#include <MaterialXGenShader/Util.h>
#include <MaterialXGenShader/DefaultColorManagementSystem.h>
#include <MaterialXGenOgsXml/GlslFragmentGenerator.h>
#include <MaterialXGenShader/GenContext.h>
#include <MaterialXGenOgsXml/OgsXmlGenerator.h>

#ifdef MATERIALX_BUILD_CROSS
#include <MaterialXCross/Cross.h>
#endif

#include <iostream>

namespace MaterialXMaya
{

namespace
{
mx::GenContext createGlslGenerator(mx::ElementPtr element, const mx::FileSearchPath& librarySearchPath)
{
    bool isSurface = false;
    if (element->asA<mx::ShaderRef>())
    {
        isSurface = true;
    }
    else if (!element->asA<mx::Output>())
    {
        // Should never occur as we pre-filter renderables before creating the node + override
        throw mx::Exception("Invalid element to create fragment for " + element->getName());
    }

    mx::ShaderGeneratorPtr generator = mx::GlslFragmentGenerator::create();
    mx::GenContext genContext(generator);
    mx::GenOptions& genOptions = genContext.getOptions();

    // Set up color management. We assume the target render space is linear
    // if not found in the document. Currently the default system has no other color space targets.
    //
    if ( mx::DefaultColorManagementSystemPtr colorManagementSystem =
        mx::DefaultColorManagementSystem::create(generator->getLanguage())
    )
    {
        generator->setColorManagementSystem(colorManagementSystem);

        mx::DocumentPtr document = element->getDocument();
        colorManagementSystem->loadLibrary(document);
        const std::string& documentColorSpace = document->getAttribute(mx::Element::COLOR_SPACE_ATTRIBUTE);

        static const std::string MATERIALX_LINEAR_WORKING_SPACE("lin_rec709");
        genOptions.targetColorSpaceOverride =
            documentColorSpace.empty() ? MATERIALX_LINEAR_WORKING_SPACE : documentColorSpace;
    }

    // Use FIS environment lookup for surface shader generation but
    // disable for texture nodes to avoid additional unneeded XML parameter
    // generation.
    genContext.registerSourceCodeSearchPath(librarySearchPath);
    genOptions.hwSpecularEnvironmentMethod =
        isSurface ? mx::SPECULAR_ENVIRONMENT_FIS : mx::SPECULAR_ENVIRONMENT_NONE;

    // Set to use no direct lighting
    genOptions.hwMaxActiveLightSources = 0;

    // Maya images require a texture coordinates to be flipped in V.
    genOptions.fileTextureVerticalFlip = true;
    genOptions.hwTransparency = mx::isTransparentSurface(element, *generator);

    // Maya viewport uses texture atlas for tile image so enabled
    // texture coordinate transform to go from original UDIM range to
    // normalized 0..1 range.
    genOptions.hwNormalizeUdimTexCoords = true;

    return genContext;
}
}

OgsFragment::OgsFragment(
    mx::ElementPtr element,
    const mx::FileSearchPath& librarySearchPath
)
    : _element(element)
{
    if (!_element)
    {
        throw mx::Exception("No element specified");
    }

    try
    {
        generateFragment(librarySearchPath);
    }
    catch (std::exception& e)
    {
        throw mx::Exception(std::string("Failed to generate OGS shader fragment: ") + e.what());
    }
}

OgsFragment::~OgsFragment()
{
}

const std::string& OgsFragment::getFragmentName() const
{
    return _fragmentName;
}

const std::string& OgsFragment::getFragmentSource() const
{
    return _fragmentSource;
}

const mx::StringMap& OgsFragment::getPathInputMap() const
{
    return _pathInputMap;
}

bool OgsFragment::isElementAShader() const
{
    return _element && _element->isA<mx::ShaderRef>();
}

void OgsFragment::generateFragment(const mx::FileSearchPath& librarySearchPath)
{
    if (!_element)
    {
        throw mx::Exception("Element is NULL");
    }

    std::string baseFragmentName = mx::createValidName(_element->getNamePath());

    {
        mx::GenContext glslGenContext = createGlslGenerator(_element, librarySearchPath);
        _glslShader = glslGenContext.getShaderGenerator().generate(baseFragmentName, _element, glslGenContext);
        if (!_glslShader)
        {
            throw mx::Exception("Failed to generate shader");
        }

        _isTransparent = glslGenContext.getOptions().hwTransparency;
    }

    static const std::string FRAGMENT_NAME_TOKEN = "$fragmentName";

    {
        std::string hlslSource;
#ifdef MATERIALX_BUILD_CROSS
        try
        {
            // Cross-compile GLSL fragment code generated by MaterialX to HLSL
            //
            hlslSource = mx::Cross::glslToHlsl(
                _glslShader->getSourceCode(mx::Stage::PRIVATE_UNIFORMS),
                _glslShader->getSourceCode(mx::Stage::PIXEL),
                baseFragmentName
            );
        }
        catch (std::exception& e)
        {
            std::cerr << "Failed to cross-compile GLSL fragment to HLSL: " << e.what() <<"\n";
        }
#endif
        _fragmentSource = mx::OgsXmlGenerator::generate(FRAGMENT_NAME_TOKEN, *_glslShader, hlslSource, _isTransparent);
        if (_fragmentSource.empty())
        {
            throw mx::Exception("Generated fragment source is empty");
        }
    }

    // Strip out any '\r' characters.
    _fragmentSource.erase(
        std::remove(_fragmentSource.begin(), _fragmentSource.end(), '\r'), _fragmentSource.end()
    );

    {
        std::ostringstream nameStream;
        const size_t sourceHash = std::hash<std::string>{}(_fragmentSource);
        nameStream << baseFragmentName << "__" << std::hex << sourceHash;
        _fragmentName = nameStream.str();
    }

    {
        // Note: This name must match the fragment name used for fragment
        // registration in Maya API or the registration will fail.
        //
        const mx::StringMap substitutions{ {FRAGMENT_NAME_TOKEN, _fragmentName} };
        mx::tokenSubstitution(substitutions, _fragmentSource);
    }

    // Extract out the input fragment parameter names along with their
    // associated Element paths to allow for value binding.
    //
    const mx::ShaderStage& pixelShader = _glslShader->getStage(mx::Stage::PIXEL);
    for (const auto& uniformBlock : pixelShader.getUniformBlocks())
    {
        const mx::VariableBlock& uniforms = *uniformBlock.second;

        // Skip light uniforms
        if (uniforms.getName() == mx::HW::LIGHT_DATA)
        {
            continue;
        }

        for (size_t i = 0; i < uniforms.size(); ++i)
        {
            const mx::ShaderPort* const port = uniforms[i];
            const std::string& path = port->getPath();
            if (!path.empty())
            {
                const std::string& variableName = port->getVariable();
                if (port->getType()->getSemantic() == mx::TypeDesc::SEMANTIC_FILENAME)
                {
                    std::string textureName = mx::OgsXmlGenerator::samplerToTextureName(variableName);
                    if (!textureName.empty())
                    {
                        _pathInputMap[path] = textureName;
                        continue;
                    }
                }
                _pathInputMap[path] = variableName;
            }
        }
    }
}

mx::ImageSamplingProperties OgsFragment::getImageSamplingProperties(const std::string& fileParameterName) const
{
    mx::ImageSamplingProperties samplingProperties;
    if (_glslShader && _glslShader->hasStage(mx::Stage::PIXEL))
    {
        mx::ShaderStage& stage = _glslShader->getStage(mx::Stage::PIXEL);
        mx::VariableBlock& block = stage.getUniformBlock(mx::HW::PUBLIC_UNIFORMS);
        samplingProperties.setProperties(fileParameterName, block);

    }
    return samplingProperties;
}

std::string OgsFragment::getMatrix4Name(const std::string& matrix3Name)
{
    return matrix3Name + mx::GlslFragmentGenerator::MATRIX3_TO_MATRIX4_POSTFIX;
}

} // namespace MaterialXMaya
