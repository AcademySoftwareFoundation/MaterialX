#include "OgsFragment.h"

#include <MaterialXFormat/XmlIo.h>
#include <MaterialXGenShader/Util.h>
#include <MaterialXGenShader/DefaultColorManagementSystem.h>
#include <MaterialXGenOgsXml/GlslFragmentGenerator.h>
#include <MaterialXGenShader/GenContext.h>
#include <MaterialXGenOgsXml/OgsXmlGenerator.h>

#ifdef MATERIALX_BUILD_CROSS
#include <MaterialXCross/Cross.h>
#endif

#include <iostream>

namespace MaterialXMaya
{

OgsFragment::OgsFragment(
    mx::ElementPtr element,
    const mx::FileSearchPath& librarySearchPath
)
    : _element(element)
{
    if (!_element)
    {
        throw mx::Exception("No element specified");
    }

    try
    {
        generateFragment(librarySearchPath);
    }
    catch (std::exception& e)
    {
        throw mx::Exception(std::string("Failed to generate OGS shader fragment: ") + e.what());
    }
}

OgsFragment::~OgsFragment()
{
}

const std::string& OgsFragment::getFragmentName() const
{
    return _fragmentName;
}

const std::string& OgsFragment::getFragmentSource() const
{
    return _fragmentSource;
}

const mx::StringMap& OgsFragment::getPathInputMap() const
{
    return _pathInputMap;
}

bool OgsFragment::isElementAShader() const
{
    return _element && _element->isA<mx::ShaderRef>();
}

void OgsFragment::generateFragment(const mx::FileSearchPath& librarySearchPath)
{
    if (!_element)
    {
        throw mx::Exception("Element is NULL");
    }

    bool isSurface = false;
    if (_element->asA<mx::ShaderRef>())
    {
        isSurface = true;
    }
    else if (!_element->asA<mx::Output>())
    {
        // Should never occur as we pre-filter renderables before creating the node + override
        throw mx::Exception("Invalid element to create fragment for " + _element->getName());
    }

    {
        mx::ShaderGeneratorPtr glslGenerator = mx::GlslFragmentGenerator::create();
        mx::GenContext genContext(glslGenerator);
        mx::GenOptions& genOptions = genContext.getOptions();

        // Set up color management. We assume the target render space is linear
        // if not found in the document. Currently the default system has no other color space targets.
        //
        if ( mx::DefaultColorManagementSystemPtr colorManagementSystem =
            mx::DefaultColorManagementSystem::create(glslGenerator->getLanguage())
        )
        {
            glslGenerator->setColorManagementSystem(colorManagementSystem);

            mx::DocumentPtr document = _element->getDocument();
            colorManagementSystem->loadLibrary(document);
            const std::string& documentColorSpace = document->getAttribute(mx::Element::COLOR_SPACE_ATTRIBUTE);

            static const std::string MATERIALX_LINEAR_WORKING_SPACE("lin_rec709");
            genOptions.targetColorSpaceOverride =
                documentColorSpace.empty() ? MATERIALX_LINEAR_WORKING_SPACE : documentColorSpace;
        }

        // Use FIS environment lookup for surface shader generation but
        // disable for textures to avoid additional unneeded XML parameter
        // generation.
        genContext.registerSourceCodeSearchPath(librarySearchPath);
        genOptions.hwSpecularEnvironmentMethod =
            isSurface ? mx::SPECULAR_ENVIRONMENT_FIS : mx::SPECULAR_ENVIRONMENT_NONE;

        // Set to use no direct lighting
        genOptions.hwMaxActiveLightSources = 0;
        
        // Maya images require a texture coordinates to be flipped in V.
        genOptions.fileTextureVerticalFlip = true;

        _isTransparent = mx::isTransparentSurface(_element, *glslGenerator);
        genOptions.hwTransparency = _isTransparent;

        // Maya viewport uses texture atlas for tile image so enabled
        // texture coordinate transform to go from original UDIM range to
        // normalized 0..1 range.
        genOptions.hwNormalizeUdimTexCoords = true;

        // Generate the fragment source (shader and XML wrapper).
        _fragmentName = _element->getNamePath();
        _fragmentName = mx::createValidName(_fragmentName);

        _glslShader = glslGenerator->generate(_fragmentName, _element, genContext);
        if (!_glslShader)
        {
            throw mx::Exception("Failed to generate shader");
        }
    }

    static const std::string FRAGMENT_NAME_TOKEN = "$fragmentName";

    {
        std::string hlslSource;
#ifdef MATERIALX_BUILD_CROSS
        try
        {
            // Cross-compile GLSL fragment code generated by MaterialX to HLSL
            //
            hlslSource = mx::Cross::glslToHlsl(
                _glslShader->getSourceCode(mx::Stage::PRIVATE_UNIFORMS),
                _glslShader->getSourceCode(mx::Stage::PIXEL),
                _fragmentName
            );
        }
        catch (std::exception& e)
        {
            std::cerr << "Failed to cross-compile GLSL fragment to HLSL: " << e.what() <<"\n";
        }
#endif
        std::ostringstream sourceStream;
         mx::OgsXmlGenerator::generate(FRAGMENT_NAME_TOKEN, *_glslShader, hlslSource, _isTransparent, sourceStream);
        _fragmentSource = sourceStream.str();
        if (_fragmentSource.empty())
        {
            throw mx::Exception("Generated fragment source is empty");
        }
    }

    // Strip out any '\r' characters.
    _fragmentSource.erase(
        std::remove(_fragmentSource.begin(), _fragmentSource.end(), '\r'), _fragmentSource.end()
    );

    {
        std::ostringstream nameStream;

        const size_t sourceHash = std::hash<std::string>{}(_fragmentSource);
        nameStream << _fragmentName << "__" << std::hex << sourceHash;

        _fragmentName = nameStream.str();
    }

    {
        // Note: This name must match the fragment name used for fragment
        // registration in Maya API or the registration will fail.
        //
        const mx::StringMap substitutions{ {FRAGMENT_NAME_TOKEN, _fragmentName} };
        mx::tokenSubstitution(substitutions, _fragmentSource);
    }

    // Extract out the input fragment parameter names along with their
    // associated Element paths to allow for value binding.
    //
    const mx::ShaderStage& pixelShader = _glslShader->getStage(mx::Stage::PIXEL);
    for (const auto& uniformBlock : pixelShader.getUniformBlocks())
    {
        const mx::VariableBlock& uniforms = *uniformBlock.second;

        // Skip light uniforms
        if (uniforms.getName() == mx::HW::LIGHT_DATA)
        {
            continue;
        }

        for (size_t i = 0; i < uniforms.size(); ++i)
        {
            const mx::ShaderPort* const port = uniforms[i];
            const std::string& path = port->getPath();
            if (!path.empty())
            {
                const std::string& variableName = port->getVariable();
                if (port->getType()->getSemantic() == mx::TypeDesc::SEMANTIC_FILENAME)
                {
                    std::string textureName = mx::OgsXmlGenerator::samplerToTextureName(variableName);
                    if (!textureName.empty())
                    {
                        _pathInputMap[path] = textureName;
                        continue;
                    }
                }
                _pathInputMap[path] = variableName;
            }
        }
    }
}

mx::ImageSamplingProperties OgsFragment::getImageSamplingProperties(const std::string& fileParameterName) const
{
    mx::ImageSamplingProperties samplingProperties;
    if (_glslShader && _glslShader->hasStage(mx::Stage::PIXEL))
    {
        mx::ShaderStage& stage = _glslShader->getStage(mx::Stage::PIXEL);
        mx::VariableBlock& block = stage.getUniformBlock(mx::HW::PUBLIC_UNIFORMS);
        samplingProperties.setProperties(fileParameterName, block);

    }
    return samplingProperties;
}

std::string OgsFragment::getMatrix4Name(const std::string& matrix3Name)
{
    return matrix3Name + mx::GlslFragmentGenerator::MATRIX3_TO_MATRIX4_POSTFIX;
}

} // namespace MaterialXMaya
