From 189551e39c836c757871cad0c67e703f856b8c14 Mon Sep 17 00:00:00 2001
From: Morteza Mostajab <smostajabodaveh@apple.com>
Date: Fri, 3 Mar 2023 13:31:06 +0000
Subject: [PATCH] Fixes a typo

---
 source/MaterialXGenMsl/MslShaderGenerator.cpp | 6 +++---
 source/MaterialXGenMsl/MslShaderGenerator.h   | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/source/MaterialXGenMsl/MslShaderGenerator.cpp b/source/MaterialXGenMsl/MslShaderGenerator.cpp
index ad76e0da..5eede5fa 100644
--- a/source/MaterialXGenMsl/MslShaderGenerator.cpp
+++ b/source/MaterialXGenMsl/MslShaderGenerator.cpp
@@ -618,7 +618,7 @@ void MslShaderGenerator::emitVertexStage(const ShaderGraph& graph, GenContext& c
     }
     emitLineBreak(stage);
 
-    emitConstantBufferDeclerations(context, resourceBindingCtx, stage);
+    emitConstantBufferDeclarations(context, resourceBindingCtx, stage);
 
     // Add vertex inputs
     emitInputs(context, stage);
@@ -758,7 +758,7 @@ void MslShaderGenerator::emitConstants(GenContext& context, ShaderStage& stage)
     }
 }
 
-void MslShaderGenerator::emitConstantBufferDeclerations(GenContext& context,
+void MslShaderGenerator::emitConstantBufferDeclarations(GenContext& context,
                                                         HwResourceBindingContextPtr resourceBindingCtx,
                                                         ShaderStage& stage) const
 {
@@ -1032,7 +1032,7 @@ void MslShaderGenerator::emitPixelStage(const ShaderGraph& graph, GenContext& co
     // Add type definitions
     emitTypeDefinitions(context, stage);
     
-    emitConstantBufferDeclerations(context, resourceBindingCtx, stage);
+    emitConstantBufferDeclarations(context, resourceBindingCtx, stage);
 
     // Add all constants
     emitConstants(context, stage);
diff --git a/source/MaterialXGenMsl/MslShaderGenerator.h b/source/MaterialXGenMsl/MslShaderGenerator.h
index 529f2c36..094a06b3 100644
--- a/source/MaterialXGenMsl/MslShaderGenerator.h
+++ b/source/MaterialXGenMsl/MslShaderGenerator.h
@@ -68,7 +68,7 @@ class MX_GENMSL_API MslShaderGenerator : public HwShaderGenerator
     virtual string MathMatrixScalarMathOperators() const;
     virtual void MetalizeGeneratedShader(ShaderStage& shaderStage) const;
  
-    void emitConstantBufferDeclerations(GenContext& context,
+    void emitConstantBufferDeclarations(GenContext& context,
                                         HwResourceBindingContextPtr resourceBindingCtx,
                                         ShaderStage& stage) const;
     
-- 
2.37.0

From 2704630c1e82722dfc26969174ea61247747baff Mon Sep 17 00:00:00 2001
From: Morteza Mostajab <smostajabodaveh@apple.com>
Date: Fri, 3 Mar 2023 13:32:08 +0000
Subject: [PATCH] Inherits genmsl from genglsl. Removing unncessary files

---
 libraries/stdlib/genmsl/lib/mx_hsv.metal      |  91 ---
 libraries/stdlib/genmsl/lib/mx_noise.metal    | 636 ------------------
 .../genmsl/lib/mx_transform_color.metal       |  18 -
 .../stdlib/genmsl/lib/mx_transform_uv.metal   |   5 -
 .../genmsl/lib/mx_transform_uv_vflip.metal    |   5 -
 libraries/targets/genmsl.mtlx                 |   2 +-
 6 files changed, 1 insertion(+), 756 deletions(-)
 delete mode 100644 libraries/stdlib/genmsl/lib/mx_hsv.metal
 delete mode 100644 libraries/stdlib/genmsl/lib/mx_noise.metal
 delete mode 100644 libraries/stdlib/genmsl/lib/mx_transform_color.metal
 delete mode 100644 libraries/stdlib/genmsl/lib/mx_transform_uv.metal
 delete mode 100644 libraries/stdlib/genmsl/lib/mx_transform_uv_vflip.metal

diff --git a/libraries/stdlib/genmsl/lib/mx_hsv.metal b/libraries/stdlib/genmsl/lib/mx_hsv.metal
deleted file mode 100644
index 923e9eac..00000000
--- a/libraries/stdlib/genmsl/lib/mx_hsv.metal
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
-Color transform functions.
-
-These funcions are modified versions of the color operators found in Open Shading Language:
-github.com/imageworks/OpenShadingLanguage/blob/master/src/liboslexec/opcolor.cpp
-
-It contains the subset of color operators needed to implement the MaterialX
-standard library. The modifications are for conversions from C++ to GLSL.
-
-Original copyright notice:
-------------------------------------------------------------------------
-Copyright (c) 2009-2010 Sony Pictures Imageworks Inc., et al.
-All Rights Reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-* Redistributions of source code must retain the above copyright
-  notice, this list of conditions and the following disclaimer.
-* Redistributions in binary form must reproduce the above copyright
-  notice, this list of conditions and the following disclaimer in the
-  documentation and/or other materials provided with the distribution.
-* Neither the name of Sony Pictures Imageworks nor the names of its
-  contributors may be used to endorse or promote products derived from
-  this software without specific prior written permission.
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-------------------------------------------------------------------------
-*/
-
-vec3 mx_hsvtorgb(vec3 hsv)
-{
-    // Reference for this technique: Foley & van Dam
-    float h = hsv.x; float s = hsv.y; float v = hsv.z;
-    if (s < 0.0001f) {
-      return vec3 (v, v, v);
-    } else {
-        h = 6.0f * (h - floor(h));  // expand to [0..6)
-        int hi = int(trunc(h));
-        float f = h - float(hi);
-        float p = v * (1.0f-s);
-        float q = v * (1.0f-s*f);
-        float t = v * (1.0f-s*(1.0f-f));
-        if (hi == 0)
-            return vec3 (v, t, p);
-        else if (hi == 1)
-            return vec3 (q, v, p);
-        else if (hi == 2)
-            return vec3 (p, v, t);
-        else if (hi == 3)
-            return vec3 (p, q, v);
-        else if (hi == 4)
-            return vec3 (t, p, v);
-        return vec3 (v, p, q);
-    }
-}
-
-
-vec3 mx_rgbtohsv(vec3 c)
-{
-    // See Foley & van Dam
-    float r = c.x; float g = c.y; float b = c.z;
-    float mincomp = min (r, min(g, b));
-    float maxcomp = max (r, max(g, b));
-    float delta = maxcomp - mincomp;  // chroma
-    float h, s, v;
-    v = maxcomp;
-    if (maxcomp > 0.0f)
-        s = delta / maxcomp;
-    else s = 0.0f;
-    if (s <= 0.0f)
-        h = 0.0f;
-    else {
-        if      (r >= maxcomp) h = (g-b) / delta;
-        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;
-        else                   h = 4.0f + (r-g) / delta;
-        h *= (1.0f/6.0f);
-        if (h < 0.0f)
-            h += 1.0f;
-    }
-    return vec3(h, s, v);
-}
diff --git a/libraries/stdlib/genmsl/lib/mx_noise.metal b/libraries/stdlib/genmsl/lib/mx_noise.metal
deleted file mode 100644
index 3212481d..00000000
--- a/libraries/stdlib/genmsl/lib/mx_noise.metal
+++ /dev/null
@@ -1,636 +0,0 @@
-/*
-Noise Library.
-
-This library is a modified version of the noise library found in
-Open Shading Language:
-github.com/imageworks/OpenShadingLanguage/blob/master/src/include/OSL/oslnoise.h
-
-It contains the subset of noise types needed to implement the MaterialX
-standard library. The modifications are mainly conversions from C++ to GLSL.
-Produced results should be identical to the OSL noise functions.
-
-Original copyright notice:
-------------------------------------------------------------------------
-Copyright (c) 2009-2010 Sony Pictures Imageworks Inc., et al.
-All Rights Reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-* Redistributions of source code must retain the above copyright
-  notice, this list of conditions and the following disclaimer.
-* Redistributions in binary form must reproduce the above copyright
-  notice, this list of conditions and the following disclaimer in the
-  documentation and/or other materials provided with the distribution.
-* Neither the name of Sony Pictures Imageworks nor the names of its
-  contributors may be used to endorse or promote products derived from
-  this software without specific prior written permission.
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-------------------------------------------------------------------------
-*/
-
-float mx_select(bool b, float t, float f)
-{
-    return b ? t : f;
-}
-
-float mx_negate_if(float val, bool b)
-{
-    return b ? -val : val;
-}
-
-int mx_floor(float x)
-{
-    return int(floor(x));
-}
-
-// return mx_floor as well as the fractional remainder
-float mx_floorfrac(float x, out int i)
-{
-    i = mx_floor(x);
-    return x - float(i);
-}
-
-float mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)
-{
-    float s1 = 1.0 - s;
-    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
-}
-vec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)
-{
-    float s1 = 1.0 - s;
-    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
-}
-float mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)
-{
-    float s1 = 1.0 - s;
-    float t1 = 1.0 - t;
-    float r1 = 1.0 - r;
-    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
-            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
-}
-vec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)
-{
-    float s1 = 1.0 - s;
-    float t1 = 1.0 - t;
-    float r1 = 1.0 - r;
-    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
-            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
-}
-
-// 2 and 3 dimensional gradient functions - perform a dot product against a
-// randomly chosen vector. Note that the gradient vector is not normalized, but
-// this only affects the overal "scale" of the result, so we simply account for
-// the scale by multiplying in the corresponding "perlin" function.
-float mx_gradient_float(uint hash, float x, float y)
-{
-    // 8 possible directions (+-1,+-2) and (+-2,+-1)
-    uint h = hash & 7u;
-    float u = mx_select(h<4u, x, y);
-    float v = 2.0 * mx_select(h<4u, y, x);
-    // compute the dot product with (x,y).
-    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
-}
-float mx_gradient_float(uint hash, float x, float y, float z)
-{
-    // use vectors pointing to the edges of the cube
-    uint h = hash & 15u;
-    float u = mx_select(h<8u, x, y);
-    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));
-    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
-}
-vec3 mx_gradient_vec3(uvec3 hash, float x, float y)
-{
-    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
-}
-vec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)
-{
-    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
-}
-// Scaling factors to normalize the result of gradients above.
-// These factors were experimentally calculated to be:
-//    2D:   0.6616
-//    3D:   0.9820
-float mx_gradient_scale2d(float v) { return 0.6616 * v; }
-float mx_gradient_scale3d(float v) { return 0.9820 * v; }
-vec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }
-vec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }
-
-/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)
-uint mx_rotl32(uint x, int k)
-{
-    return (x<<k) | (x>>(32-k));
-}
-
-void mx_bjmix(inout uint a, inout uint b, inout uint c)
-{
-    a -= c; a ^= mx_rotl32(c, 4); c += b;
-    b -= a; b ^= mx_rotl32(a, 6); a += c;
-    c -= b; c ^= mx_rotl32(b, 8); b += a;
-    a -= c; a ^= mx_rotl32(c,16); c += b;
-    b -= a; b ^= mx_rotl32(a,19); a += c;
-    c -= b; c ^= mx_rotl32(b, 4); b += a;
-}
-
-// Mix up and combine the bits of a, b, and c (doesn't change them, but
-// returns a hash of those three original values).
-uint mx_bjfinal(uint a, uint b, uint c)
-{
-    c ^= b; c -= mx_rotl32(b,14);
-    a ^= c; a -= mx_rotl32(c,11);
-    b ^= a; b -= mx_rotl32(a,25);
-    c ^= b; c -= mx_rotl32(b,16);
-    a ^= c; a -= mx_rotl32(c,4);
-    b ^= a; b -= mx_rotl32(a,14);
-    c ^= b; c -= mx_rotl32(b,24);
-    return c;
-}
-
-// Convert a 32 bit integer into a floating point number in [0,1]
-float mx_bits_to_01(uint bits)
-{
-    return float(bits) / float(uint(0xffffffff));
-}
-
-float mx_fade(float t)
-{
-   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
-}
-
-uint mx_hash_int(int x)
-{
-    uint len = 1u;
-    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;
-    return mx_bjfinal(seed+uint(x), seed, seed);
-}
-
-uint mx_hash_int(int x, int y)
-{
-    uint len = 2u;
-    uint a, b, c;
-    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
-    a += uint(x);
-    b += uint(y);
-    return mx_bjfinal(a, b, c);
-}
-
-uint mx_hash_int(int x, int y, int z)
-{
-    uint len = 3u;
-    uint a, b, c;
-    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
-    a += uint(x);
-    b += uint(y);
-    c += uint(z);
-    return mx_bjfinal(a, b, c);
-}
-
-uint mx_hash_int(int x, int y, int z, int xx)
-{
-    uint len = 4u;
-    uint a, b, c;
-    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
-    a += uint(x);
-    b += uint(y);
-    c += uint(z);
-    mx_bjmix(a, b, c);
-    a += uint(xx);
-    return mx_bjfinal(a, b, c);
-}
-
-uint mx_hash_int(int x, int y, int z, int xx, int yy)
-{
-    uint len = 5u;
-    uint a, b, c;
-    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
-    a += uint(x);
-    b += uint(y);
-    c += uint(z);
-    mx_bjmix(a, b, c);
-    a += uint(xx);
-    b += uint(yy);
-    return mx_bjfinal(a, b, c);
-}
-
-uvec3 mx_hash_vec3(int x, int y)
-{
-    uint h = mx_hash_int(x, y);
-    // we only need the low-order bits to be random, so split out
-    // the 32 bit result into 3 parts for each channel
-    uvec3 result;
-    result.x = (h      ) & 0xFFu;
-    result.y = (h >> 8 ) & 0xFFu;
-    result.z = (h >> 16) & 0xFFu;
-    return result;
-}
-
-uvec3 mx_hash_vec3(int x, int y, int z)
-{
-    uint h = mx_hash_int(x, y, z);
-    // we only need the low-order bits to be random, so split out
-    // the 32 bit result into 3 parts for each channel
-    uvec3 result;
-    result.x = (h      ) & 0xFFu;
-    result.y = (h >> 8 ) & 0xFFu;
-    result.z = (h >> 16) & 0xFFu;
-    return result;
-}
-
-float mx_perlin_noise_float(vec2 p)
-{
-    int X, Y;
-    float fx = mx_floorfrac(p.x, X);
-    float fy = mx_floorfrac(p.y, Y);
-    float u = mx_fade(fx);
-    float v = mx_fade(fy);
-    float result = mx_bilerp(
-        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),
-        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),
-        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),
-        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),
-        u, v);
-    return mx_gradient_scale2d(result);
-}
-
-float mx_perlin_noise_float(vec3 p)
-{
-    int X, Y, Z;
-    float fx = mx_floorfrac(p.x, X);
-    float fy = mx_floorfrac(p.y, Y);
-    float fz = mx_floorfrac(p.z, Z);
-    float u = mx_fade(fx);
-    float v = mx_fade(fy);
-    float w = mx_fade(fz);
-    float result = mx_trilerp(
-        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),
-        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
-        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
-        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
-        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),
-        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
-        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
-        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
-        u, v, w);
-    return mx_gradient_scale3d(result);
-}
-
-vec3 mx_perlin_noise_vec3(vec2 p)
-{
-    int X, Y;
-    float fx = mx_floorfrac(p.x, X);
-    float fy = mx_floorfrac(p.y, Y);
-    float u = mx_fade(fx);
-    float v = mx_fade(fy);
-    vec3 result = mx_bilerp(
-        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),
-        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),
-        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),
-        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),
-        u, v);
-    return mx_gradient_scale2d(result);
-}
-
-vec3 mx_perlin_noise_vec3(vec3 p)
-{
-    int X, Y, Z;
-    float fx = mx_floorfrac(p.x, X);
-    float fy = mx_floorfrac(p.y, Y);
-    float fz = mx_floorfrac(p.z, Z);
-    float u = mx_fade(fx);
-    float v = mx_fade(fy);
-    float w = mx_fade(fz);
-    vec3 result = mx_trilerp(
-        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),
-        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
-        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
-        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
-        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),
-        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
-        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
-        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
-        u, v, w);
-    return mx_gradient_scale3d(result);
-}
-
-float mx_cell_noise_float(float p)
-{
-    int ix = mx_floor(p);
-    return mx_bits_to_01(mx_hash_int(ix));
-}
-
-float mx_cell_noise_float(vec2 p)
-{
-    int ix = mx_floor(p.x);
-    int iy = mx_floor(p.y);
-    return mx_bits_to_01(mx_hash_int(ix, iy));
-}
-
-float mx_cell_noise_float(vec3 p)
-{
-    int ix = mx_floor(p.x);
-    int iy = mx_floor(p.y);
-    int iz = mx_floor(p.z);
-    return mx_bits_to_01(mx_hash_int(ix, iy, iz));
-}
-
-float mx_cell_noise_float(vec4 p)
-{
-    int ix = mx_floor(p.x);
-    int iy = mx_floor(p.y);
-    int iz = mx_floor(p.z);
-    int iw = mx_floor(p.w);
-    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
-}
-
-vec3 mx_cell_noise_vec3(float p)
-{
-    int ix = mx_floor(p);
-    return vec3(
-            mx_bits_to_01(mx_hash_int(ix, 0)),
-            mx_bits_to_01(mx_hash_int(ix, 1)),
-            mx_bits_to_01(mx_hash_int(ix, 2))
-    );
-}
-
-vec3 mx_cell_noise_vec3(vec2 p)
-{
-    int ix = mx_floor(p.x);
-    int iy = mx_floor(p.y);
-    return vec3(
-            mx_bits_to_01(mx_hash_int(ix, iy, 0)),
-            mx_bits_to_01(mx_hash_int(ix, iy, 1)),
-            mx_bits_to_01(mx_hash_int(ix, iy, 2))
-    );
-}
-
-vec3 mx_cell_noise_vec3(vec3 p)
-{
-    int ix = mx_floor(p.x);
-    int iy = mx_floor(p.y);
-    int iz = mx_floor(p.z);
-    return vec3(
-            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),
-            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),
-            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))
-    );
-}
-
-vec3 mx_cell_noise_vec3(vec4 p)
-{
-    int ix = mx_floor(p.x);
-    int iy = mx_floor(p.y);
-    int iz = mx_floor(p.z);
-    int iw = mx_floor(p.w);
-    return vec3(
-            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),
-            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),
-            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))
-    );
-}
-
-float mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)
-{
-    float result = 0.0;
-    float amplitude = 1.0;
-    for (int i = 0;  i < octaves; ++i)
-    {
-        result += amplitude * mx_perlin_noise_float(p);
-        amplitude *= diminish;
-        p *= lacunarity;
-    }
-    return result;
-}
-
-vec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)
-{
-    vec3 result = vec3(0.0);
-    float amplitude = 1.0;
-    for (int i = 0;  i < octaves; ++i)
-    {
-        result += amplitude * mx_perlin_noise_vec3(p);
-        amplitude *= diminish;
-        p *= lacunarity;
-    }
-    return result;
-}
-
-vec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)
-{
-    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),
-                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));
-}
-
-vec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)
-{
-    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);
-    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);
-    return vec4(c, f);
-}
-
-float mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)
-{
-    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));
-    vec2  off = vec2(tmp.x, tmp.y);
-
-    off -= 0.5f;
-    off *= jitter;
-    off += 0.5f;
-
-    vec2 cellpos = vec2(float(x), float(y)) + off;
-    vec2 diff = cellpos - p;
-    if (metric == 2)
-        return abs(diff.x) + abs(diff.y);       // Manhattan distance
-    if (metric == 3)
-        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance
-    // Either Euclidian or Distance^2
-    return dot(diff, diff);
-}
-
-float mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)
-{
-    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));
-
-    off -= 0.5f;
-    off *= jitter;
-    off += 0.5f;
-
-    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;
-    vec3 diff = cellpos - p;
-    if (metric == 2)
-        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance
-    if (metric == 3)
-        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance
-    // Either Euclidian or Distance^2
-    return dot(diff, diff);
-}
-
-float mx_worley_noise_float(vec2 p, float jitter, int metric)
-{
-    int X, Y;
-    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
-    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)
-    for (int x = -1; x <= 1; ++x)
-    {
-        for (int y = -1; y <= 1; ++y)
-        {
-            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
-            sqdist = min(sqdist, dist);
-        }
-    }
-    if (metric == 0)
-        sqdist = sqrt(sqdist);
-    return sqdist;
-}
-
-vec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)
-{
-    int X, Y;
-    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
-    vec2 sqdist = vec2(1e6f, 1e6f);
-    for (int x = -1; x <= 1; ++x)
-    {
-        for (int y = -1; y <= 1; ++y)
-        {
-            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
-            if (dist < sqdist.x)
-            {
-                sqdist.y = sqdist.x;
-                sqdist.x = dist;
-            }
-            else if (dist < sqdist.y)
-            {
-                sqdist.y = dist;
-            }
-        }
-    }
-    if (metric == 0)
-        sqdist = sqrt(sqdist);
-    return sqdist;
-}
-
-vec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)
-{
-    int X, Y;
-    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
-    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
-    for (int x = -1; x <= 1; ++x)
-    {
-        for (int y = -1; y <= 1; ++y)
-        {
-            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
-            if (dist < sqdist.x)
-            {
-                sqdist.z = sqdist.y;
-                sqdist.y = sqdist.x;
-                sqdist.x = dist;
-            }
-            else if (dist < sqdist.y)
-            {
-                sqdist.z = sqdist.y;
-                sqdist.y = dist;
-            }
-            else if (dist < sqdist.z)
-            {
-                sqdist.z = dist;
-            }
-        }
-    }
-    if (metric == 0)
-        sqdist = sqrt(sqdist);
-    return sqdist;
-}
-
-float mx_worley_noise_float(vec3 p, float jitter, int metric)
-{
-    int X, Y, Z;
-    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
-    float sqdist = 1e6f;
-    for (int x = -1; x <= 1; ++x)
-    {
-        for (int y = -1; y <= 1; ++y)
-        {
-            for (int z = -1; z <= 1; ++z)
-            {
-                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
-                sqdist = min(sqdist, dist);
-            }
-        }
-    }
-    if (metric == 0)
-        sqdist = sqrt(sqdist);
-    return sqdist;
-}
-
-vec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)
-{
-    int X, Y, Z;
-    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
-    vec2 sqdist = vec2(1e6f, 1e6f);
-    for (int x = -1; x <= 1; ++x)
-    {
-        for (int y = -1; y <= 1; ++y)
-        {
-            for (int z = -1; z <= 1; ++z)
-            {
-                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
-                if (dist < sqdist.x)
-                {
-                    sqdist.y = sqdist.x;
-                    sqdist.x = dist;
-                }
-                else if (dist < sqdist.y)
-                {
-                    sqdist.y = dist;
-                }
-            }
-        }
-    }
-    if (metric == 0)
-        sqdist = sqrt(sqdist);
-    return sqdist;
-}
-
-vec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)
-{
-    int X, Y, Z;
-    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
-    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
-    for (int x = -1; x <= 1; ++x)
-    {
-        for (int y = -1; y <= 1; ++y)
-        {
-            for (int z = -1; z <= 1; ++z)
-            {
-                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
-                if (dist < sqdist.x)
-                {
-                    sqdist.z = sqdist.y;
-                    sqdist.y = sqdist.x;
-                    sqdist.x = dist;
-                }
-                else if (dist < sqdist.y)
-                {
-                    sqdist.z = sqdist.y;
-                    sqdist.y = dist;
-                }
-                else if (dist < sqdist.z)
-                {
-                    sqdist.z = dist;
-                }
-            }
-        }
-    }
-    if (metric == 0)
-        sqdist = sqrt(sqdist);
-    return sqdist;
-}
diff --git a/libraries/stdlib/genmsl/lib/mx_transform_color.metal b/libraries/stdlib/genmsl/lib/mx_transform_color.metal
deleted file mode 100644
index e7c04438..00000000
--- a/libraries/stdlib/genmsl/lib/mx_transform_color.metal
+++ /dev/null
@@ -1,18 +0,0 @@
-const mat3 AP1_TO_REC709 = mat3( 1.705050992658, -0.130256417507, -0.024003356805,
-                                -0.621792120657,  1.140804736575, -0.128968976065,
-                                -0.083258872001, -0.010548319068,  1.15297233287);
-
-const mat3 ADOBERGB_TO_REC709 = mat3( 1.39835574e+00, -2.50233861e-16,  2.77555756e-17,
-                                     -3.98355744e-01,  1.00000000e+00, -4.29289893e-02,
-                                      0.00000000e+00,  0.00000000e+00,  1.04292899e+00);
-
-const float ADOBERGB_GAMMA = 563.0 / 256.0;
-
-vec3 mx_srgb_texture_to_lin_rec709(vec3 color)
-{
-    bvec3 isAbove = color > vec3(0.04045);
-    vec3 linSeg = color / 12.92;
-    vec3 powSeg = pow(max(color + vec3(0.055), vec3(0.0)) / 1.055, vec3(2.4));
-    vec3 m = vec3(isAbove.x ? 1.0 : 0.0, isAbove.y ? 1.0 : 0.0, isAbove.z ? 1.0 : 0.0);
-    return mix(linSeg, powSeg, m);
-}
diff --git a/libraries/stdlib/genmsl/lib/mx_transform_uv.metal b/libraries/stdlib/genmsl/lib/mx_transform_uv.metal
deleted file mode 100644
index 33299252..00000000
--- a/libraries/stdlib/genmsl/lib/mx_transform_uv.metal
+++ /dev/null
@@ -1,5 +0,0 @@
-vec2 mx_transform_uv(vec2 uv, vec2 uv_scale, vec2 uv_offset)
-{
-    uv = uv * uv_scale + uv_offset;
-    return uv;
-}
diff --git a/libraries/stdlib/genmsl/lib/mx_transform_uv_vflip.metal b/libraries/stdlib/genmsl/lib/mx_transform_uv_vflip.metal
deleted file mode 100644
index 7e1b2e77..00000000
--- a/libraries/stdlib/genmsl/lib/mx_transform_uv_vflip.metal
+++ /dev/null
@@ -1,5 +0,0 @@
-vec2 mx_transform_uv(vec2 uv, vec2 uv_scale, vec2 uv_offset)
-{
-    uv = uv * uv_scale + uv_offset;
-    return vec2(uv.x, 1.0 - uv.y);
-}
diff --git a/libraries/targets/genmsl.mtlx b/libraries/targets/genmsl.mtlx
index 61afcc1d..d18c45ca 100644
--- a/libraries/targets/genmsl.mtlx
+++ b/libraries/targets/genmsl.mtlx
@@ -9,6 +9,6 @@
   <!-- ======================================================================== -->
   <!-- Base target definition for MSL targets using shader generation.          -->
   <!-- ======================================================================== -->
-  <targetdef name="genmsl" />
+  <targetdef name="genmsl" inherit="genglsl" />
 
 </materialx>
-- 
2.37.0

From 86458fc1df22795a25aed6477c4332f96f662cfa Mon Sep 17 00:00:00 2001
From: Morteza Mostajab <smostajabodaveh@apple.com>
Date: Mon, 6 Mar 2023 15:48:15 +0000
Subject: [PATCH] Removing linearToSRGB function that's not needed.

---
 libraries/stdlib/genmsl/lib/mx_math.metal | 9 ---------
 1 file changed, 9 deletions(-)

diff --git a/libraries/stdlib/genmsl/lib/mx_math.metal b/libraries/stdlib/genmsl/lib/mx_math.metal
index 6a85a986..e073ddac 100644
--- a/libraries/stdlib/genmsl/lib/mx_math.metal
+++ b/libraries/stdlib/genmsl/lib/mx_math.metal
@@ -15,15 +15,6 @@ vec3 mx_square(vec3 x)
     return x*x;
 }
 
-float4 linearToSRGB(float4 color_linear)
-{
-    float4 color_srgb;
-    for(int i = 0; i < 3; ++i)
-        color_srgb[i] = (color_linear[i] < 0.0031308) ? (12.92 * color_linear[i]): (1.055 * pow(color_linear[i], 1.0 / 2.4) - 0.055);
-    color_srgb[3] = color_linear[3];
-    return color_srgb;
-}
-
 #ifdef __DECL_GL_MATH_FUNCTIONS__
 
 float radians(float degree) { return (degree * M_PI_F / 180.0f); }
-- 
2.37.0

From 25db88a26649647c347fbec960691269eff623d8 Mon Sep 17 00:00:00 2001
From: Morteza Mostajab <smostajabodaveh@apple.com>
Date: Mon, 6 Mar 2023 15:49:19 +0000
Subject: [PATCH] Code refactoring to improve the quality

---
 .../MaterialXGenGlsl/GlslShaderGenerator.cpp  | 238 +++++++++--------
 source/MaterialXGenMsl/MslShaderGenerator.cpp | 240 ++++++++++--------
 source/MaterialXGenShader/ShaderGenerator.cpp |   8 +
 source/MaterialXGenShader/ShaderGenerator.h   |   3 +
 source/MaterialXRender/Material.cpp           |  42 ++-
 source/MaterialXRender/Material.h             |   2 +-
 source/MaterialXRenderGlsl/GlslMaterial.cpp   |  39 ---
 source/MaterialXRenderGlsl/GlslMaterial.h     |   6 -
 .../MSLPipelineStateObject.mm                 |   4 +-
 source/MaterialXRenderMsl/MetalState.mm       |   4 +-
 .../MaterialXRenderMsl/MetalTextureHandler.h  |  13 +-
 .../MaterialXRenderMsl/MetalTextureHandler.mm |   9 +-
 source/MaterialXRenderMsl/MslMaterial.h       |   6 -
 source/MaterialXRenderMsl/MslMaterial.mm      |  39 ---
 .../MaterialXRender/RenderUtil.cpp            | 218 ++++++++++++++++
 .../MaterialXRender/RenderUtil.h              |   4 +
 .../MaterialXRenderGlsl/RenderGlsl.cpp        | 220 ----------------
 .../MaterialXRenderMsl/RenderMsl.mm           | 224 +---------------
 18 files changed, 571 insertions(+), 748 deletions(-)

diff --git a/source/MaterialXGenGlsl/GlslShaderGenerator.cpp b/source/MaterialXGenGlsl/GlslShaderGenerator.cpp
index f4260e6f..e9919b74 100644
--- a/source/MaterialXGenGlsl/GlslShaderGenerator.cpp
+++ b/source/MaterialXGenGlsl/GlslShaderGenerator.cpp
@@ -57,93 +57,113 @@ GlslShaderGenerator::GlslShaderGenerator() :
     // Register all custom node implementation classes
     //
 
+    StringVec elementNames;
+    
     // <!-- <switch> -->
-    // <!-- 'which' type : float -->
-    registerImplementation("IM_switch_float_" + GlslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_color3_" + GlslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_color4_" + GlslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_vector2_" + GlslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_vector3_" + GlslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_vector4_" + GlslShaderGenerator::TARGET, SwitchNode::create);
-    // <!-- 'which' type : integer -->
-    registerImplementation("IM_switch_floatI_" + GlslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_color3I_" + GlslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_color4I_" + GlslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_vector2I_" + GlslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_vector3I_" + GlslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_vector4I_" + GlslShaderGenerator::TARGET, SwitchNode::create);
+    elementNames = {
+        // <!-- 'which' type : float -->
+        "IM_switch_float_"   + GlslShaderGenerator::TARGET,
+        "IM_switch_color3_"  + GlslShaderGenerator::TARGET,
+        "IM_switch_color4_"  + GlslShaderGenerator::TARGET,
+        "IM_switch_vector2_" + GlslShaderGenerator::TARGET,
+        "IM_switch_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_switch_vector4_" + GlslShaderGenerator::TARGET,
+        
+        // <!-- 'which' type : integer -->
+        "IM_switch_floatI_" + GlslShaderGenerator::TARGET,
+        "IM_switch_color3I_" + GlslShaderGenerator::TARGET,
+        "IM_switch_color4I_" + GlslShaderGenerator::TARGET,
+        "IM_switch_vector2I_" + GlslShaderGenerator::TARGET,
+        "IM_switch_vector3I_" + GlslShaderGenerator::TARGET,
+        "IM_switch_vector4I_" + GlslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, SwitchNode::create);
 
     // <!-- <swizzle> -->
-    // <!-- from type : float -->
-    registerImplementation("IM_swizzle_float_color3_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_float_color4_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_float_vector2_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_float_vector3_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_float_vector4_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    // <!-- from type : color3 -->
-    registerImplementation("IM_swizzle_color3_float_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color3_color3_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color3_color4_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color3_vector2_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color3_vector3_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color3_vector4_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    // <!-- from type : color4 -->
-    registerImplementation("IM_swizzle_color4_float_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color4_color3_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color4_color4_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color4_vector2_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color4_vector3_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color4_vector4_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    // <!-- from type : vector2 -->
-    registerImplementation("IM_swizzle_vector2_float_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector2_color3_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector2_color4_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector2_vector2_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector2_vector3_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector2_vector4_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    // <!-- from type : vector3 -->
-    registerImplementation("IM_swizzle_vector3_float_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector3_color3_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector3_color4_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector3_vector2_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector3_vector3_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector3_vector4_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    // <!-- from type : vector4 -->
-    registerImplementation("IM_swizzle_vector4_float_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector4_color3_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector4_color4_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector4_vector2_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector4_vector3_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector4_vector4_" + GlslShaderGenerator::TARGET, SwizzleNode::create);
+    elementNames = {
+        // <!-- from type : float -->
+        "IM_swizzle_float_color3_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_float_color4_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_float_vector2_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_float_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_float_vector4_" + GlslShaderGenerator::TARGET,
+        
+        // <!-- from type : color3 -->
+        "IM_swizzle_color3_float_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_color3_color3_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_color3_color4_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_color3_vector2_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_color3_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_color3_vector4_" + GlslShaderGenerator::TARGET,
+        
+        // <!-- from type : color4 -->
+        "IM_swizzle_color4_float_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_color4_color3_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_color4_color4_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_color4_vector2_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_color4_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_color4_vector4_" + GlslShaderGenerator::TARGET,
+        
+        // <!-- from type : vector2 -->
+        "IM_swizzle_vector2_float_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector2_color3_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector2_color4_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector2_vector2_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector2_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector2_vector4_" + GlslShaderGenerator::TARGET,
+        
+        // <!-- from type : vector3 -->
+        "IM_swizzle_vector3_float_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector3_color3_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector3_color4_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector3_vector2_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector3_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector3_vector4_" + GlslShaderGenerator::TARGET,
+        
+        // <!-- from type : vector4 -->
+        "IM_swizzle_vector4_float_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector4_color3_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector4_color4_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector4_vector2_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector4_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_swizzle_vector4_vector4_" + GlslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, SwizzleNode::create);
 
     // <!-- <convert> -->
-    registerImplementation("IM_convert_float_color3_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_float_color4_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_float_vector2_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_float_vector3_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_float_vector4_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_vector2_vector3_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_vector3_vector2_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_vector3_color3_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_vector3_vector4_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_vector4_vector3_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_vector4_color4_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_color3_vector3_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_color4_vector4_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_color3_color4_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_color4_color3_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_boolean_float_" + GlslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_integer_float_" + GlslShaderGenerator::TARGET, ConvertNode::create);
+    elementNames = {
+        "IM_convert_float_color3_" + GlslShaderGenerator::TARGET,
+        "IM_convert_float_color4_" + GlslShaderGenerator::TARGET,
+        "IM_convert_float_vector2_" + GlslShaderGenerator::TARGET,
+        "IM_convert_float_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_convert_float_vector4_" + GlslShaderGenerator::TARGET,
+        "IM_convert_vector2_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_convert_vector3_vector2_" + GlslShaderGenerator::TARGET,
+        "IM_convert_vector3_color3_" + GlslShaderGenerator::TARGET,
+        "IM_convert_vector3_vector4_" + GlslShaderGenerator::TARGET,
+        "IM_convert_vector4_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_convert_vector4_color4_" + GlslShaderGenerator::TARGET,
+        "IM_convert_color3_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_convert_color4_vector4_" + GlslShaderGenerator::TARGET,
+        "IM_convert_color3_color4_" + GlslShaderGenerator::TARGET,
+        "IM_convert_color4_color3_" + GlslShaderGenerator::TARGET,
+        "IM_convert_boolean_float_" + GlslShaderGenerator::TARGET,
+        "IM_convert_integer_float_" + GlslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, ConvertNode::create);
 
     // <!-- <combine> -->
-    registerImplementation("IM_combine2_vector2_" + GlslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine2_color4CF_" + GlslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine2_vector4VF_" + GlslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine2_vector4VV_" + GlslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine3_color3_" + GlslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine3_vector3_" + GlslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine4_color4_" + GlslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine4_vector4_" + GlslShaderGenerator::TARGET, CombineNode::create);
+    elementNames = {
+        "IM_combine2_vector2_" + GlslShaderGenerator::TARGET,
+        "IM_combine2_color4CF_" + GlslShaderGenerator::TARGET,
+        "IM_combine2_vector4VF_" + GlslShaderGenerator::TARGET,
+        "IM_combine2_vector4VV_" + GlslShaderGenerator::TARGET,
+        "IM_combine3_color3_" + GlslShaderGenerator::TARGET,
+        "IM_combine3_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_combine4_color4_" + GlslShaderGenerator::TARGET,
+        "IM_combine4_vector4_" + GlslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, CombineNode::create);
 
     // <!-- <position> -->
     registerImplementation("IM_position_vector3_" + GlslShaderGenerator::TARGET, PositionNodeGlsl::create);
@@ -161,15 +181,18 @@ GlslShaderGenerator::GlslShaderGenerator() :
     registerImplementation("IM_geomcolor_color3_" + GlslShaderGenerator::TARGET, GeomColorNodeGlsl::create);
     registerImplementation("IM_geomcolor_color4_" + GlslShaderGenerator::TARGET, GeomColorNodeGlsl::create);
     // <!-- <geompropvalue> -->
-    registerImplementation("IM_geompropvalue_integer_" + GlslShaderGenerator::TARGET, GeomPropValueNodeGlsl::create);
+    elementNames = {
+        "IM_geompropvalue_integer_" + GlslShaderGenerator::TARGET,
+        "IM_geompropvalue_float_" + GlslShaderGenerator::TARGET,
+        "IM_geompropvalue_color3_" + GlslShaderGenerator::TARGET,
+        "IM_geompropvalue_color4_" + GlslShaderGenerator::TARGET,
+        "IM_geompropvalue_vector2_" + GlslShaderGenerator::TARGET,
+        "IM_geompropvalue_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_geompropvalue_vector4_" + GlslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, GeomPropValueNodeGlsl::create);
     registerImplementation("IM_geompropvalue_boolean_" + GlslShaderGenerator::TARGET, GeomPropValueNodeGlslAsUniform::create);
     registerImplementation("IM_geompropvalue_string_" + GlslShaderGenerator::TARGET, GeomPropValueNodeGlslAsUniform::create);
-    registerImplementation("IM_geompropvalue_float_" + GlslShaderGenerator::TARGET, GeomPropValueNodeGlsl::create);
-    registerImplementation("IM_geompropvalue_color3_" + GlslShaderGenerator::TARGET, GeomPropValueNodeGlsl::create);
-    registerImplementation("IM_geompropvalue_color4_" + GlslShaderGenerator::TARGET, GeomPropValueNodeGlsl::create);
-    registerImplementation("IM_geompropvalue_vector2_" + GlslShaderGenerator::TARGET, GeomPropValueNodeGlsl::create);
-    registerImplementation("IM_geompropvalue_vector3_" + GlslShaderGenerator::TARGET, GeomPropValueNodeGlsl::create);
-    registerImplementation("IM_geompropvalue_vector4_" + GlslShaderGenerator::TARGET, GeomPropValueNodeGlsl::create);
 
     // <!-- <frame> -->
     registerImplementation("IM_frame_float_" + GlslShaderGenerator::TARGET, FrameNodeGlsl::create);
@@ -194,12 +217,15 @@ GlslShaderGenerator::GlslShaderGenerator() :
     registerImplementation("IM_heighttonormal_vector3_" + GlslShaderGenerator::TARGET, HeightToNormalNodeGlsl::create);
 
     // <!-- <blur> -->
-    registerImplementation("IM_blur_float_" + GlslShaderGenerator::TARGET, BlurNodeGlsl::create);
-    registerImplementation("IM_blur_color3_" + GlslShaderGenerator::TARGET, BlurNodeGlsl::create);
-    registerImplementation("IM_blur_color4_" + GlslShaderGenerator::TARGET, BlurNodeGlsl::create);
-    registerImplementation("IM_blur_vector2_" + GlslShaderGenerator::TARGET, BlurNodeGlsl::create);
-    registerImplementation("IM_blur_vector3_" + GlslShaderGenerator::TARGET, BlurNodeGlsl::create);
-    registerImplementation("IM_blur_vector4_" + GlslShaderGenerator::TARGET, BlurNodeGlsl::create);
+    elementNames = {
+        "IM_blur_float_" + GlslShaderGenerator::TARGET,
+        "IM_blur_color3_" + GlslShaderGenerator::TARGET,
+        "IM_blur_color4_" + GlslShaderGenerator::TARGET,
+        "IM_blur_vector2_" + GlslShaderGenerator::TARGET,
+        "IM_blur_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_blur_vector4_" + GlslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, BlurNodeGlsl::create);
 
     // <!-- <ND_transformpoint> ->
     registerImplementation("IM_transformpoint_vector3_" + GlslShaderGenerator::TARGET, TransformPointNodeGlsl::create);
@@ -211,12 +237,15 @@ GlslShaderGenerator::GlslShaderGenerator() :
     registerImplementation("IM_transformnormal_vector3_" + GlslShaderGenerator::TARGET, TransformNormalNodeGlsl::create);
 
     // <!-- <image> -->
-    registerImplementation("IM_image_float_" + GlslShaderGenerator::TARGET, HwImageNode::create);
-    registerImplementation("IM_image_color3_" + GlslShaderGenerator::TARGET, HwImageNode::create);
-    registerImplementation("IM_image_color4_" + GlslShaderGenerator::TARGET, HwImageNode::create);
-    registerImplementation("IM_image_vector2_" + GlslShaderGenerator::TARGET, HwImageNode::create);
-    registerImplementation("IM_image_vector3_" + GlslShaderGenerator::TARGET, HwImageNode::create);
-    registerImplementation("IM_image_vector4_" + GlslShaderGenerator::TARGET, HwImageNode::create);
+    elementNames = {
+        "IM_image_float_" + GlslShaderGenerator::TARGET,
+        "IM_image_color3_" + GlslShaderGenerator::TARGET,
+        "IM_image_color4_" + GlslShaderGenerator::TARGET,
+        "IM_image_vector2_" + GlslShaderGenerator::TARGET,
+        "IM_image_vector3_" + GlslShaderGenerator::TARGET,
+        "IM_image_vector4_" + GlslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, HwImageNode::create);
 
     // <!-- <layer> -->
     registerImplementation("IM_layer_bsdf_" + GlslShaderGenerator::TARGET, ClosureLayerNode::create);
@@ -228,10 +257,13 @@ GlslShaderGenerator::GlslShaderGenerator() :
     registerImplementation("IM_add_bsdf_" + GlslShaderGenerator::TARGET, ClosureAddNode::create);
     registerImplementation("IM_add_edf_" + GlslShaderGenerator::TARGET, ClosureAddNode::create);
     // <!-- <multiply> -->
-    registerImplementation("IM_multiply_bsdfC_" + GlslShaderGenerator::TARGET, ClosureMultiplyNode::create);
-    registerImplementation("IM_multiply_bsdfF_" + GlslShaderGenerator::TARGET, ClosureMultiplyNode::create);
-    registerImplementation("IM_multiply_edfC_" + GlslShaderGenerator::TARGET, ClosureMultiplyNode::create);
-    registerImplementation("IM_multiply_edfF_" + GlslShaderGenerator::TARGET, ClosureMultiplyNode::create);
+    elementNames = {
+        "IM_multiply_bsdfC_" + GlslShaderGenerator::TARGET,
+        "IM_multiply_bsdfF_" + GlslShaderGenerator::TARGET,
+        "IM_multiply_edfC_" + GlslShaderGenerator::TARGET,
+        "IM_multiply_edfF_" + GlslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, ClosureMultiplyNode::create);
 
     // <!-- <thin_film> -->
     registerImplementation("IM_thin_film_bsdf_" + GlslShaderGenerator::TARGET, NopNode::create);
diff --git a/source/MaterialXGenMsl/MslShaderGenerator.cpp b/source/MaterialXGenMsl/MslShaderGenerator.cpp
index 5eede5fa..1bdd9784 100644
--- a/source/MaterialXGenMsl/MslShaderGenerator.cpp
+++ b/source/MaterialXGenMsl/MslShaderGenerator.cpp
@@ -59,93 +59,113 @@ MslShaderGenerator::MslShaderGenerator() :
     // Register all custom node implementation classes
     //
 
+    StringVec elementNames;
+    
     // <!-- <switch> -->
-    // <!-- 'which' type : float -->
-    registerImplementation("IM_switch_float_" + MslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_color3_" + MslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_color4_" + MslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_vector2_" + MslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_vector3_" + MslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_vector4_" + MslShaderGenerator::TARGET, SwitchNode::create);
-    // <!-- 'which' type : integer -->
-    registerImplementation("IM_switch_floatI_" + MslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_color3I_" + MslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_color4I_" + MslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_vector2I_" + MslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_vector3I_" + MslShaderGenerator::TARGET, SwitchNode::create);
-    registerImplementation("IM_switch_vector4I_" + MslShaderGenerator::TARGET, SwitchNode::create);
+    elementNames = {
+        // <!-- 'which' type : float -->
+        "IM_switch_float_"   + MslShaderGenerator::TARGET,
+        "IM_switch_color3_"  + MslShaderGenerator::TARGET,
+        "IM_switch_color4_"  + MslShaderGenerator::TARGET,
+        "IM_switch_vector2_" + MslShaderGenerator::TARGET,
+        "IM_switch_vector3_" + MslShaderGenerator::TARGET,
+        "IM_switch_vector4_" + MslShaderGenerator::TARGET,
+        
+        // <!-- 'which' type : integer -->
+        "IM_switch_floatI_" + MslShaderGenerator::TARGET,
+        "IM_switch_color3I_" + MslShaderGenerator::TARGET,
+        "IM_switch_color4I_" + MslShaderGenerator::TARGET,
+        "IM_switch_vector2I_" + MslShaderGenerator::TARGET,
+        "IM_switch_vector3I_" + MslShaderGenerator::TARGET,
+        "IM_switch_vector4I_" + MslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, SwitchNode::create);
 
     // <!-- <swizzle> -->
-    // <!-- from type : float -->
-    registerImplementation("IM_swizzle_float_color3_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_float_color4_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_float_vector2_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_float_vector3_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_float_vector4_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    // <!-- from type : color3 -->
-    registerImplementation("IM_swizzle_color3_float_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color3_color3_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color3_color4_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color3_vector2_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color3_vector3_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color3_vector4_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    // <!-- from type : color4 -->
-    registerImplementation("IM_swizzle_color4_float_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color4_color3_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color4_color4_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color4_vector2_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color4_vector3_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_color4_vector4_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    // <!-- from type : vector2 -->
-    registerImplementation("IM_swizzle_vector2_float_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector2_color3_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector2_color4_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector2_vector2_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector2_vector3_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector2_vector4_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    // <!-- from type : vector3 -->
-    registerImplementation("IM_swizzle_vector3_float_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector3_color3_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector3_color4_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector3_vector2_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector3_vector3_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector3_vector4_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    // <!-- from type : vector4 -->
-    registerImplementation("IM_swizzle_vector4_float_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector4_color3_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector4_color4_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector4_vector2_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector4_vector3_" + MslShaderGenerator::TARGET, SwizzleNode::create);
-    registerImplementation("IM_swizzle_vector4_vector4_" + MslShaderGenerator::TARGET, SwizzleNode::create);
+    elementNames = {
+        // <!-- from type : float -->
+        "IM_swizzle_float_color3_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_float_color4_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_float_vector2_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_float_vector3_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_float_vector4_" + MslShaderGenerator::TARGET,
+        
+        // <!-- from type : color3 -->
+        "IM_swizzle_color3_float_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_color3_color3_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_color3_color4_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_color3_vector2_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_color3_vector3_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_color3_vector4_" + MslShaderGenerator::TARGET,
+        
+        // <!-- from type : color4 -->
+        "IM_swizzle_color4_float_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_color4_color3_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_color4_color4_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_color4_vector2_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_color4_vector3_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_color4_vector4_" + MslShaderGenerator::TARGET,
+        
+        // <!-- from type : vector2 -->
+        "IM_swizzle_vector2_float_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector2_color3_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector2_color4_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector2_vector2_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector2_vector3_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector2_vector4_" + MslShaderGenerator::TARGET,
+        
+        // <!-- from type : vector3 -->
+        "IM_swizzle_vector3_float_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector3_color3_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector3_color4_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector3_vector2_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector3_vector3_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector3_vector4_" + MslShaderGenerator::TARGET,
+        
+        // <!-- from type : vector4 -->
+        "IM_swizzle_vector4_float_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector4_color3_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector4_color4_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector4_vector2_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector4_vector3_" + MslShaderGenerator::TARGET,
+        "IM_swizzle_vector4_vector4_" + MslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, SwizzleNode::create);
 
     // <!-- <convert> -->
-    registerImplementation("IM_convert_float_color3_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_float_color4_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_float_vector2_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_float_vector3_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_float_vector4_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_vector2_vector3_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_vector3_vector2_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_vector3_color3_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_vector3_vector4_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_vector4_vector3_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_vector4_color4_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_color3_vector3_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_color4_vector4_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_color3_color4_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_color4_color3_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_boolean_float_" + MslShaderGenerator::TARGET, ConvertNode::create);
-    registerImplementation("IM_convert_integer_float_" + MslShaderGenerator::TARGET, ConvertNode::create);
+    elementNames = {
+        "IM_convert_float_color3_" + MslShaderGenerator::TARGET,
+        "IM_convert_float_color4_" + MslShaderGenerator::TARGET,
+        "IM_convert_float_vector2_" + MslShaderGenerator::TARGET,
+        "IM_convert_float_vector3_" + MslShaderGenerator::TARGET,
+        "IM_convert_float_vector4_" + MslShaderGenerator::TARGET,
+        "IM_convert_vector2_vector3_" + MslShaderGenerator::TARGET,
+        "IM_convert_vector3_vector2_" + MslShaderGenerator::TARGET,
+        "IM_convert_vector3_color3_" + MslShaderGenerator::TARGET,
+        "IM_convert_vector3_vector4_" + MslShaderGenerator::TARGET,
+        "IM_convert_vector4_vector3_" + MslShaderGenerator::TARGET,
+        "IM_convert_vector4_color4_" + MslShaderGenerator::TARGET,
+        "IM_convert_color3_vector3_" + MslShaderGenerator::TARGET,
+        "IM_convert_color4_vector4_" + MslShaderGenerator::TARGET,
+        "IM_convert_color3_color4_" + MslShaderGenerator::TARGET,
+        "IM_convert_color4_color3_" + MslShaderGenerator::TARGET,
+        "IM_convert_boolean_float_" + MslShaderGenerator::TARGET,
+        "IM_convert_integer_float_" + MslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, ConvertNode::create);
 
     // <!-- <combine> -->
-    registerImplementation("IM_combine2_vector2_" + MslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine2_color4CF_" + MslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine2_vector4VF_" + MslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine2_vector4VV_" + MslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine3_color3_" + MslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine3_vector3_" + MslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine4_color4_" + MslShaderGenerator::TARGET, CombineNode::create);
-    registerImplementation("IM_combine4_vector4_" + MslShaderGenerator::TARGET, CombineNode::create);
+    elementNames = {
+        "IM_combine2_vector2_" + MslShaderGenerator::TARGET,
+        "IM_combine2_color4CF_" + MslShaderGenerator::TARGET,
+        "IM_combine2_vector4VF_" + MslShaderGenerator::TARGET,
+        "IM_combine2_vector4VV_" + MslShaderGenerator::TARGET,
+        "IM_combine3_color3_" + MslShaderGenerator::TARGET,
+        "IM_combine3_vector3_" + MslShaderGenerator::TARGET,
+        "IM_combine4_color4_" + MslShaderGenerator::TARGET,
+        "IM_combine4_vector4_" + MslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, CombineNode::create);
 
     // <!-- <position> -->
     registerImplementation("IM_position_vector3_" + MslShaderGenerator::TARGET, PositionNodeMsl::create);
@@ -163,15 +183,18 @@ MslShaderGenerator::MslShaderGenerator() :
     registerImplementation("IM_geomcolor_color3_" + MslShaderGenerator::TARGET, GeomColorNodeMsl::create);
     registerImplementation("IM_geomcolor_color4_" + MslShaderGenerator::TARGET, GeomColorNodeMsl::create);
     // <!-- <geompropvalue> -->
-    registerImplementation("IM_geompropvalue_integer_" + MslShaderGenerator::TARGET, GeomPropValueNodeMsl::create);
+    elementNames = {
+        "IM_geompropvalue_integer_" + MslShaderGenerator::TARGET,
+        "IM_geompropvalue_float_" + MslShaderGenerator::TARGET,
+        "IM_geompropvalue_color3_" + MslShaderGenerator::TARGET,
+        "IM_geompropvalue_color4_" + MslShaderGenerator::TARGET,
+        "IM_geompropvalue_vector2_" + MslShaderGenerator::TARGET,
+        "IM_geompropvalue_vector3_" + MslShaderGenerator::TARGET,
+        "IM_geompropvalue_vector4_" + MslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, GeomPropValueNodeMsl::create);
     registerImplementation("IM_geompropvalue_boolean_" + MslShaderGenerator::TARGET, GeomPropValueNodeMslAsUniform::create);
     registerImplementation("IM_geompropvalue_string_" + MslShaderGenerator::TARGET, GeomPropValueNodeMslAsUniform::create);
-    registerImplementation("IM_geompropvalue_float_" + MslShaderGenerator::TARGET, GeomPropValueNodeMsl::create);
-    registerImplementation("IM_geompropvalue_color3_" + MslShaderGenerator::TARGET, GeomPropValueNodeMsl::create);
-    registerImplementation("IM_geompropvalue_color4_" + MslShaderGenerator::TARGET, GeomPropValueNodeMsl::create);
-    registerImplementation("IM_geompropvalue_vector2_" + MslShaderGenerator::TARGET, GeomPropValueNodeMsl::create);
-    registerImplementation("IM_geompropvalue_vector3_" + MslShaderGenerator::TARGET, GeomPropValueNodeMsl::create);
-    registerImplementation("IM_geompropvalue_vector4_" + MslShaderGenerator::TARGET, GeomPropValueNodeMsl::create);
 
     // <!-- <frame> -->
     registerImplementation("IM_frame_float_" + MslShaderGenerator::TARGET, FrameNodeMsl::create);
@@ -196,12 +219,15 @@ MslShaderGenerator::MslShaderGenerator() :
     registerImplementation("IM_heighttonormal_vector3_" + MslShaderGenerator::TARGET, HeightToNormalNodeMsl::create);
 
     // <!-- <blur> -->
-    registerImplementation("IM_blur_float_" + MslShaderGenerator::TARGET, BlurNodeMsl::create);
-    registerImplementation("IM_blur_color3_" + MslShaderGenerator::TARGET, BlurNodeMsl::create);
-    registerImplementation("IM_blur_color4_" + MslShaderGenerator::TARGET, BlurNodeMsl::create);
-    registerImplementation("IM_blur_vector2_" + MslShaderGenerator::TARGET, BlurNodeMsl::create);
-    registerImplementation("IM_blur_vector3_" + MslShaderGenerator::TARGET, BlurNodeMsl::create);
-    registerImplementation("IM_blur_vector4_" + MslShaderGenerator::TARGET, BlurNodeMsl::create);
+    elementNames = {
+        "IM_blur_float_" + MslShaderGenerator::TARGET,
+        "IM_blur_color3_" + MslShaderGenerator::TARGET,
+        "IM_blur_color4_" + MslShaderGenerator::TARGET,
+        "IM_blur_vector2_" + MslShaderGenerator::TARGET,
+        "IM_blur_vector3_" + MslShaderGenerator::TARGET,
+        "IM_blur_vector4_" + MslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, BlurNodeMsl::create);
 
     // <!-- <ND_transformpoint> ->
     registerImplementation("IM_transformpoint_vector3_" + MslShaderGenerator::TARGET, TransformPointNodeMsl::create);
@@ -213,12 +239,15 @@ MslShaderGenerator::MslShaderGenerator() :
     registerImplementation("IM_transformnormal_vector3_" + MslShaderGenerator::TARGET, TransformNormalNodeMsl::create);
 
     // <!-- <image> -->
-    registerImplementation("IM_image_float_" + MslShaderGenerator::TARGET, HwImageNode::create);
-    registerImplementation("IM_image_color3_" + MslShaderGenerator::TARGET, HwImageNode::create);
-    registerImplementation("IM_image_color4_" + MslShaderGenerator::TARGET, HwImageNode::create);
-    registerImplementation("IM_image_vector2_" + MslShaderGenerator::TARGET, HwImageNode::create);
-    registerImplementation("IM_image_vector3_" + MslShaderGenerator::TARGET, HwImageNode::create);
-    registerImplementation("IM_image_vector4_" + MslShaderGenerator::TARGET, HwImageNode::create);
+    elementNames = {
+        "IM_image_float_" + MslShaderGenerator::TARGET,
+        "IM_image_color3_" + MslShaderGenerator::TARGET,
+        "IM_image_color4_" + MslShaderGenerator::TARGET,
+        "IM_image_vector2_" + MslShaderGenerator::TARGET,
+        "IM_image_vector3_" + MslShaderGenerator::TARGET,
+        "IM_image_vector4_" + MslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, HwImageNode::create);
 
     // <!-- <layer> -->
     registerImplementation("IM_layer_bsdf_" + MslShaderGenerator::TARGET, ClosureLayerNode::create);
@@ -230,10 +259,13 @@ MslShaderGenerator::MslShaderGenerator() :
     registerImplementation("IM_add_bsdf_" + MslShaderGenerator::TARGET, ClosureAddNode::create);
     registerImplementation("IM_add_edf_" + MslShaderGenerator::TARGET, ClosureAddNode::create);
     // <!-- <multiply> -->
-    registerImplementation("IM_multiply_bsdfC_" + MslShaderGenerator::TARGET, ClosureMultiplyNode::create);
-    registerImplementation("IM_multiply_bsdfF_" + MslShaderGenerator::TARGET, ClosureMultiplyNode::create);
-    registerImplementation("IM_multiply_edfC_" + MslShaderGenerator::TARGET, ClosureMultiplyNode::create);
-    registerImplementation("IM_multiply_edfF_" + MslShaderGenerator::TARGET, ClosureMultiplyNode::create);
+    elementNames = {
+        "IM_multiply_bsdfC_" + MslShaderGenerator::TARGET,
+        "IM_multiply_bsdfF_" + MslShaderGenerator::TARGET,
+        "IM_multiply_edfC_" + MslShaderGenerator::TARGET,
+        "IM_multiply_edfF_" + MslShaderGenerator::TARGET,
+    };
+    registerImplementation(elementNames, ClosureMultiplyNode::create);
 
     // <!-- <thin_film> -->
     registerImplementation("IM_thin_film_bsdf_" + MslShaderGenerator::TARGET, NopNode::create);
@@ -287,6 +319,8 @@ void MslShaderGenerator::MetalizeGeneratedShader(ShaderStage& shaderStage) const
 {
     std::string sourceCode = shaderStage.getSourceCode();
     
+    // Used to convert shared code between GLSL pass by reference parameters to MSL pass by reference.
+    // Converts "inout/out Type variableName" to "thread Type& variableName"
     size_t pos = 0;
     {
         std::array<string, 2> refKeywords = { "out", "inout" };
diff --git a/source/MaterialXGenShader/ShaderGenerator.cpp b/source/MaterialXGenShader/ShaderGenerator.cpp
index 6445010e..ecfc8645 100644
--- a/source/MaterialXGenShader/ShaderGenerator.cpp
+++ b/source/MaterialXGenShader/ShaderGenerator.cpp
@@ -273,6 +273,14 @@ void ShaderGenerator::registerImplementation(const string& name, CreatorFunction
     _implFactory.registerClass(name, creator);
 }
 
+void ShaderGenerator::registerImplementation(const StringVec& nameVec, CreatorFunction<ShaderNodeImpl> creator)
+{
+    for(const string& name : nameVec)
+    {
+        _implFactory.registerClass(name, creator);
+    }
+}
+
 bool ShaderGenerator::implementationRegistered(const string& name) const
 {
     return _implFactory.classRegistered(name);
diff --git a/source/MaterialXGenShader/ShaderGenerator.h b/source/MaterialXGenShader/ShaderGenerator.h
index efa8cbe8..7045f43b 100644
--- a/source/MaterialXGenShader/ShaderGenerator.h
+++ b/source/MaterialXGenShader/ShaderGenerator.h
@@ -150,6 +150,9 @@ class MX_GENSHADER_API ShaderGenerator
 
     /// Register a shader node implementation for a given implementation element name
     void registerImplementation(const string& name, CreatorFunction<ShaderNodeImpl> creator);
+    
+    /// Register a shader node implementation for a given set of implementation element names
+    void registerImplementation(const StringVec& nameVec, CreatorFunction<ShaderNodeImpl> creator);
 
     /// Determine if a shader node implementation has been registered for a given implementation element name
     bool implementationRegistered(const string& name) const;
diff --git a/source/MaterialXRender/Material.cpp b/source/MaterialXRender/Material.cpp
index e5c15c54..80586bb5 100644
--- a/source/MaterialXRender/Material.cpp
+++ b/source/MaterialXRender/Material.cpp
@@ -4,6 +4,7 @@
 //
 
 #include <MaterialXRender/Material.h>
+#include <MaterialXFormat/XmlIo.h>
 
 MATERIALX_NAMESPACE_BEGIN
 
@@ -60,4 +61,43 @@ bool Material::hasTransparency() const
     return _hasTransparency;
 }
 
-MATERIALX_NAMESPACE_END
\ No newline at end of file
+bool Material::generateEnvironmentShader(GenContext& context,
+                                         const FilePath& filename,
+                                         DocumentPtr stdLib,
+                                         const FilePath& imagePath)
+{
+    // Read in the environment nodegraph.
+    DocumentPtr doc = createDocument();
+    doc->importLibrary(stdLib);
+    DocumentPtr envDoc = createDocument();
+    readFromXmlFile(envDoc, filename);
+    doc->importLibrary(envDoc);
+
+    NodeGraphPtr envGraph = doc->getNodeGraph("environmentDraw");
+    if (!envGraph)
+    {
+        return false;
+    }
+    NodePtr image = envGraph->getNode("envImage");
+    if (!image)
+    {
+        return false;
+    }
+    image->setInputValue("file", imagePath.asString(), FILENAME_TYPE_STRING);
+    OutputPtr output = envGraph->getOutput("out");
+    if (!output)
+    {
+        return false;
+    }
+
+    // Create the shader.
+    std::string shaderName = "__ENV_SHADER__";
+    _hwShader = createShader(shaderName, context, output);
+    if (!_hwShader)
+    {
+        return false;
+    }
+    return generateShader(_hwShader);
+}
+
+MATERIALX_NAMESPACE_END
diff --git a/source/MaterialXRender/Material.h b/source/MaterialXRender/Material.h
index 4f703c78..baaf1847 100644
--- a/source/MaterialXRender/Material.h
+++ b/source/MaterialXRender/Material.h
@@ -82,7 +82,7 @@ class MX_RENDER_API Material
     virtual bool generateEnvironmentShader(GenContext& context,
                                            const FilePath& filename,
                                            DocumentPtr stdLib,
-                                           const FilePath& imagePath) = 0;
+                                           const FilePath& imagePath);
     
     /// Return the underlying hardware shader.
     ShaderPtr getShader() const;
diff --git a/source/MaterialXRenderGlsl/GlslMaterial.cpp b/source/MaterialXRenderGlsl/GlslMaterial.cpp
index 8bc7f4eb..f14b3634 100644
--- a/source/MaterialXRenderGlsl/GlslMaterial.cpp
+++ b/source/MaterialXRenderGlsl/GlslMaterial.cpp
@@ -91,45 +91,6 @@ bool GlslMaterial::generateShader(ShaderPtr hwShader)
     return true;
 }
 
-bool GlslMaterial::generateEnvironmentShader(GenContext& context,
-                                             const FilePath& filename,
-                                             DocumentPtr stdLib,
-                                             const FilePath& imagePath)
-{
-    // Read in the environment nodegraph. 
-    DocumentPtr doc = createDocument();
-    doc->importLibrary(stdLib);
-    DocumentPtr envDoc = createDocument();
-    readFromXmlFile(envDoc, filename);
-    doc->importLibrary(envDoc);
-
-    NodeGraphPtr envGraph = doc->getNodeGraph("environmentDraw");
-    if (!envGraph)
-    {
-        return false;
-    }
-    NodePtr image = envGraph->getNode("envImage");
-    if (!image)
-    {
-        return false;
-    }
-    image->setInputValue("file", imagePath.asString(), FILENAME_TYPE_STRING);
-    OutputPtr output = envGraph->getOutput("out");
-    if (!output)
-    {
-        return false;
-    }
-
-    // Create the shader.
-    std::string shaderName = "__ENV_SHADER__";
-    _hwShader = createShader(shaderName, context, output); 
-    if (!_hwShader)
-    {
-        return false;
-    }
-    return generateShader(_hwShader);
-}
-
 bool GlslMaterial::bindShader() const
 {
     if (!_glProgram)
diff --git a/source/MaterialXRenderGlsl/GlslMaterial.h b/source/MaterialXRenderGlsl/GlslMaterial.h
index 9b99b4e1..3acd1fd5 100644
--- a/source/MaterialXRenderGlsl/GlslMaterial.h
+++ b/source/MaterialXRenderGlsl/GlslMaterial.h
@@ -45,12 +45,6 @@ class MX_RENDERGLSL_API GlslMaterial : public Material
 
     /// Generate a shader from the given hardware shader.
     bool generateShader(ShaderPtr hwShader) override;
-
-    /// Generate an environment background shader
-    bool generateEnvironmentShader(GenContext& context,
-                                   const FilePath& filename,
-                                   DocumentPtr stdLib,
-                                   const FilePath& imagePath) override;
     
     /// Copy shader from one material to this one
     void copyShader(GlslMaterialPtr material)
diff --git a/source/MaterialXRenderMsl/MSLPipelineStateObject.mm b/source/MaterialXRenderMsl/MSLPipelineStateObject.mm
index 2fbb2cd2..790b4919 100644
--- a/source/MaterialXRenderMsl/MSLPipelineStateObject.mm
+++ b/source/MaterialXRenderMsl/MSLPipelineStateObject.mm
@@ -559,7 +559,9 @@ ImagePtr MslProgram::bindTexture(id<MTLRenderCommandEncoder> renderCmdEncoder,
     return nullptr;
 }
 
-MaterialX::ValuePtr MslProgram::findUniformValue(const string& uniformName, const MslProgram::InputMap& uniformList)
+MaterialX::ValuePtr MslProgram::findUniformValue(
+                                    const string& uniformName,
+                                    const MslProgram::InputMap& uniformList)
 {
     auto uniform = uniformList.find(uniformName);
     if (uniform != uniformList.end())
diff --git a/source/MaterialXRenderMsl/MetalState.mm b/source/MaterialXRenderMsl/MetalState.mm
index c5c05f1b..2c6bfa37 100644
--- a/source/MaterialXRenderMsl/MetalState.mm
+++ b/source/MaterialXRenderMsl/MetalState.mm
@@ -128,7 +128,9 @@ void MetalState::initLinearToSRGBKernel()
          "{                                                             \n"
          "    half4 color_srgb;                                         \n"
          "    for(int i = 0; i < 3; ++i)                                \n"
-         "        color_srgb[i] = (color_linear[i] < 0.0031308) ? (12.92 * color_linear[i]): (1.055 * pow(color_linear[i], 1.0h / 2.2h) - 0.055);\n"
+         "        color_srgb[i] = (color_linear[i] < 0.0031308) ?       \n"
+         "          (12.92 * color_linear[i])                   :       \n"
+         "          (1.055 * pow(color_linear[i], 1.0h / 2.2h) - 0.055);\n"
          "    color_srgb[3] = color_linear[3];                          \n"
          "    return color_srgb;                                        \n"
          "}                                                             \n"
diff --git a/source/MaterialXRenderMsl/MetalTextureHandler.h b/source/MaterialXRenderMsl/MetalTextureHandler.h
index b2e9bde8..e9bffe02 100644
--- a/source/MaterialXRenderMsl/MetalTextureHandler.h
+++ b/source/MaterialXRenderMsl/MetalTextureHandler.h
@@ -27,22 +27,27 @@ using MetalTextureHandlerPtr = std::shared_ptr<class MetalTextureHandler>;
 /// An Metal texture handler class
 class MX_RENDERMSL_API MetalTextureHandler : public ImageHandler
 {
+    friend class MslProgram;
   public:
     static MetalTextureHandlerPtr create(id<MTLDevice> device, ImageLoaderPtr imageLoader)
     {
         return MetalTextureHandlerPtr(new MetalTextureHandler(device, imageLoader));
-        //std::make_shared<MetalTextureHandler>(device, imageLoader);// MetalTextureHandlerPtr(imageLoader));
     }
 
+
+    /// This method binds image and its corresponding sampling properties.
+    /// It also creates the underlying resource if needed.
+    /// Actual binding of texture and sampler to command encoder happens autoamt
+    bool bindImage(ImagePtr image, const ImageSamplingProperties& samplingProperties) override;
+    
+protected:
     /// Bind an image. This method will bind the texture to an active texture
     /// unit as defined by the corresponding image description. The method
     /// will fail if there are not enough available image units to bind to.
-    bool bindImage(ImagePtr image, const ImageSamplingProperties& samplingProperties) override;
-    
     bool bindImage(id<MTLRenderCommandEncoder> renderCmdEncoder,
                    int textureUnit,
                    ImagePtr image);
-    
+public:
     id<MTLSamplerState> getSamplerState(const ImageSamplingProperties& samplingProperties);
     
     /// Unbind an image.
diff --git a/source/MaterialXRenderMsl/MetalTextureHandler.mm b/source/MaterialXRenderMsl/MetalTextureHandler.mm
index 87907ea9..ccbc000e 100644
--- a/source/MaterialXRenderMsl/MetalTextureHandler.mm
+++ b/source/MaterialXRenderMsl/MetalTextureHandler.mm
@@ -176,8 +176,13 @@ bool MetalTextureHandler::createRenderResources(ImagePtr image, bool generateMip
     
     NSUInteger channelCount = image->getChannelCount();
     
-    NSUInteger sourceBytesPerRow = image->getWidth() * channelCount * getTextureBaseTypeSize(image->getBaseType());
-    NSUInteger sourceBytesPerImage = sourceBytesPerRow * image->getHeight();
+    NSUInteger sourceBytesPerRow =
+        image->getWidth() *
+        channelCount *
+        getTextureBaseTypeSize(image->getBaseType());
+    NSUInteger sourceBytesPerImage =
+        sourceBytesPerRow *
+        image->getHeight();
     
     std::vector<float>         rearrangedDataF;
     std::vector<unsigned char> rearrangedDataC;
diff --git a/source/MaterialXRenderMsl/MslMaterial.h b/source/MaterialXRenderMsl/MslMaterial.h
index cc70ead3..5c62f803 100644
--- a/source/MaterialXRenderMsl/MslMaterial.h
+++ b/source/MaterialXRenderMsl/MslMaterial.h
@@ -47,12 +47,6 @@ class MX_RENDERMSL_API MslMaterial : public Material
 
     /// Generate a shader from the given hardware shader.
     bool generateShader(ShaderPtr hwShader) override;
-
-    /// Generate an environment background shader
-    bool generateEnvironmentShader(GenContext& context,
-                                   const FilePath& filename,
-                                   DocumentPtr stdLib,
-                                   const FilePath& imagePath) override;
     
     /// Copy shader from one material to this one
     void copyShader(MslMaterialPtr material)
diff --git a/source/MaterialXRenderMsl/MslMaterial.mm b/source/MaterialXRenderMsl/MslMaterial.mm
index 290353fe..2de3ae8a 100644
--- a/source/MaterialXRenderMsl/MslMaterial.mm
+++ b/source/MaterialXRenderMsl/MslMaterial.mm
@@ -94,45 +94,6 @@ bool MslMaterial::generateShader(ShaderPtr hwShader)
     return true;
 }
 
-bool MslMaterial::generateEnvironmentShader(GenContext& context,
-                                         const FilePath& filename,
-                                         DocumentPtr stdLib,
-                                         const FilePath& imagePath)
-{
-    // Read in the environment nodegraph. 
-    DocumentPtr doc = createDocument();
-    doc->importLibrary(stdLib);
-    DocumentPtr envDoc = createDocument();
-    readFromXmlFile(envDoc, filename);
-    doc->importLibrary(envDoc);
-
-    NodeGraphPtr envGraph = doc->getNodeGraph("environmentDraw");
-    if (!envGraph)
-    {
-        return false;
-    }
-    NodePtr image = envGraph->getNode("envImage");
-    if (!image)
-    {
-        return false;
-    }
-    image->setInputValue("file", imagePath.asString(), FILENAME_TYPE_STRING);
-    OutputPtr output = envGraph->getOutput("out");
-    if (!output)
-    {
-        return false;
-    }
-
-    // Create the shader.
-    std::string shaderName = "__ENV_SHADER__";
-    _hwShader = createShader(shaderName, context, output); 
-    if (!_hwShader)
-    {
-        return false;
-    }
-    return generateShader(_hwShader);
-}
-
 bool MslMaterial::bindShader() const
 {
     if (_glProgram)
diff --git a/source/MaterialXTest/MaterialXRender/RenderUtil.cpp b/source/MaterialXTest/MaterialXRender/RenderUtil.cpp
index cd460aa8..62cf68c5 100644
--- a/source/MaterialXTest/MaterialXRender/RenderUtil.cpp
+++ b/source/MaterialXTest/MaterialXRender/RenderUtil.cpp
@@ -427,4 +427,222 @@ bool ShaderRenderTester::validate(const mx::FilePath optionsFilePath)
     return true;
 }
 
+void ShaderRenderTester::addAdditionalTestStreams(mx::MeshPtr mesh)
+{
+    size_t vertexCount = mesh->getVertexCount();
+    if (vertexCount < 1)
+    {
+        return;
+    }
+
+    const std::string TEXCOORD_STREAM0_NAME("i_" + mx::MeshStream::TEXCOORD_ATTRIBUTE + "_0");
+    mx::MeshStreamPtr texCoordStream1 = mesh->getStream(TEXCOORD_STREAM0_NAME);
+    mx::MeshFloatBuffer uv = texCoordStream1->getData();
+
+    const std::string TEXCOORD_STREAM1_NAME("i_" + mx::MeshStream::TEXCOORD_ATTRIBUTE + "_1");
+    mx::MeshFloatBuffer* texCoordData2 = nullptr;
+    if (!mesh->getStream(TEXCOORD_STREAM1_NAME))
+    {
+        mx::MeshStreamPtr texCoordStream2 = mx::MeshStream::create(TEXCOORD_STREAM1_NAME, mx::MeshStream::TEXCOORD_ATTRIBUTE, 1);
+        texCoordStream2->setStride(2);
+        texCoordData2 = &(texCoordStream2->getData());
+        texCoordData2->resize(vertexCount * 2);
+        mesh->addStream(texCoordStream2);
+    }
+
+    const std::string COLOR_STREAM0_NAME("i_" + mx::MeshStream::COLOR_ATTRIBUTE + "_0");
+    mx::MeshFloatBuffer* colorData1 = nullptr;
+    if (!mesh->getStream(COLOR_STREAM0_NAME))
+    {
+        mx::MeshStreamPtr colorStream1 = mx::MeshStream::create(COLOR_STREAM0_NAME, mx::MeshStream::COLOR_ATTRIBUTE, 0);
+        colorData1 = &(colorStream1->getData());
+        colorStream1->setStride(4);
+        colorData1->resize(vertexCount * 4);
+        mesh->addStream(colorStream1);
+    }
+
+    const std::string COLOR_STREAM1_NAME("i_" + mx::MeshStream::COLOR_ATTRIBUTE + "_1");
+    mx::MeshFloatBuffer* colorData2 = nullptr;
+    if (!mesh->getStream(COLOR_STREAM1_NAME))
+    {
+        mx::MeshStreamPtr colorStream2 = mx::MeshStream::create(COLOR_STREAM1_NAME, mx::MeshStream::COLOR_ATTRIBUTE, 1);
+        colorData2 = &(colorStream2->getData());
+        colorStream2->setStride(4);
+        colorData2->resize(vertexCount * 4);
+        mesh->addStream(colorStream2);
+    }
+
+    const std::string GEOM_INT_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_integer");
+    int32_t* geomIntData = nullptr;
+    if (!mesh->getStream(GEOM_INT_STREAM_NAME))
+    {
+        mx::MeshStreamPtr geomIntStream = mx::MeshStream::create(GEOM_INT_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 0);
+        geomIntStream->setStride(1);
+        geomIntStream->getData().resize(vertexCount);
+        mesh->addStream(geomIntStream);
+        // Float and int32 have same size.
+        geomIntData = reinterpret_cast<int32_t*>(geomIntStream->getData().data());
+    }
+
+    const std::string GEOM_FLOAT_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_float");
+    mx::MeshFloatBuffer* geomFloatData = nullptr;
+    if (!mesh->getStream(GEOM_FLOAT_STREAM_NAME))
+    {
+        mx::MeshStreamPtr geomFloatStream = mx::MeshStream::create(GEOM_FLOAT_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
+        geomFloatData = &(geomFloatStream->getData());
+        geomFloatStream->setStride(1);
+        geomFloatData->resize(vertexCount);
+        mesh->addStream(geomFloatStream);
+    }
+
+    const std::string GEOM_VECTOR2_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_vector2");
+    mx::MeshFloatBuffer* geomVector2Data = nullptr;
+    if (!mesh->getStream(GEOM_VECTOR2_STREAM_NAME))
+    {
+        mx::MeshStreamPtr geomVector2Stream = mx::MeshStream::create(GEOM_VECTOR2_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
+        geomVector2Data = &(geomVector2Stream->getData());
+        geomVector2Stream->setStride(2);
+        geomVector2Data->resize(vertexCount * 2);
+        mesh->addStream(geomVector2Stream);
+    }
+
+    const std::string GEOM_VECTOR3_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_vector3");
+    mx::MeshFloatBuffer* geomVector3Data = nullptr;
+    if (!mesh->getStream(GEOM_VECTOR3_STREAM_NAME))
+    {
+        mx::MeshStreamPtr geomVector3Stream = mx::MeshStream::create(GEOM_VECTOR3_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
+        geomVector3Data = &(geomVector3Stream->getData());
+        geomVector3Stream->setStride(3);
+        geomVector3Data->resize(vertexCount * 3);
+        mesh->addStream(geomVector3Stream);
+    }
+
+    const std::string GEOM_VECTOR4_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_vector4");
+    mx::MeshFloatBuffer* geomVector4Data = nullptr;
+    if (!mesh->getStream(GEOM_VECTOR4_STREAM_NAME))
+    {
+        mx::MeshStreamPtr geomVector4Stream = mx::MeshStream::create(GEOM_VECTOR4_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
+        geomVector4Data = &(geomVector4Stream->getData());
+        geomVector4Stream->setStride(4);
+        geomVector4Data->resize(vertexCount * 4);
+        mesh->addStream(geomVector4Stream);
+    }
+
+    const std::string GEOM_COLOR2_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_color2");
+    mx::MeshFloatBuffer* geomColor2Data = nullptr;
+    if (!mesh->getStream(GEOM_COLOR2_STREAM_NAME))
+    {
+        mx::MeshStreamPtr geomColor2Stream = mx::MeshStream::create(GEOM_COLOR2_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
+        geomColor2Data = &(geomColor2Stream->getData());
+        geomColor2Stream->setStride(2);
+        geomColor2Data->resize(vertexCount * 2);
+        mesh->addStream(geomColor2Stream);
+    }
+
+    const std::string GEOM_COLOR3_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_color3");
+    mx::MeshFloatBuffer* geomColor3Data = nullptr;
+    if (!mesh->getStream(GEOM_COLOR3_STREAM_NAME))
+    {
+        mx::MeshStreamPtr geomColor3Stream = mx::MeshStream::create(GEOM_COLOR3_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
+        geomColor3Data = &(geomColor3Stream->getData());
+        geomColor3Stream->setStride(3);
+        geomColor3Data->resize(vertexCount * 3);
+        mesh->addStream(geomColor3Stream);
+    }
+
+    const std::string GEOM_COLOR4_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_color4");
+    mx::MeshFloatBuffer* geomColor4Data = nullptr;
+    if (!mesh->getStream(GEOM_COLOR4_STREAM_NAME))
+    {
+        mx::MeshStreamPtr geomColor4Stream = mx::MeshStream::create(GEOM_COLOR4_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
+        geomColor4Data = &(geomColor4Stream->getData());
+        geomColor4Stream->setStride(4);
+        geomColor4Data->resize(vertexCount * 4);
+        mesh->addStream(geomColor4Stream);
+    }
+
+    auto sineData = [](float uv, float freq){
+        const float PI = std::acos(-1.0f);
+        float angle = uv * 2 * PI * freq;
+        return std::sin(angle) / 2.0f + 1.0f;
+    };
+    if (!uv.empty())
+    {
+        for (size_t i = 0; i < vertexCount; i++)
+        {
+            const size_t i2 = 2 * i;
+            const size_t i21 = i2 + 1;
+            const size_t i3 = 3 * i;
+            const size_t i4 = 4 * i;
+
+            // Fake second set of texture coordinates
+            if (texCoordData2)
+            {
+                (*texCoordData2)[i2] = uv[i21];
+                (*texCoordData2)[i21] = uv[i2];
+            }
+            if (colorData1)
+            {
+                // Fake some colors
+                (*colorData1)[i4] = uv[i2];
+                (*colorData1)[i4 + 1] = uv[i21];
+                (*colorData1)[i4 + 2] = 1.0f;
+                (*colorData1)[i4 + 3] = 1.0f;
+            }
+            if (colorData2)
+            {
+                (*colorData2)[i4] = 1.0f;
+                (*colorData2)[i4 + 1] = uv[i2];
+                (*colorData2)[i4 + 2] = uv[i21];
+                (*colorData2)[i4 + 3] = 1.0f;
+            }
+            if (geomIntData)
+            {
+                geomIntData[i] = static_cast<int32_t>(uv[i21] * 5);
+            }
+            if (geomFloatData)
+            {
+                (*geomFloatData)[i] = sineData(uv[i21], 12.0f);
+            }
+            if (geomVector2Data)
+            {
+                (*geomVector2Data)[i2] = sineData(uv[i21], 6.0f);
+                (*geomVector2Data)[i21] = 0.0f;
+            }
+            if (geomVector3Data)
+            {
+                (*geomVector3Data)[i3] = 0.0f;
+                (*geomVector3Data)[i3 + 1] = sineData(uv[i21], 8.0f);
+                (*geomVector3Data)[i3 + 2] = 0.0f;
+            }
+            if (geomVector4Data)
+            {
+                (*geomVector4Data)[i4] = 0.0f;
+                (*geomVector4Data)[i4 + 1] = 0.0f;
+                (*geomVector4Data)[i4 + 2] = sineData(uv[i21], 10.0f);
+                (*geomVector4Data)[i4 + 3] = 1.0f;
+            }
+
+            if (geomColor2Data)
+            {
+                (*geomColor2Data)[i2] = sineData(uv[i2], 10.0f);
+                (*geomColor2Data)[i21] = 0.0f;
+            }
+            if (geomColor3Data)
+            {
+                (*geomColor3Data)[i3] = 0.0f;
+                (*geomColor3Data)[i3 + 1] = sineData(uv[i2], 8.0f);
+                (*geomColor3Data)[i3 + 2] = 0.0f;
+            }
+            if (geomColor4Data)
+            {
+                (*geomColor4Data)[i4] = 0.0f;
+                (*geomColor4Data)[i4 + 1] = 0.0f;
+                (*geomColor4Data)[i4 + 2] = sineData(uv[i2], 6.0f);
+                (*geomColor4Data)[i4 + 3] = 1.0f;
+            }
+        }
+    }
+}
+
 } // namespace RenderUtil
diff --git a/source/MaterialXTest/MaterialXRender/RenderUtil.h b/source/MaterialXTest/MaterialXRender/RenderUtil.h
index e2df5aab..9f892569 100644
--- a/source/MaterialXTest/MaterialXRender/RenderUtil.h
+++ b/source/MaterialXTest/MaterialXRender/RenderUtil.h
@@ -8,6 +8,7 @@
 
 #include <MaterialXTest/MaterialXGenShader/GenShaderUtil.h>
 
+#include <MaterialXRender/Mesh.h>
 #include <MaterialXRender/ImageHandler.h>
 #include <MaterialXRender/Timer.h>
 #include <MaterialXRender/Util.h>
@@ -170,6 +171,9 @@ class ShaderRenderTester
     virtual bool canBake() const { return false; }
     virtual void runBake(mx::DocumentPtr /*doc*/, const mx::FileSearchPath& /*codeSearchPath*/, const mx::FilePath& /*outputFilename*/,
                          const GenShaderUtil::TestSuiteOptions::BakeSetting& /*bakeOptions*/, std::ostream& /*log*/) {};
+    
+    // If these streams don't exist add them for testing purposes
+    void addAdditionalTestStreams(mx::MeshPtr mesh);
 
     // Generator to use
     mx::ShaderGeneratorPtr _shaderGenerator;
diff --git a/source/MaterialXTest/MaterialXRenderGlsl/RenderGlsl.cpp b/source/MaterialXTest/MaterialXRenderGlsl/RenderGlsl.cpp
index e4019ca9..01c01bc5 100644
--- a/source/MaterialXTest/MaterialXRenderGlsl/RenderGlsl.cpp
+++ b/source/MaterialXTest/MaterialXRenderGlsl/RenderGlsl.cpp
@@ -151,226 +151,6 @@ bool GlslShaderRenderTester::saveImage(const mx::FilePath& filePath, mx::ConstIm
     return _renderer->getImageHandler()->saveImage(filePath, image, verticalFlip);
 }
 
-// If these streams don't exist add them for testing purposes
-//
-void addAdditionalTestStreams(mx::MeshPtr mesh)
-{
-    size_t vertexCount = mesh->getVertexCount();
-    if (vertexCount < 1)
-    {
-        return;
-    }
-
-    const std::string TEXCOORD_STREAM0_NAME("i_" + mx::MeshStream::TEXCOORD_ATTRIBUTE + "_0");
-    mx::MeshStreamPtr texCoordStream1 = mesh->getStream(TEXCOORD_STREAM0_NAME);
-    mx::MeshFloatBuffer uv = texCoordStream1->getData();
-
-    const std::string TEXCOORD_STREAM1_NAME("i_" + mx::MeshStream::TEXCOORD_ATTRIBUTE + "_1");
-    mx::MeshFloatBuffer* texCoordData2 = nullptr;
-    if (!mesh->getStream(TEXCOORD_STREAM1_NAME))
-    {
-        mx::MeshStreamPtr texCoordStream2 = mx::MeshStream::create(TEXCOORD_STREAM1_NAME, mx::MeshStream::TEXCOORD_ATTRIBUTE, 1);
-        texCoordStream2->setStride(2);
-        texCoordData2 = &(texCoordStream2->getData());
-        texCoordData2->resize(vertexCount * 2);
-        mesh->addStream(texCoordStream2);
-    }
-
-    const std::string COLOR_STREAM0_NAME("i_" + mx::MeshStream::COLOR_ATTRIBUTE + "_0");
-    mx::MeshFloatBuffer* colorData1 = nullptr;
-    if (!mesh->getStream(COLOR_STREAM0_NAME))
-    {
-        mx::MeshStreamPtr colorStream1 = mx::MeshStream::create(COLOR_STREAM0_NAME, mx::MeshStream::COLOR_ATTRIBUTE, 0);
-        colorData1 = &(colorStream1->getData());
-        colorStream1->setStride(4);
-        colorData1->resize(vertexCount * 4);
-        mesh->addStream(colorStream1);
-    }
-
-    const std::string COLOR_STREAM1_NAME("i_" + mx::MeshStream::COLOR_ATTRIBUTE + "_1");
-    mx::MeshFloatBuffer* colorData2 = nullptr;
-    if (!mesh->getStream(COLOR_STREAM1_NAME))
-    {
-        mx::MeshStreamPtr colorStream2 = mx::MeshStream::create(COLOR_STREAM1_NAME, mx::MeshStream::COLOR_ATTRIBUTE, 1);
-        colorData2 = &(colorStream2->getData());
-        colorStream2->setStride(4);
-        colorData2->resize(vertexCount * 4);
-        mesh->addStream(colorStream2);
-    }
-
-    const std::string GEOM_INT_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_integer");
-    int32_t* geomIntData = nullptr;
-    if (!mesh->getStream(GEOM_INT_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomIntStream = mx::MeshStream::create(GEOM_INT_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 0);
-        geomIntStream->setStride(1);
-        geomIntStream->getData().resize(vertexCount);
-        mesh->addStream(geomIntStream);
-        // Float and int32 have same size.
-        geomIntData = reinterpret_cast<int32_t*>(geomIntStream->getData().data());
-    }
-
-    const std::string GEOM_FLOAT_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_float");
-    mx::MeshFloatBuffer* geomFloatData = nullptr;
-    if (!mesh->getStream(GEOM_FLOAT_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomFloatStream = mx::MeshStream::create(GEOM_FLOAT_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomFloatData = &(geomFloatStream->getData());
-        geomFloatStream->setStride(1);
-        geomFloatData->resize(vertexCount);
-        mesh->addStream(geomFloatStream);
-    }
-
-    const std::string GEOM_VECTOR2_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_vector2");
-    mx::MeshFloatBuffer* geomVector2Data = nullptr;
-    if (!mesh->getStream(GEOM_VECTOR2_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomVector2Stream = mx::MeshStream::create(GEOM_VECTOR2_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomVector2Data = &(geomVector2Stream->getData());
-        geomVector2Stream->setStride(2);
-        geomVector2Data->resize(vertexCount * 2);
-        mesh->addStream(geomVector2Stream);
-    }
-
-    const std::string GEOM_VECTOR3_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_vector3");
-    mx::MeshFloatBuffer* geomVector3Data = nullptr;
-    if (!mesh->getStream(GEOM_VECTOR3_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomVector3Stream = mx::MeshStream::create(GEOM_VECTOR3_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomVector3Data = &(geomVector3Stream->getData());
-        geomVector3Stream->setStride(3);
-        geomVector3Data->resize(vertexCount * 3);
-        mesh->addStream(geomVector3Stream);
-    }
-
-    const std::string GEOM_VECTOR4_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_vector4");
-    mx::MeshFloatBuffer* geomVector4Data = nullptr;
-    if (!mesh->getStream(GEOM_VECTOR4_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomVector4Stream = mx::MeshStream::create(GEOM_VECTOR4_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomVector4Data = &(geomVector4Stream->getData());
-        geomVector4Stream->setStride(4);
-        geomVector4Data->resize(vertexCount * 4);
-        mesh->addStream(geomVector4Stream);
-    }
-
-    const std::string GEOM_COLOR2_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_color2");
-    mx::MeshFloatBuffer* geomColor2Data = nullptr;
-    if (!mesh->getStream(GEOM_COLOR2_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomColor2Stream = mx::MeshStream::create(GEOM_COLOR2_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomColor2Data = &(geomColor2Stream->getData());
-        geomColor2Stream->setStride(2);
-        geomColor2Data->resize(vertexCount * 2);
-        mesh->addStream(geomColor2Stream);
-    }
-
-    const std::string GEOM_COLOR3_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_color3");
-    mx::MeshFloatBuffer* geomColor3Data = nullptr;
-    if (!mesh->getStream(GEOM_COLOR3_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomColor3Stream = mx::MeshStream::create(GEOM_COLOR3_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomColor3Data = &(geomColor3Stream->getData());
-        geomColor3Stream->setStride(3);
-        geomColor3Data->resize(vertexCount * 3);
-        mesh->addStream(geomColor3Stream);
-    }
-
-    const std::string GEOM_COLOR4_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_color4");
-    mx::MeshFloatBuffer* geomColor4Data = nullptr;
-    if (!mesh->getStream(GEOM_COLOR4_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomColor4Stream = mx::MeshStream::create(GEOM_COLOR4_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomColor4Data = &(geomColor4Stream->getData());
-        geomColor4Stream->setStride(4);
-        geomColor4Data->resize(vertexCount * 4);
-        mesh->addStream(geomColor4Stream);
-    }
-
-    auto sineData = [](float uv, float freq){
-        const float PI = std::acos(-1.0f);
-        float angle = uv * 2 * PI * freq;
-        return std::sin(angle) / 2.0f + 1.0f;
-    };
-    if (!uv.empty())
-    {
-        for (size_t i = 0; i < vertexCount; i++)
-        {
-            const size_t i2 = 2 * i;
-            const size_t i21 = i2 + 1;
-            const size_t i3 = 3 * i;
-            const size_t i4 = 4 * i;
-
-            // Fake second set of texture coordinates
-            if (texCoordData2)
-            {
-                (*texCoordData2)[i2] = uv[i21];
-                (*texCoordData2)[i21] = uv[i2];
-            }
-            if (colorData1)
-            {
-                // Fake some colors
-                (*colorData1)[i4] = uv[i2];
-                (*colorData1)[i4 + 1] = uv[i21];
-                (*colorData1)[i4 + 2] = 1.0f;
-                (*colorData1)[i4 + 3] = 1.0f;
-            }
-            if (colorData2)
-            {
-                (*colorData2)[i4] = 1.0f;
-                (*colorData2)[i4 + 1] = uv[i2];
-                (*colorData2)[i4 + 2] = uv[i21];
-                (*colorData2)[i4 + 3] = 1.0f;
-            }
-            if (geomIntData)
-            {
-                geomIntData[i] = static_cast<int32_t>(uv[i21] * 5);
-            }
-            if (geomFloatData)
-            {
-                (*geomFloatData)[i] = sineData(uv[i21], 12.0f);
-            }
-            if (geomVector2Data)
-            {
-                (*geomVector2Data)[i2] = sineData(uv[i21], 6.0f);
-                (*geomVector2Data)[i21] = 0.0f;
-            }
-            if (geomVector3Data)
-            {
-                (*geomVector3Data)[i3] = 0.0f;
-                (*geomVector3Data)[i3 + 1] = sineData(uv[i21], 8.0f);
-                (*geomVector3Data)[i3 + 2] = 0.0f;
-            }
-            if (geomVector4Data)
-            {
-                (*geomVector4Data)[i4] = 0.0f;
-                (*geomVector4Data)[i4 + 1] = 0.0f;
-                (*geomVector4Data)[i4 + 2] = sineData(uv[i21], 10.0f);
-                (*geomVector4Data)[i4 + 3] = 1.0f;
-            }
-
-            if (geomColor2Data)
-            {
-                (*geomColor2Data)[i2] = sineData(uv[i2], 10.0f);
-                (*geomColor2Data)[i21] = 0.0f;
-            }
-            if (geomColor3Data)
-            {
-                (*geomColor3Data)[i3] = 0.0f;
-                (*geomColor3Data)[i3 + 1] = sineData(uv[i2], 8.0f);
-                (*geomColor3Data)[i3 + 2] = 0.0f;
-            }
-            if (geomColor4Data)
-            {
-                (*geomColor4Data)[i4] = 0.0f;
-                (*geomColor4Data)[i4 + 1] = 0.0f;
-                (*geomColor4Data)[i4 + 2] = sineData(uv[i2], 6.0f);
-                (*geomColor4Data)[i4 + 3] = 1.0f;
-            }
-        }
-    }
-}
-
 bool GlslShaderRenderTester::runRenderer(const std::string& shaderName,
                                           mx::TypedElementPtr element,
                                           mx::GenContext& context,
diff --git a/source/MaterialXTest/MaterialXRenderMsl/RenderMsl.mm b/source/MaterialXTest/MaterialXRenderMsl/RenderMsl.mm
index 283a4556..d39fe2cc 100644
--- a/source/MaterialXTest/MaterialXRenderMsl/RenderMsl.mm
+++ b/source/MaterialXTest/MaterialXRenderMsl/RenderMsl.mm
@@ -162,226 +162,6 @@ bool MslShaderRenderTester::saveImage(const mx::FilePath& filePath, mx::ConstIma
     return _renderer->getImageHandler()->saveImage(filePath, image, verticalFlip);
 }
 
-// If these streams don't exist add them for testing purposes
-//
-void addAdditionalTestStreamsMetal(mx::MeshPtr mesh)
-{
-    size_t vertexCount = mesh->getVertexCount();
-    if (vertexCount < 1)
-    {
-        return;
-    }
-
-    const std::string TEXCOORD_STREAM0_NAME("i_" + mx::MeshStream::TEXCOORD_ATTRIBUTE + "_0");
-    mx::MeshStreamPtr texCoordStream1 = mesh->getStream(TEXCOORD_STREAM0_NAME);
-    mx::MeshFloatBuffer uv = texCoordStream1->getData();
-
-    const std::string TEXCOORD_STREAM1_NAME("i_" + mx::MeshStream::TEXCOORD_ATTRIBUTE + "_1");
-    mx::MeshFloatBuffer* texCoordData2 = nullptr;
-    if (!mesh->getStream(TEXCOORD_STREAM1_NAME))
-    {
-        mx::MeshStreamPtr texCoordStream2 = mx::MeshStream::create(TEXCOORD_STREAM1_NAME, mx::MeshStream::TEXCOORD_ATTRIBUTE, 1);
-        texCoordStream2->setStride(2);
-        texCoordData2 = &(texCoordStream2->getData());
-        texCoordData2->resize(vertexCount * 2);
-        mesh->addStream(texCoordStream2);
-    }
-
-    const std::string COLOR_STREAM0_NAME("i_" + mx::MeshStream::COLOR_ATTRIBUTE + "_0");
-    mx::MeshFloatBuffer* colorData1 = nullptr;
-    if (!mesh->getStream(COLOR_STREAM0_NAME))
-    {
-        mx::MeshStreamPtr colorStream1 = mx::MeshStream::create(COLOR_STREAM0_NAME, mx::MeshStream::COLOR_ATTRIBUTE, 0);
-        colorData1 = &(colorStream1->getData());
-        colorStream1->setStride(4);
-        colorData1->resize(vertexCount * 4);
-        mesh->addStream(colorStream1);
-    }
-
-    const std::string COLOR_STREAM1_NAME("i_" + mx::MeshStream::COLOR_ATTRIBUTE + "_1");
-    mx::MeshFloatBuffer* colorData2 = nullptr;
-    if (!mesh->getStream(COLOR_STREAM1_NAME))
-    {
-        mx::MeshStreamPtr colorStream2 = mx::MeshStream::create(COLOR_STREAM1_NAME, mx::MeshStream::COLOR_ATTRIBUTE, 1);
-        colorData2 = &(colorStream2->getData());
-        colorStream2->setStride(4);
-        colorData2->resize(vertexCount * 4);
-        mesh->addStream(colorStream2);
-    }
-
-    const std::string GEOM_INT_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_integer");
-    int32_t* geomIntData = nullptr;
-    if (!mesh->getStream(GEOM_INT_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomIntStream = mx::MeshStream::create(GEOM_INT_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 0);
-        geomIntStream->setStride(1);
-        geomIntStream->getData().resize(vertexCount);
-        mesh->addStream(geomIntStream);
-        // Float and int32 have same size.
-        geomIntData = reinterpret_cast<int32_t*>(geomIntStream->getData().data());
-    }
-
-    const std::string GEOM_FLOAT_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_float");
-    mx::MeshFloatBuffer* geomFloatData = nullptr;
-    if (!mesh->getStream(GEOM_FLOAT_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomFloatStream = mx::MeshStream::create(GEOM_FLOAT_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomFloatData = &(geomFloatStream->getData());
-        geomFloatStream->setStride(1);
-        geomFloatData->resize(vertexCount);
-        mesh->addStream(geomFloatStream);
-    }
-
-    const std::string GEOM_VECTOR2_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_vector2");
-    mx::MeshFloatBuffer* geomVector2Data = nullptr;
-    if (!mesh->getStream(GEOM_VECTOR2_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomVector2Stream = mx::MeshStream::create(GEOM_VECTOR2_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomVector2Data = &(geomVector2Stream->getData());
-        geomVector2Stream->setStride(2);
-        geomVector2Data->resize(vertexCount * 2);
-        mesh->addStream(geomVector2Stream);
-    }
-
-    const std::string GEOM_VECTOR3_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_vector3");
-    mx::MeshFloatBuffer* geomVector3Data = nullptr;
-    if (!mesh->getStream(GEOM_VECTOR3_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomVector3Stream = mx::MeshStream::create(GEOM_VECTOR3_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomVector3Data = &(geomVector3Stream->getData());
-        geomVector3Stream->setStride(3);
-        geomVector3Data->resize(vertexCount * 3);
-        mesh->addStream(geomVector3Stream);
-    }
-
-    const std::string GEOM_VECTOR4_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_vector4");
-    mx::MeshFloatBuffer* geomVector4Data = nullptr;
-    if (!mesh->getStream(GEOM_VECTOR4_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomVector4Stream = mx::MeshStream::create(GEOM_VECTOR4_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomVector4Data = &(geomVector4Stream->getData());
-        geomVector4Stream->setStride(4);
-        geomVector4Data->resize(vertexCount * 4);
-        mesh->addStream(geomVector4Stream);
-    }
-
-    const std::string GEOM_COLOR2_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_color2");
-    mx::MeshFloatBuffer* geomColor2Data = nullptr;
-    if (!mesh->getStream(GEOM_COLOR2_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomColor2Stream = mx::MeshStream::create(GEOM_COLOR2_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomColor2Data = &(geomColor2Stream->getData());
-        geomColor2Stream->setStride(2);
-        geomColor2Data->resize(vertexCount * 2);
-        mesh->addStream(geomColor2Stream);
-    }
-
-    const std::string GEOM_COLOR3_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_color3");
-    mx::MeshFloatBuffer* geomColor3Data = nullptr;
-    if (!mesh->getStream(GEOM_COLOR3_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomColor3Stream = mx::MeshStream::create(GEOM_COLOR3_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomColor3Data = &(geomColor3Stream->getData());
-        geomColor3Stream->setStride(3);
-        geomColor3Data->resize(vertexCount * 3);
-        mesh->addStream(geomColor3Stream);
-    }
-
-    const std::string GEOM_COLOR4_STREAM_NAME("i_" + mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE + "_geompropvalue_color4");
-    mx::MeshFloatBuffer* geomColor4Data = nullptr;
-    if (!mesh->getStream(GEOM_COLOR4_STREAM_NAME))
-    {
-        mx::MeshStreamPtr geomColor4Stream = mx::MeshStream::create(GEOM_COLOR4_STREAM_NAME, mx::MeshStream::GEOMETRY_PROPERTY_ATTRIBUTE, 1);
-        geomColor4Data = &(geomColor4Stream->getData());
-        geomColor4Stream->setStride(4);
-        geomColor4Data->resize(vertexCount * 4);
-        mesh->addStream(geomColor4Stream);
-    }
-
-    auto sineData = [](float uv, float freq){
-        const float PI = std::acos(-1.0f);
-        float angle = uv * 2 * PI * freq;
-        return std::sin(angle) / 2.0f + 1.0f;
-    };
-    if (!uv.empty())
-    {
-        for (size_t i = 0; i < vertexCount; i++)
-        {
-            const size_t i2 = 2 * i;
-            const size_t i21 = i2 + 1;
-            const size_t i3 = 3 * i;
-            const size_t i4 = 4 * i;
-
-            // Fake second set of texture coordinates
-            if (texCoordData2)
-            {
-                (*texCoordData2)[i2] = uv[i21];
-                (*texCoordData2)[i21] = uv[i2];
-            }
-            if (colorData1)
-            {
-                // Fake some colors
-                (*colorData1)[i4] = uv[i2];
-                (*colorData1)[i4 + 1] = uv[i21];
-                (*colorData1)[i4 + 2] = 1.0f;
-                (*colorData1)[i4 + 3] = 1.0f;
-            }
-            if (colorData2)
-            {
-                (*colorData2)[i4] = 1.0f;
-                (*colorData2)[i4 + 1] = uv[i2];
-                (*colorData2)[i4 + 2] = uv[i21];
-                (*colorData2)[i4 + 3] = 1.0f;
-            }
-            if (geomIntData)
-            {
-                geomIntData[i] = static_cast<int32_t>(uv[i21] * 5);
-            }
-            if (geomFloatData)
-            {
-                (*geomFloatData)[i] = sineData(uv[i21], 12.0f);
-            }
-            if (geomVector2Data)
-            {
-                (*geomVector2Data)[i2] = sineData(uv[i21], 6.0f);
-                (*geomVector2Data)[i21] = 0.0f;
-            }
-            if (geomVector3Data)
-            {
-                (*geomVector3Data)[i3] = 0.0f;
-                (*geomVector3Data)[i3 + 1] = sineData(uv[i21], 8.0f);
-                (*geomVector3Data)[i3 + 2] = 0.0f;
-            }
-            if (geomVector4Data)
-            {
-                (*geomVector4Data)[i4] = 0.0f;
-                (*geomVector4Data)[i4 + 1] = 0.0f;
-                (*geomVector4Data)[i4 + 2] = sineData(uv[i21], 10.0f);
-                (*geomVector4Data)[i4 + 3] = 1.0f;
-            }
-
-            if (geomColor2Data)
-            {
-                (*geomColor2Data)[i2] = sineData(uv[i2], 10.0f);
-                (*geomColor2Data)[i21] = 0.0f;
-            }
-            if (geomColor3Data)
-            {
-                (*geomColor3Data)[i3] = 0.0f;
-                (*geomColor3Data)[i3 + 1] = sineData(uv[i2], 8.0f);
-                (*geomColor3Data)[i3 + 2] = 0.0f;
-            }
-            if (geomColor4Data)
-            {
-                (*geomColor4Data)[i4] = 0.0f;
-                (*geomColor4Data)[i4 + 1] = 0.0f;
-                (*geomColor4Data)[i4 + 2] = sineData(uv[i2], 6.0f);
-                (*geomColor4Data)[i4 + 3] = 1.0f;
-            }
-        }
-    }
-}
-
 bool MslShaderRenderTester::runRenderer(const std::string& shaderName,
                                           mx::TypedElementPtr element,
                                           mx::GenContext& context,
@@ -515,7 +295,7 @@ bool MslShaderRenderTester::runRenderer(const std::string& shaderName,
                     geomHandler->loadGeometry(geomPath, texcoordVerticalFlip);
                     for (mx::MeshPtr mesh : geomHandler->getMeshes())
                     {
-                        addAdditionalTestStreamsMetal(mesh);
+                        addAdditionalTestStreams(mesh);
                     }
                 }
 
@@ -688,4 +468,4 @@ TEST_CASE("Render: MSL TestSuite", "[rendermsl]")
     renderTester.validate(optionsFilePath);
 }
 
-#endif
\ No newline at end of file
+#endif
-- 
2.37.0

From 26dc6936554237c28566587e69d3e36b22e186b2 Mon Sep 17 00:00:00 2001
From: Morteza Mostajab <smostajabodaveh@apple.com>
Date: Mon, 6 Mar 2023 16:02:03 +0000
Subject: [PATCH] Handling better metal texture and sampler generation

---
 source/MaterialXGenMsl/MslShaderGenerator.cpp       | 9 +++++----
 source/MaterialXGenMsl/MslShaderGenerator.h         | 3 +++
 source/MaterialXRenderMsl/MSLPipelineStateObject.mm | 9 +++++----
 source/MaterialXRenderMsl/MslMaterial.mm            | 8 ++++----
 4 files changed, 17 insertions(+), 12 deletions(-)

diff --git a/source/MaterialXGenMsl/MslShaderGenerator.cpp b/source/MaterialXGenMsl/MslShaderGenerator.cpp
index 1bdd9784..2b94b428 100644
--- a/source/MaterialXGenMsl/MslShaderGenerator.cpp
+++ b/source/MaterialXGenMsl/MslShaderGenerator.cpp
@@ -350,6 +350,7 @@ void MslShaderGenerator::MetalizeGeneratedShader(ShaderStage& shaderStage) const
         }
     }
     
+    // Renames GLSL constructs that are used in shared code to MSL equivalent constructs.
     std::unordered_map<string, string> replaceTokens;
     replaceTokens["sampler2D"] = "MetalTexture";
     replaceTokens["dFdy"] = "dfdy";
@@ -563,9 +564,9 @@ DEFINE_SHADER_STAGE(stage, Stage::PIXEL)
                             emitString(separator, stage);
                             emitString("MetalTexture", stage);
                             emitScopeBegin(stage);
-                            emitString(uniforms[i]->getVariable() + "_tex", stage);
+                            emitString(TEXTURE_NAME(uniforms[i]->getVariable()), stage);
                             emitString(separator, stage);
-                            emitString(uniforms[i]->getVariable() + "_sampler", stage);
+                            emitString(SAMPLER_NAME(uniforms[i]->getVariable()), stage);
                             emitScopeEnd(stage);
                         }
                         else if (globalContextMembers || globalContextConstructorParams)
@@ -598,9 +599,9 @@ DEFINE_SHADER_STAGE(stage, Stage::PIXEL)
                     if (uniform->getType() == Type::FILENAME)
                     {
                         emitString(separator, stage);
-                        emitString("texture2d<float> " + uniform->getVariable() + "_tex", stage);
+                        emitString("texture2d<float> " + TEXTURE_NAME(uniform->getVariable()), stage);
                         emitString(" [[texture(" + std::to_string(tex_slot) + ")]], ", stage);
-                        emitString("sampler " + uniform->getVariable() + "_sampler", stage);
+                        emitString("sampler " + SAMPLER_NAME(uniform->getVariable()), stage);
                         emitString(" [[sampler(" + std::to_string(tex_slot++) + ")]]", stage);
                         emitLineEnd(stage, false);
                     }
diff --git a/source/MaterialXGenMsl/MslShaderGenerator.h b/source/MaterialXGenMsl/MslShaderGenerator.h
index 094a06b3..93bbaa3f 100644
--- a/source/MaterialXGenMsl/MslShaderGenerator.h
+++ b/source/MaterialXGenMsl/MslShaderGenerator.h
@@ -13,6 +13,9 @@
 
 #include <MaterialXGenShader/HwShaderGenerator.h>
 
+#define TEXTURE_NAME(t) (t + "_tex")
+#define SAMPLER_NAME(t) (t + "_sampler")
+
 MATERIALX_NAMESPACE_BEGIN
 
 using MslShaderGeneratorPtr = shared_ptr<class MslShaderGenerator>;
diff --git a/source/MaterialXRenderMsl/MSLPipelineStateObject.mm b/source/MaterialXRenderMsl/MSLPipelineStateObject.mm
index 790b4919..2f3a7984 100644
--- a/source/MaterialXRenderMsl/MSLPipelineStateObject.mm
+++ b/source/MaterialXRenderMsl/MSLPipelineStateObject.mm
@@ -11,6 +11,7 @@
 #include <MaterialXRender/ShaderRenderer.h>
 
 #include <MaterialXGenShader/HwShaderGenerator.h>
+#include <MaterialXGenMsl/MslShaderGenerator.h>
 #include <MaterialXGenShader/Util.h>
 
 #include <iostream>
@@ -716,7 +717,7 @@ void MslProgram::bindLighting(LightHandlerPtr lightHandler, ImageHandlerPtr imag
     };
     for (const auto& env : envLights)
     {
-        auto iblUniform = uniformList.find(env.first + "_tex");
+        auto iblUniform = uniformList.find(TEXTURE_NAME(env.first));
         MslProgram::InputPtr inputPtr = iblUniform != uniformList.end() ? iblUniform->second : nullptr;
         if (inputPtr)
         {
@@ -801,14 +802,14 @@ void MslProgram::bindLighting(LightHandlerPtr lightHandler, ImageHandlerPtr imag
 
     // Bind the directional albedo table, if needed.
     ImagePtr albedoTable = lightHandler->getAlbedoTable();
-    if (albedoTable && hasUniform(HW::ALBEDO_TABLE + "_tex"))
+    if (albedoTable && hasUniform(TEXTURE_NAME(HW::ALBEDO_TABLE)))
     {
         ImageSamplingProperties samplingProperties;
         samplingProperties.uaddressMode = ImageSamplingProperties::AddressMode::CLAMP;
         samplingProperties.vaddressMode = ImageSamplingProperties::AddressMode::CLAMP;
         samplingProperties.filterType = ImageSamplingProperties::FilterType::LINEAR;
         bindTexture(imageHandler,
-                    HW::ALBEDO_TABLE + "_tex",
+                    TEXTURE_NAME(HW::ALBEDO_TABLE),
                     albedoTable,
                     samplingProperties);
     }
@@ -1112,7 +1113,7 @@ try_again:      if (inputIt != _uniformList.end())
                         ++tries;
                         if(v->getType() == Type::FILENAME)
                         {
-                            inputIt = _uniformList.find(v->getVariable() + "_tex");
+                            inputIt = _uniformList.find(TEXTURE_NAME(v->getVariable()));
                         }
                         else
                         {
diff --git a/source/MaterialXRenderMsl/MslMaterial.mm b/source/MaterialXRenderMsl/MslMaterial.mm
index 2de3ae8a..d27b894e 100644
--- a/source/MaterialXRenderMsl/MslMaterial.mm
+++ b/source/MaterialXRenderMsl/MslMaterial.mm
@@ -244,7 +244,7 @@ void MslMaterial::bindLighting(LightHandlerPtr lightHandler,
     _glProgram->bindLighting(lightHandler, imageHandler);
 
     // Bind shadow map properties
-    if (shadowState.shadowMap && _glProgram->hasUniform(HW::SHADOW_MAP + "_tex"))
+    if (shadowState.shadowMap && _glProgram->hasUniform(TEXTURE_NAME(HW::SHADOW_MAP)))
     {
         ImageSamplingProperties samplingProperties;
         samplingProperties.uaddressMode = ImageSamplingProperties::AddressMode::CLAMP;
@@ -252,12 +252,12 @@ void MslMaterial::bindLighting(LightHandlerPtr lightHandler,
         samplingProperties.filterType = ImageSamplingProperties::FilterType::LINEAR;
 
         // Bind the shadow map.
-        _glProgram->bindTexture(imageHandler, HW::SHADOW_MAP + "_tex", shadowState.shadowMap, samplingProperties);
+        _glProgram->bindTexture(imageHandler, TEXTURE_NAME(HW::SHADOW_MAP), shadowState.shadowMap, samplingProperties);
         _glProgram->bindUniform(HW::SHADOW_MATRIX, Value::createValue(shadowState.shadowMatrix));
     }
 
     // Bind ambient occlusion properties.
-    if (shadowState.ambientOcclusionMap && _glProgram->hasUniform(HW::AMB_OCC_MAP + "_tex"))
+    if (shadowState.ambientOcclusionMap && _glProgram->hasUniform(TEXTURE_NAME(HW::AMB_OCC_MAP)))
     {
         ImageSamplingProperties samplingProperties;
         samplingProperties.uaddressMode = ImageSamplingProperties::AddressMode::PERIODIC;
@@ -265,7 +265,7 @@ void MslMaterial::bindLighting(LightHandlerPtr lightHandler,
         samplingProperties.filterType = ImageSamplingProperties::FilterType::LINEAR;
 
         // Bind the ambient occlusion map.
-        _glProgram->bindTexture(imageHandler, HW::AMB_OCC_MAP + "_tex",
+        _glProgram->bindTexture(imageHandler, TEXTURE_NAME(HW::AMB_OCC_MAP),
                                 shadowState.ambientOcclusionMap,
                                 samplingProperties);
         
-- 
2.37.0

From 5f21e4464436807990a3afa9ecf4365da828c5e3 Mon Sep 17 00:00:00 2001
From: Morteza Mostajab <smostajabodaveh@apple.com>
Date: Mon, 6 Mar 2023 17:48:09 +0000
Subject: [PATCH] Proper comment and adjustment for alignments

---
 source/MaterialXGenMsl/MslResourceBindingContext.cpp | 7 +++++--
 source/MaterialXGenMsl/MslShaderGenerator.cpp        | 2 +-
 2 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/source/MaterialXGenMsl/MslResourceBindingContext.cpp b/source/MaterialXGenMsl/MslResourceBindingContext.cpp
index 48aa9cf5..f372c428 100644
--- a/source/MaterialXGenMsl/MslResourceBindingContext.cpp
+++ b/source/MaterialXGenMsl/MslResourceBindingContext.cpp
@@ -71,12 +71,15 @@ void MslResourceBindingContext::emitStructuredResourceBindings(GenContext& conte
     ShaderGenerator& generator = context.getShaderGenerator();
 
     const size_t baseAlignment = 16;
-    std::unordered_map<const TypeDesc*, size_t> alignmentMap({ { Type::FLOAT, baseAlignment / 4 },
+    // Values are adjusted based on
+    // https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf
+    std::unordered_map<const TypeDesc*, size_t> alignmentMap({
+        { Type::FLOAT, baseAlignment / 4 },
         { Type::INTEGER, baseAlignment / 4 },
         { Type::BOOLEAN, baseAlignment / 4 },
         { Type::COLOR3, baseAlignment },
         { Type::COLOR4, baseAlignment },
-        { Type::VECTOR2, baseAlignment },
+        { Type::VECTOR2, baseAlignment / 2 },
         { Type::VECTOR3, baseAlignment },
         { Type::VECTOR4, baseAlignment },
         { Type::MATRIX33, baseAlignment * 4 },
diff --git a/source/MaterialXGenMsl/MslShaderGenerator.cpp b/source/MaterialXGenMsl/MslShaderGenerator.cpp
index 2b94b428..6cd7526d 100644
--- a/source/MaterialXGenMsl/MslShaderGenerator.cpp
+++ b/source/MaterialXGenMsl/MslShaderGenerator.cpp
@@ -760,7 +760,7 @@ void MslShaderGenerator::emitDirectives(GenContext&, ShaderStage& stage) const
 {
     // Add directives
     emitLine("//Metal Shading Language version " + getVersion(), stage, false);
-    emitLine("#define __METAL__ 1",       stage, false);
+    emitLine("#define __METAL__ ",      stage, false);
     emitLine("#include <metal_stdlib>", stage, false);
     emitLine("#include <simd/simd.h>",  stage, false);
     emitLine("using namespace metal;",  stage, false);
-- 
2.37.0

From dffee917d9897a3dd0f0f829959c96ce5f335a90 Mon Sep 17 00:00:00 2001
From: Morteza Mostajab <smostajabodaveh@apple.com>
Date: Tue, 7 Mar 2023 13:20:49 +0000
Subject: [PATCH] Moved Texture Baker to a shared file in MaterialXRender layer
 and instantiated it differently for Metal and OpenGL

---
 source/MaterialXRender/CMakeLists.txt         |   4 +-
 source/MaterialXRender/TextureBaker.h         | 297 ++++++++
 source/MaterialXRender/TextureBaker.inl       | 638 ++++++++++++++++++
 source/MaterialXRenderGlsl/GlslRenderer.h     |   7 +
 source/MaterialXRenderGlsl/TextureBaker.cpp   | 610 +----------------
 source/MaterialXRenderGlsl/TextureBaker.h     | 272 +-------
 source/MaterialXRenderMsl/MslRenderer.h       |   8 +
 source/MaterialXRenderMsl/TextureBaker.h      | 267 +-------
 source/MaterialXRenderMsl/TextureBaker.mm     | 617 +----------------
 .../MaterialXRenderGlsl/RenderGlsl.cpp        |   7 +-
 .../MaterialXRenderMsl/RenderMsl.mm           |   4 +-
 source/MaterialXView/ViewerMSL.mm             |   2 +-
 12 files changed, 981 insertions(+), 1752 deletions(-)
 create mode 100644 source/MaterialXRender/TextureBaker.h
 create mode 100644 source/MaterialXRender/TextureBaker.inl

diff --git a/source/MaterialXRender/CMakeLists.txt b/source/MaterialXRender/CMakeLists.txt
index 00337929..63ebe906 100644
--- a/source/MaterialXRender/CMakeLists.txt
+++ b/source/MaterialXRender/CMakeLists.txt
@@ -3,6 +3,7 @@ include_directories(
     ${CMAKE_CURRENT_SOURCE_DIR}/../)
 
 file(GLOB_RECURSE materialx_source "${CMAKE_CURRENT_SOURCE_DIR}/*.cpp")
+file(GLOB_RECURSE materialx_inlined "${CMAKE_CURRENT_SOURCE_DIR}/*.inl")
 file(GLOB_RECURSE materialx_headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h*")
 
 if(NOT MATERIALX_BUILD_OIIO)
@@ -10,13 +11,14 @@ if(NOT MATERIALX_BUILD_OIIO)
 endif()
 
 assign_source_group("Source Files" ${materialx_source})
+assign_source_group("Source Files" ${materialx_inlined})
 assign_source_group("Header Files" ${materialx_headers})
 
 if(UNIX)
     add_compile_options(-Wno-unused-function)
 endif()
 
-add_library(MaterialXRender ${materialx_source} ${materialx_headers})
+add_library(MaterialXRender ${materialx_source} ${materialx_headers} ${materialx_inlined})
 
 add_definitions(-DMATERIALX_RENDER_EXPORTS)
 
diff --git a/source/MaterialXRender/TextureBaker.h b/source/MaterialXRender/TextureBaker.h
new file mode 100644
index 00000000..7f52f7e4
--- /dev/null
+++ b/source/MaterialXRender/TextureBaker.h
@@ -0,0 +1,297 @@
+//
+// Copyright Contributors to the MaterialX Project
+// SPDX-License-Identifier: Apache-2.0
+//
+
+#ifndef MATERIALX_TEXTUREBAKER
+#define MATERIALX_TEXTUREBAKER
+
+/// @file
+/// Texture baking functionality
+
+#include <iostream>
+
+#include <MaterialXCore/Unit.h>
+
+#include <MaterialXRender/Export.h>
+#include <MaterialXFormat/File.h>
+#include <MaterialXRender/ImageHandler.h>
+#include <MaterialXGenShader/GenContext.h>
+
+MATERIALX_NAMESPACE_BEGIN
+
+/// A vector of baked documents with their associated names.
+using BakedDocumentVec = std::vector<std::pair<std::string, DocumentPtr>>;
+
+/// @class TextureBaker
+/// A helper class for baking procedural material content to textures.
+/// TODO: Add support for graphs containing geometric nodes such as position
+///       and normal.
+template<typename Renderer, typename ShaderGen>
+class MX_RENDER_API TextureBaker : public Renderer
+{
+  public:
+    /// Set the file extension for baked textures.
+    void setExtension(const string& extension)
+    {
+        _extension = extension;
+    }
+
+    /// Return the file extension for baked textures.
+    const string& getExtension() const
+    {
+        return _extension;
+    }
+
+    /// Set the color space in which color textures are encoded.
+    ///
+    /// By default, this color space is srgb_texture, and color inputs are
+    /// automatically transformed to this space by the baker.  If another color
+    /// space is set, then the input graph is responsible for transforming
+    /// colors to this space.
+    void setColorSpace(const string& colorSpace)
+    {
+        _colorSpace = colorSpace;
+    }
+
+    /// Return the color space in which color textures are encoded.
+    const string& getColorSpace() const
+    {
+        return _colorSpace;
+    }
+
+    /// Set the distance unit to which textures are baked.  Defaults to meters.
+    void setDistanceUnit(const string& unitSpace)
+    {
+        _distanceUnit = unitSpace;
+    }
+
+    /// Return the distance unit to which textures are baked.
+    const string& getDistanceUnit() const
+    {
+        return _distanceUnit;
+    }
+
+    /// Set whether images should be averaged to generate constants.  Defaults to false.
+    void setAverageImages(bool enable)
+    {
+        _averageImages = enable;
+    }
+
+    /// Return whether images should be averaged to generate constants.
+    bool getAverageImages() const
+    {
+        return _averageImages;
+    }
+
+    /// Set whether uniform textures should be stored as constants.  Defaults to true.
+    void setOptimizeConstants(bool enable)
+    {
+        _optimizeConstants = enable;
+    }
+
+    /// Return whether uniform textures should be stored as constants.
+    bool getOptimizeConstants() const
+    {
+        return _optimizeConstants;
+    }
+
+    /// Set the output location for baked texture images.  Defaults to the root folder
+    /// of the destination material.
+    void setOutputImagePath(const FilePath& outputImagePath)
+    {
+        _outputImagePath = outputImagePath;
+    }
+
+    /// Get the current output location for baked texture images.
+    const FilePath& getOutputImagePath()
+    {
+        return _outputImagePath;
+    }
+
+    /// Set the name of the baked graph element.
+    void setBakedGraphName(const string& name)
+    {
+        _bakedGraphName= name;
+    }
+
+    /// Return the name of the baked graph element.
+    const string& getBakedGraphName() const
+    {
+        return _bakedGraphName;
+    }
+
+    /// Set the name of the baked geometry info element.
+    void setBakedGeomInfoName(const string& name)
+    {
+        _bakedGeomInfoName = name;
+    }
+
+    /// Return the name of the baked geometry info element.
+    const string& getBakedGeomInfoName() const
+    {
+        return _bakedGeomInfoName;
+    }
+
+    /// Get the texture filename template.
+    const string& getTextureFilenameTemplate() const
+    {
+        return _textureFilenameTemplate;
+    }
+
+    /// Set the texture filename template.
+    void setTextureFilenameTemplate(const string& filenameTemplate)
+    {
+        _textureFilenameTemplate = (filenameTemplate.find("$EXTENSION") == string::npos) ?
+            filenameTemplate + ".$EXTENSION" : filenameTemplate;
+    }
+
+    /// Set texFilenameOverrides if template variable exists.
+    void setFilenameTemplateVarOverride(const string& key, const string& value)
+    {
+        if (_permittedOverrides.count(key))
+        {
+            _texTemplateOverrides[key] = value;
+        }
+    }
+
+    /// Set the output stream for reporting progress and warnings.  Defaults to std::cout.
+    void setOutputStream(std::ostream* outputStream)
+    {
+        _outputStream = outputStream;
+    }
+
+    /// Return the output stream for reporting progress and warnings.
+    std::ostream* getOutputStream() const
+    {
+        return _outputStream;
+    }
+
+    /// Set whether to create a short name for baked images by hashing the baked image filenames
+    /// This is useful for file systems which may have a maximum limit on filename size.
+    /// By default names are not hashed.
+    void setHashImageNames(bool enable)
+    {
+        _hashImageNames = enable;
+    }
+
+    /// Return whether automatic baked texture resolution is set.
+    bool getHashImageNames() const
+    {
+        return _hashImageNames;
+    }
+
+    /// Set the minimum texcoords used in texture baking.  Defaults to 0, 0.
+    void setTextureSpaceMin(const Vector2& min)
+    {
+        _textureSpaceMin = min;
+    }
+
+    /// Return the minimum texcoords used in texture baking.
+    Vector2 getTextureSpaceMin() const
+    {
+        return _textureSpaceMin;
+    }
+
+    /// Set the maximum texcoords used in texture baking.  Defaults to 1, 1.
+    void setTextureSpaceMax(const Vector2& max)
+    {
+        _textureSpaceMax = max;
+    }
+
+    /// Return the maximum texcoords used in texture baking.
+    Vector2 getTextureSpaceMax() const
+    {
+        return _textureSpaceMax;
+    }
+
+    /// Set up the unit definitions to be used in baking.
+    void setupUnitSystem(DocumentPtr unitDefinitions);
+
+    /// Bake textures for all graph inputs of the given shader.
+    void bakeShaderInputs(NodePtr material, NodePtr shader, GenContext& context, const string& udim = EMPTY_STRING);
+
+    /// Bake a texture for the given graph output.
+    void bakeGraphOutput(OutputPtr output, GenContext& context, const StringMap& filenameTemplateMap);
+
+    /// Optimize baked textures before writing.
+    void optimizeBakedTextures(NodePtr shader);
+
+    /// Bake material to document in memory and write baked textures to disk.
+    DocumentPtr bakeMaterialToDoc(DocumentPtr doc, const FileSearchPath& searchPath, const string& materialPath, 
+                                  const StringVec& udimSet, std::string& documentName);
+
+    /// Bake materials in the given document and write them to disk.  If multiple documents are written,
+    /// then the given output filename will be used as a template.
+    void bakeAllMaterials(DocumentPtr doc, const FileSearchPath& searchPath, const FilePath& outputFileName);
+    
+    string getValueStringFromColor(const Color4& color, const string& type);
+
+  protected:
+    class BakedImage
+    {
+      public:
+        FilePath filename;
+        Color4 uniformColor;
+        bool isUniform = false;
+    };
+    class BakedConstant
+    {
+      public:
+        Color4 color;
+        bool isDefault = false;
+    };
+    using BakedImageVec = vector<BakedImage>;
+    using BakedImageMap = std::unordered_map<OutputPtr, BakedImageVec>;
+    using BakedConstantMap = std::unordered_map<OutputPtr, BakedConstant>;
+
+  protected:
+    TextureBaker(unsigned int width, unsigned int height, Image::BaseType baseType);
+
+    // Populate file template variable naming map
+    StringMap initializeFileTemplateMap(InputPtr input, NodePtr shader, const string& udim = EMPTY_STRING);
+
+    // Find first occurence of variable in filename from start index onwards
+    size_t findVarInTemplate(const string& filename, const string& var, size_t start = 0);
+
+    // Generate a texture filename for the given graph output.
+    FilePath generateTextureFilename(const StringMap& fileTemplateMap);
+
+    // Create document that links shader outputs to a material.
+    DocumentPtr generateNewDocumentFromShader(NodePtr shader, const StringVec& udimSet);
+
+    // Write a baked image to disk, returning true if the write was successful.
+    bool writeBakedImage(const BakedImage& baked, ImagePtr image);
+
+  protected:
+    string _extension;
+    string _colorSpace;
+    string _distanceUnit;
+    bool _averageImages;
+    bool _optimizeConstants;
+    FilePath _outputImagePath;
+    string _bakedGraphName;
+    string _bakedGeomInfoName;
+    string _textureFilenameTemplate;
+    std::ostream* _outputStream;
+    bool _hashImageNames;
+    Vector2 _textureSpaceMin;
+    Vector2 _textureSpaceMax;
+
+    ShaderGeneratorPtr _generator;
+    ConstNodePtr _material;
+    ImagePtr _frameCaptureImage;
+    BakedImageMap _bakedImageMap;
+    BakedConstantMap _bakedConstantMap;
+    StringSet _permittedOverrides;
+    StringMap _texTemplateOverrides;
+    StringMap _bakedInputMap;
+
+    std::unordered_map<string, NodePtr> _worldSpaceNodes;
+};
+
+MATERIALX_NAMESPACE_END
+
+#include <MaterialXRender/TextureBaker.inl>
+
+#endif
diff --git a/source/MaterialXRender/TextureBaker.inl b/source/MaterialXRender/TextureBaker.inl
new file mode 100644
index 00000000..1cbd9efb
--- /dev/null
+++ b/source/MaterialXRender/TextureBaker.inl
@@ -0,0 +1,638 @@
+//
+// Copyright Contributors to the MaterialX Project
+// SPDX-License-Identifier: Apache-2.0
+//
+
+#include <MaterialXRender/OiioImageLoader.h>
+#include <MaterialXRender/StbImageLoader.h>
+#include <MaterialXRender/Util.h>
+
+#include <MaterialXGenShader/DefaultColorManagementSystem.h>
+
+#include <MaterialXFormat/XmlIo.h>
+
+MATERIALX_NAMESPACE_BEGIN
+
+namespace {
+
+const string SRGB_TEXTURE = "srgb_texture";
+const string LIN_REC709 = "lin_rec709";
+const string BAKED_POSTFIX = "_baked";
+const string SHADER_PREFIX = "SR_";
+const string DEFAULT_UDIM_PREFIX = "_";
+
+} // anonymous namespace
+
+template<typename Renderer, typename ShaderGen>
+string TextureBaker<Renderer, ShaderGen>::getValueStringFromColor(const Color4& color, const string& type)
+{
+    if (type == "color4" || type == "vector4")
+    {
+        return toValueString(color);
+    }
+    if (type == "color3" || type == "vector3")
+    {
+        return toValueString(Vector3(color[0], color[1], color[2]));
+    }
+    if (type == "vector2")
+    {
+        return toValueString(Vector2(color[0], color[1]));
+    }
+    if (type == "float")
+    {
+        return toValueString(color[0]);
+    }
+    return EMPTY_STRING;
+}
+
+template<typename Renderer, typename ShaderGen>
+TextureBaker<Renderer, ShaderGen>::TextureBaker(unsigned int width, unsigned int height, Image::BaseType baseType) :
+    Renderer(width, height, baseType),
+    _distanceUnit("meter"),
+    _averageImages(false),
+    _optimizeConstants(true),
+    _bakedGraphName("NG_baked"),
+    _bakedGeomInfoName("GI_baked"),
+    _textureFilenameTemplate("$MATERIAL_$SHADINGMODEL_$INPUT$UDIMPREFIX$UDIM.$EXTENSION"),
+    _outputStream(&std::cout),
+    _hashImageNames(false),
+    _textureSpaceMin(0.0f),
+    _textureSpaceMax(1.0f),
+    _generator(ShaderGen::create()),
+    _permittedOverrides({ "$ASSET", "$MATERIAL", "$UDIMPREFIX" })
+{
+    if (baseType == Image::BaseType::UINT8)
+    {
+#if MATERIALX_BUILD_OIIO
+        _extension = ImageLoader::TIFF_EXTENSION;
+#else
+        _extension = ImageLoader::PNG_EXTENSION;
+#endif
+        _colorSpace = SRGB_TEXTURE;
+    }
+    else
+    {
+#if MATERIALX_BUILD_OIIO
+        _extension = ImageLoader::EXR_EXTENSION;
+#else
+        _extension = ImageLoader::HDR_EXTENSION;
+#endif
+        _colorSpace = LIN_REC709;
+    }
+
+    // Initialize our base renderer.
+    Renderer::initialize();
+
+    // Initialize our image handler.
+    Renderer::_imageHandler = Renderer::createImageHandler(StbImageLoader::create());
+#if MATERIALX_BUILD_OIIO
+    Renderer::_imageHandler->addLoader(OiioImageLoader::create());
+#endif
+
+    // Create our dedicated frame capture image.
+    _frameCaptureImage = Image::create(width, height, 4, baseType);
+    _frameCaptureImage->createResourceBuffer();
+}
+
+template<typename Renderer, typename ShaderGen>
+size_t TextureBaker<Renderer, ShaderGen>::findVarInTemplate(const string& filename, const string& var, size_t start)
+{
+    size_t i = filename.find(var, start);
+    if (var == "$UDIM" && i != string::npos)
+    {
+        size_t udimPrefix = filename.find("$UDIMPREFIX", start);
+        if (i == udimPrefix)
+        {
+            i = filename.find(var, i + 1);
+        }
+    }
+    return i;
+}
+
+template<typename Renderer, typename ShaderGen>
+FilePath TextureBaker<Renderer, ShaderGen>::generateTextureFilename(const StringMap& filenameTemplateMap)
+{
+    string bakedImageName = _textureFilenameTemplate;
+
+    for (auto& pair : filenameTemplateMap)
+    {
+        string replacement = (_texTemplateOverrides.count(pair.first)) ?
+            _texTemplateOverrides[pair.first] : pair.second;
+        replacement = (filenameTemplateMap.at("$UDIM").empty() && pair.first == "$UDIMPREFIX") ?
+            EMPTY_STRING : replacement;
+
+        for (size_t i = 0; (i = findVarInTemplate(bakedImageName, pair.first, i)) != string::npos; i++)
+        {
+            bakedImageName.replace(i, pair.first.length(), replacement);
+        }
+    }
+
+    if (_hashImageNames)
+    {
+        std::stringstream hashStream;
+        hashStream << std::hash<std::string>{}(bakedImageName);
+        hashStream << "." + getExtension();
+        bakedImageName = hashStream.str();
+    }
+    return _outputImagePath / bakedImageName;
+}
+
+template<typename Renderer, typename ShaderGen>
+StringMap TextureBaker<Renderer, ShaderGen>::initializeFileTemplateMap(InputPtr input, NodePtr shader, const string& udim)
+{
+    FilePath assetPath = FilePath(shader->getActiveSourceUri());
+    assetPath.removeExtension();
+    StringMap filenameTemplateMap;
+    filenameTemplateMap["$ASSET"] = assetPath.getBaseName();
+    filenameTemplateMap["$INPUT"] = _bakedInputMap[input->getName()];
+    filenameTemplateMap["$EXTENSION"] = _extension;
+    filenameTemplateMap["$MATERIAL"] = _material->getName();
+    filenameTemplateMap["$SHADINGMODEL"] = shader->getCategory();
+    filenameTemplateMap["$UDIM"] = udim;
+    filenameTemplateMap["$UDIMPREFIX"] = DEFAULT_UDIM_PREFIX;
+    return filenameTemplateMap;
+}
+
+template<typename Renderer, typename ShaderGen>
+bool TextureBaker<Renderer, ShaderGen>::writeBakedImage(const BakedImage& baked, ImagePtr image)
+{
+    if (!Renderer::_imageHandler->saveImage(baked.filename, image, true))
+    {
+        if (_outputStream)
+        {
+            *_outputStream << "Failed to write baked image: " << baked.filename.asString() << std::endl;
+        }
+        return false;
+    }
+
+    if (_outputStream)
+    {
+        *_outputStream << "Wrote baked image: " << baked.filename.asString() << std::endl;
+    }
+
+    return true;
+}
+
+template<typename Renderer, typename ShaderGen>
+void TextureBaker<Renderer, ShaderGen>::bakeShaderInputs(NodePtr material, NodePtr shader, GenContext& context, const string& udim)
+{
+    _material = material;
+    
+    if (!shader)
+    {
+        return;
+    }
+
+    std::unordered_map<OutputPtr, InputPtr> bakedOutputMap;
+    for (InputPtr input : shader->getInputs())
+    {
+        OutputPtr output = input->getConnectedOutput();
+        if (output && !bakedOutputMap.count(output))
+        {
+            bakedOutputMap[output] = input;
+            _bakedInputMap[input->getName()] = input->getName();
+
+            // When possible, nodes with world-space outputs are applied outside of the baking process.
+            NodePtr worldSpaceNode = connectsToWorldSpaceNode(output);
+            if (worldSpaceNode)
+            {
+                output->setConnectedNode(worldSpaceNode->getConnectedNode("in"));
+                _worldSpaceNodes[input->getName()] = worldSpaceNode;
+            }
+            StringMap filenameTemplateMap = initializeFileTemplateMap(input, shader, udim);
+            bakeGraphOutput(output, context, filenameTemplateMap);
+        }
+        else if (bakedOutputMap.count(output))
+        {
+            // When the input shares the same output as a previously baked input, we use the already baked input.
+            _bakedInputMap[input->getName()] = bakedOutputMap[output]->getName();
+        }
+    }
+
+    // Release all images used to generate this set of shader inputs.
+    Renderer::_imageHandler->clearImageCache();
+}
+
+template<typename Renderer, typename ShaderGen>
+void TextureBaker<Renderer, ShaderGen>::bakeGraphOutput(OutputPtr output, GenContext& context, const StringMap& filenameTemplateMap)
+{
+    if (!output)
+    {
+        return;
+    }
+
+    ShaderPtr shader = _generator->generate("BakingShader", output, context);
+    Renderer::createProgram(shader);
+
+    bool encodeSrgb = _colorSpace == SRGB_TEXTURE &&
+        (output->getType() == "color3" || output->getType() == "color4");
+    Renderer::getFramebuffer()->setEncodeSrgb(encodeSrgb);
+
+    // Render and capture the requested image.
+    Renderer::renderTextureSpace(getTextureSpaceMin(), getTextureSpaceMax());
+    string texturefilepath = generateTextureFilename(filenameTemplateMap);
+    Renderer::captureImage(_frameCaptureImage);
+
+    // Construct a baked image record.
+    BakedImage baked;
+    baked.filename = texturefilepath;
+    if (_averageImages)
+    {
+        baked.uniformColor = _frameCaptureImage->getAverageColor();
+        baked.isUniform = true;
+    }
+    else if (_frameCaptureImage->isUniformColor(&baked.uniformColor))
+    {
+        baked.isUniform = true;
+    }
+    _bakedImageMap[output].push_back(baked);
+
+    // TODO: Write images to memory rather than to disk.
+    // Write non-uniform images to disk.
+    if (!baked.isUniform)
+    {
+        writeBakedImage(baked, _frameCaptureImage);
+    }
+}
+
+template<typename Renderer, typename ShaderGen>
+void TextureBaker<Renderer, ShaderGen>::optimizeBakedTextures(NodePtr shader)
+{
+    if (!shader)
+    {
+        return;
+    }
+
+    // Check for fully uniform outputs.
+    for (auto& pair : _bakedImageMap)
+    {
+        bool outputIsUniform = true;
+        for (BakedImage& baked : pair.second)
+        {
+            if (!baked.isUniform || baked.uniformColor != pair.second[0].uniformColor)
+            {
+                outputIsUniform = false;
+                continue;
+            }
+        }
+        if (outputIsUniform)
+        {
+            BakedConstant bakedConstant;
+            bakedConstant.color = pair.second[0].uniformColor;
+            _bakedConstantMap[pair.first] = bakedConstant;
+        }
+    }
+
+    // Check for uniform outputs at their default values.
+    NodeDefPtr shaderNodeDef = shader->getNodeDef();
+    if (shaderNodeDef)
+    {
+        for (InputPtr shaderInput : shader->getInputs())
+        {
+            OutputPtr output = shaderInput->getConnectedOutput();
+            if (output && _bakedConstantMap.count(output))
+            {
+                InputPtr input = shaderNodeDef->getInput(shaderInput->getName());
+                if (input)
+                {
+                    Color4 uniformColor = _bakedConstantMap[output].color;
+                    string uniformColorString = getValueStringFromColor(uniformColor, input->getType());
+                    string defaultValueString = input->hasValue() ? input->getValue()->getValueString() : EMPTY_STRING;
+                    if (uniformColorString == defaultValueString)
+                    {
+                        _bakedConstantMap[output].isDefault = true;
+                    }
+                }
+            }
+        }
+    }
+
+    // Remove baked images that have been replaced by constant values.
+    for (auto& pair : _bakedConstantMap)
+    {
+        if (pair.second.isDefault || _optimizeConstants || _averageImages)
+        {
+            _bakedImageMap.erase(pair.first);
+        }
+    }
+}
+
+template<typename Renderer, typename ShaderGen>
+DocumentPtr TextureBaker<Renderer, ShaderGen>::generateNewDocumentFromShader(NodePtr shader, const StringVec& udimSet)
+{
+    if (!shader)
+    {
+        return nullptr;
+    }
+
+    // Create document.
+    DocumentPtr bakedTextureDoc = createDocument();
+    if (shader->getDocument()->hasColorSpace())
+    {
+        bakedTextureDoc->setColorSpace(shader->getDocument()->getColorSpace());
+    }
+
+    // Create node graph and geometry info.
+    NodeGraphPtr bakedNodeGraph;
+    if (!_bakedImageMap.empty())
+    {
+        _bakedGraphName = bakedTextureDoc->createValidChildName(_bakedGraphName);
+        bakedNodeGraph = bakedTextureDoc->addNodeGraph(_bakedGraphName);
+        bakedNodeGraph->setColorSpace(_colorSpace);
+    }
+    _bakedGeomInfoName = bakedTextureDoc->createValidChildName(_bakedGeomInfoName);
+    GeomInfoPtr bakedGeom = !udimSet.empty() ? bakedTextureDoc->addGeomInfo(_bakedGeomInfoName) : nullptr;
+    if (bakedGeom)
+    {
+        bakedGeom->setGeomPropValue(UDIM_SET_PROPERTY, udimSet, "stringarray");
+    }
+
+    // Create a shader node.
+    NodePtr bakedShader = bakedTextureDoc->addNode(shader->getCategory(), shader->getName() + BAKED_POSTFIX, shader->getType());
+
+    // Optionally create a material node, connecting it to the new shader node.
+    if (_material)
+    {
+        string materialName = (_texTemplateOverrides.count("$MATERIAL"))? _texTemplateOverrides["$MATERIAL"] : _material->getName();
+        NodePtr bakedMaterial = bakedTextureDoc->addNode(_material->getCategory(), materialName + BAKED_POSTFIX, _material->getType());
+        for (auto sourceMaterialInput : _material->getInputs())
+        {
+            const string& sourceMaterialInputName = sourceMaterialInput->getName();
+            NodePtr upstreamShader = sourceMaterialInput->getConnectedNode();
+            if (upstreamShader && (upstreamShader->getNamePath() == shader->getNamePath()))
+            {
+                InputPtr bakedMaterialInput = bakedMaterial->getInput(sourceMaterialInputName);
+                if (!bakedMaterialInput)
+                {
+                    bakedMaterialInput = bakedMaterial->addInput(sourceMaterialInputName, sourceMaterialInput->getType());
+                }
+                bakedMaterialInput->setNodeName(bakedShader->getName());
+            }
+        }
+    }
+
+    // Create and connect inputs on the new shader node.
+    for (ValueElementPtr valueElem : shader->getChildrenOfType<ValueElement>())
+    {
+        // Get the source input and its connected output.
+        InputPtr sourceInput = valueElem->asA<Input>();
+        if (!sourceInput)
+        {
+            continue;
+        }
+
+        OutputPtr output = sourceInput->getConnectedOutput();
+
+        // Skip uniform outputs at their default values.
+        if (output && _bakedConstantMap.count(output) && _bakedConstantMap[output].isDefault)
+        {
+            continue;
+        }
+
+        // Find or create the baked input.
+        const string& sourceName = sourceInput->getName();
+        const string& sourceType = sourceInput->getType();
+        InputPtr bakedInput = bakedShader->getInput(sourceName);
+        if (!bakedInput)
+        {
+            bakedInput = bakedShader->addInput(sourceName, sourceType);
+        }
+
+        // Assign image or constant data to the baked input.
+        if (output)
+        {
+            // Store a constant value for uniform outputs.
+            if (_optimizeConstants && _bakedConstantMap.count(output))
+            {
+                Color4 uniformColor = _bakedConstantMap[output].color;
+                string uniformColorString = getValueStringFromColor(uniformColor, bakedInput->getType());
+                bakedInput->setValueString(uniformColorString);
+                if (bakedInput->getType() == "color3" || bakedInput->getType() == "color4")
+                {
+                    bakedInput->setColorSpace(_colorSpace);
+                }
+                continue;
+            }
+
+            if (!_bakedImageMap.empty())
+            {
+                // Add the image node.
+                NodePtr bakedImage = bakedNodeGraph->addNode("image", sourceName + BAKED_POSTFIX, sourceType);
+                InputPtr input = bakedImage->addInput("file", "filename");
+                StringMap filenameTemplateMap = initializeFileTemplateMap(bakedInput, shader, udimSet.empty() ? EMPTY_STRING : UDIM_TOKEN);
+                input->setValueString(generateTextureFilename(filenameTemplateMap));
+
+                // Reconstruct any world-space nodes that were excluded from the baking process.
+                auto worldSpacePair = _worldSpaceNodes.find(sourceInput->getName());
+                if (worldSpacePair != _worldSpaceNodes.end())
+                {
+                    NodePtr origWorldSpaceNode = worldSpacePair->second;
+                    if (origWorldSpaceNode)
+                    {
+                        NodePtr newWorldSpaceNode = bakedNodeGraph->addNode(origWorldSpaceNode->getCategory(), sourceName + BAKED_POSTFIX + "_map", sourceType);
+                        newWorldSpaceNode->copyContentFrom(origWorldSpaceNode);
+                        InputPtr mapInput = newWorldSpaceNode->getInput("in");
+                        if (mapInput)
+                        {
+                            mapInput->setNodeName(bakedImage->getName());
+                        }
+                        bakedImage = newWorldSpaceNode;
+                    }
+                }
+
+                // Add the graph output.
+                OutputPtr bakedOutput = bakedNodeGraph->addOutput(sourceName + "_output", sourceType);
+                bakedOutput->setConnectedNode(bakedImage);
+                bakedInput->setConnectedOutput(bakedOutput);
+            }
+        }
+        else
+        {
+            bakedInput->copyContentFrom(sourceInput);
+        }
+    }
+
+    // Generate uniform images and write to disk.
+    ImagePtr uniformImage = createUniformImage(4, 4, 4, Renderer::_baseType, Color4());
+    for (const auto& pair : _bakedImageMap)
+    {
+        for (const BakedImage& baked : pair.second)
+        {
+            if (baked.isUniform)
+            {
+                uniformImage->setUniformColor(baked.uniformColor);
+                writeBakedImage(baked, uniformImage);
+            }
+        }
+    }
+
+    // Clear cached information after each material bake
+    _bakedImageMap.clear();
+    _bakedConstantMap.clear();
+    _worldSpaceNodes.clear();
+    _bakedInputMap.clear();
+    _material = nullptr;
+
+    // Return the baked document on success.
+    return bakedTextureDoc;
+}
+
+template<typename Renderer, typename ShaderGen>
+DocumentPtr TextureBaker<Renderer, ShaderGen>::bakeMaterialToDoc(DocumentPtr doc, const FileSearchPath& searchPath, const string& materialPath,
+                                            const StringVec& udimSet, string& documentName)
+{
+    if (_outputStream)
+    {
+        *_outputStream << "Processing material: " << materialPath << std::endl;
+    }
+
+    // Set up generator context for material
+    GenContext genContext(_generator);
+    genContext.getOptions().targetColorSpaceOverride = LIN_REC709;
+    genContext.getOptions().fileTextureVerticalFlip = true;
+    genContext.getOptions().targetDistanceUnit = _distanceUnit;
+
+    DefaultColorManagementSystemPtr cms = DefaultColorManagementSystem::create(genContext.getShaderGenerator().getTarget());
+    cms->loadLibrary(doc);
+    genContext.registerSourceCodeSearchPath(searchPath);
+    genContext.getShaderGenerator().setColorManagementSystem(cms);
+
+    // Compute the material tag set.
+    StringVec materialTags = udimSet;
+    if (materialTags.empty())
+    {
+        materialTags.push_back(EMPTY_STRING);
+    }
+
+    ElementPtr elem = doc->getDescendant(materialPath);
+    if (!elem || !elem->isA<Node>())
+    {
+        return nullptr;
+    }
+    NodePtr materialNode = elem->asA<Node>();
+
+    vector<NodePtr> shaderNodes = getShaderNodes(materialNode);
+    NodePtr shaderNode = shaderNodes.empty() ? nullptr : shaderNodes[0];
+    if (!shaderNode)
+    {
+        return nullptr;
+    }
+
+    StringResolverPtr resolver = StringResolver::create();
+
+    // Iterate over material tags.
+    for (const string& tag : materialTags)
+    {
+        // Always clear any cached implementations before generation.
+        genContext.clearNodeImplementations();
+
+        ShaderPtr hwShader = createShader("Shader", genContext, shaderNode);
+        if (!hwShader)
+        {
+            continue;
+        }
+        Renderer::_imageHandler->setSearchPath(searchPath);
+        resolver->setUdimString(tag);
+        Renderer::_imageHandler->setFilenameResolver(resolver);
+        bakeShaderInputs(materialNode, shaderNode, genContext, tag);
+
+        // Optimize baked textures.
+        optimizeBakedTextures(shaderNode);
+    }
+
+    // Link the baked material and textures in a MaterialX document.
+    documentName = shaderNode->getName();
+    return generateNewDocumentFromShader(shaderNode, udimSet);
+}
+
+template<typename Renderer, typename ShaderGen>
+void TextureBaker<Renderer, ShaderGen>::bakeAllMaterials(DocumentPtr doc, const FileSearchPath& searchPath, const FilePath& outputFilename)
+{
+    if (_outputImagePath.isEmpty())
+    {
+        _outputImagePath = outputFilename.getParentPath();
+        if (!_outputImagePath.exists())
+        {
+            _outputImagePath.createDirectory();
+        }
+    }
+
+    std::vector<TypedElementPtr> renderableMaterials;
+    findRenderableElements(doc, renderableMaterials);
+
+    // Compute the UDIM set.
+    ValuePtr udimSetValue = doc->getGeomPropValue(UDIM_SET_PROPERTY);
+    StringVec udimSet;
+    if (udimSetValue && udimSetValue->isA<StringVec>())
+    {
+        udimSet = udimSetValue->asA<StringVec>();
+    }
+
+    // Bake all materials in documents to memory.
+    BakedDocumentVec bakedDocuments;
+    for (size_t i = 0; i < renderableMaterials.size(); i++)
+    {
+        if (_outputStream && i > 0)
+        {
+            *_outputStream << std::endl;
+        }
+
+        const TypedElementPtr& element = renderableMaterials[i];
+        string documentName;
+        DocumentPtr bakedMaterialDoc = bakeMaterialToDoc(doc, searchPath, element->getNamePath(), udimSet, documentName);
+        if (bakedMaterialDoc)
+        {
+            bakedDocuments.push_back(make_pair(documentName, bakedMaterialDoc));
+        }
+    }
+
+    // Write documents in memory to disk.
+    size_t bakeCount = bakedDocuments.size();
+    for (size_t i = 0; i < bakeCount; i++)
+    {
+        if (bakedDocuments[i].second)
+        {
+            FilePath writeFilename = outputFilename;
+
+            // Add additional filename decorations if there are multiple documents.
+            if (bakedDocuments.size() > 1)
+            {
+                const string extension = writeFilename.getExtension();
+                writeFilename.removeExtension();
+                string filenameSeparator = writeFilename.isDirectory()? EMPTY_STRING : "_";
+                writeFilename = FilePath(writeFilename.asString() + filenameSeparator + bakedDocuments[i].first + "." + extension);
+            }
+
+            writeToXmlFile(bakedDocuments[i].second, writeFilename);
+            if (_outputStream)
+            {
+                *_outputStream << "Wrote baked document: " << writeFilename.asString() << std::endl;
+            }
+        }
+    }
+}
+
+template<typename Renderer, typename ShaderGen>
+void TextureBaker<Renderer, ShaderGen>::setupUnitSystem(DocumentPtr unitDefinitions)
+{
+    UnitTypeDefPtr distanceTypeDef = unitDefinitions ? unitDefinitions->getUnitTypeDef("distance") : nullptr;
+    UnitTypeDefPtr angleTypeDef = unitDefinitions ? unitDefinitions->getUnitTypeDef("angle") : nullptr;
+    if (!distanceTypeDef && !angleTypeDef)
+    {
+        return;
+    }
+
+    UnitSystemPtr unitSystem = UnitSystem::create(_generator->getTarget());
+    if (!unitSystem)
+    {
+        return;
+    }
+    _generator->setUnitSystem(unitSystem);
+    UnitConverterRegistryPtr registry = UnitConverterRegistry::create();
+    registry->addUnitConverter(distanceTypeDef, LinearUnitConverter::create(distanceTypeDef));
+    registry->addUnitConverter(angleTypeDef, LinearUnitConverter::create(angleTypeDef));
+    _generator->getUnitSystem()->loadLibrary(unitDefinitions);
+    _generator->getUnitSystem()->setUnitConverterRegistry(registry);
+}
+
+MATERIALX_NAMESPACE_END
diff --git a/source/MaterialXRenderGlsl/GlslRenderer.h b/source/MaterialXRenderGlsl/GlslRenderer.h
index 8532440e..4eb77cd0 100644
--- a/source/MaterialXRenderGlsl/GlslRenderer.h
+++ b/source/MaterialXRenderGlsl/GlslRenderer.h
@@ -13,6 +13,7 @@
 
 #include <MaterialXRenderGlsl/GLFramebuffer.h>
 #include <MaterialXRenderGlsl/GlslProgram.h>
+#include <MaterialXRenderGlsl/GLTextureHandler.h>
 
 #include <MaterialXRender/ShaderRenderer.h>
 
@@ -44,6 +45,12 @@ class MX_RENDERGLSL_API GlslRenderer : public ShaderRenderer
     /// Create a GLSL renderer instance
     static GlslRendererPtr create(unsigned int width = 512, unsigned int height = 512, Image::BaseType baseType = Image::BaseType::UINT8);
 
+    /// Create a texture handler for OpenGL textures
+    ImageHandlerPtr createImageHandler(ImageLoaderPtr imageLoader)
+    {
+        return GLTextureHandler::create(imageLoader);
+    }
+    
     /// Destructor
     virtual ~GlslRenderer() { }
 
diff --git a/source/MaterialXRenderGlsl/TextureBaker.cpp b/source/MaterialXRenderGlsl/TextureBaker.cpp
index be28ba82..85bceca8 100644
--- a/source/MaterialXRenderGlsl/TextureBaker.cpp
+++ b/source/MaterialXRenderGlsl/TextureBaker.cpp
@@ -14,614 +14,8 @@
 #include <MaterialXFormat/XmlIo.h>
 
 MATERIALX_NAMESPACE_BEGIN
-
-namespace {
-
-const string SRGB_TEXTURE = "srgb_texture";
-const string LIN_REC709 = "lin_rec709";
-const string BAKED_POSTFIX = "_baked";
-const string SHADER_PREFIX = "SR_";
-const string DEFAULT_UDIM_PREFIX = "_";
-
-string getValueStringFromColor(const Color4& color, const string& type)
-{
-    if (type == "color4" || type == "vector4")
-    {
-        return toValueString(color);
-    }
-    if (type == "color3" || type == "vector3")
-    {
-        return toValueString(Vector3(color[0], color[1], color[2]));
-    }
-    if (type == "vector2")
-    {
-        return toValueString(Vector2(color[0], color[1]));
-    }
-    if (type == "float")
-    {
-        return toValueString(color[0]);
-    }
-    return EMPTY_STRING;
-}
-
-} // anonymous namespace
-
-TextureBaker::TextureBaker(unsigned int width, unsigned int height, Image::BaseType baseType) :
-    GlslRenderer(width, height, baseType),
-    _distanceUnit("meter"),
-    _averageImages(false),
-    _optimizeConstants(true),
-    _bakedGraphName("NG_baked"),
-    _bakedGeomInfoName("GI_baked"),
-    _textureFilenameTemplate("$MATERIAL_$SHADINGMODEL_$INPUT$UDIMPREFIX$UDIM.$EXTENSION"),
-    _outputStream(&std::cout),
-    _hashImageNames(false),
-    _textureSpaceMin(0.0f),
-    _textureSpaceMax(1.0f),
-    _generator(GlslShaderGenerator::create()),
-    _permittedOverrides({ "$ASSET", "$MATERIAL", "$UDIMPREFIX" })
-{
-    if (baseType == Image::BaseType::UINT8)
-    {
-#if MATERIALX_BUILD_OIIO
-        _extension = ImageLoader::TIFF_EXTENSION;
-#else
-        _extension = ImageLoader::PNG_EXTENSION;
-#endif
-        _colorSpace = SRGB_TEXTURE;
-    }
-    else
-    {
-#if MATERIALX_BUILD_OIIO
-        _extension = ImageLoader::EXR_EXTENSION;
-#else
-        _extension = ImageLoader::HDR_EXTENSION;
-#endif
-        _colorSpace = LIN_REC709;
-    }
-
-    // Initialize our base renderer.
-    GlslRenderer::initialize();
-
-    // Initialize our image handler.
-    _imageHandler = GLTextureHandler::create(StbImageLoader::create());
-#if MATERIALX_BUILD_OIIO
-    _imageHandler->addLoader(OiioImageLoader::create());
-#endif
-
-    // Create our dedicated frame capture image.
-    _frameCaptureImage = Image::create(width, height, 4, baseType);
-    _frameCaptureImage->createResourceBuffer();
-}
-
-size_t TextureBaker::findVarInTemplate(const string& filename, const string& var, size_t start)
-{
-    size_t i = filename.find(var, start);
-    if (var == "$UDIM" && i != string::npos)
-    {
-        size_t udimPrefix = filename.find("$UDIMPREFIX", start);
-        if (i == udimPrefix)
-        {
-            i = filename.find(var, i + 1);
-        }
-    }
-    return i;
-}
-
-FilePath TextureBaker::generateTextureFilename(const StringMap& filenameTemplateMap)
-{
-    string bakedImageName = _textureFilenameTemplate;
-
-    for (auto& pair : filenameTemplateMap)
-    {
-        string replacement = (_texTemplateOverrides.count(pair.first)) ?
-            _texTemplateOverrides[pair.first] : pair.second;
-        replacement = (filenameTemplateMap.at("$UDIM").empty() && pair.first == "$UDIMPREFIX") ?
-            EMPTY_STRING : replacement;
-
-        for (size_t i = 0; (i = findVarInTemplate(bakedImageName, pair.first, i)) != string::npos; i++)
-        {
-            bakedImageName.replace(i, pair.first.length(), replacement);
-        }
-    }
-
-    if (_hashImageNames)
-    {
-        std::stringstream hashStream;
-        hashStream << std::hash<std::string>{}(bakedImageName);
-        hashStream << "." + getExtension();
-        bakedImageName = hashStream.str();
-    }
-    return _outputImagePath / bakedImageName;
-}
-
-StringMap TextureBaker::initializeFileTemplateMap(InputPtr input, NodePtr shader, const string& udim)
+TextureBakerGlsl::TextureBakerGlsl(unsigned int width, unsigned int height, Image::BaseType baseType) :
+    TextureBaker<GlslRenderer, GlslShaderGenerator>(width, height, baseType)
 {
-    FilePath assetPath = FilePath(shader->getActiveSourceUri());
-    assetPath.removeExtension();
-    StringMap filenameTemplateMap;
-    filenameTemplateMap["$ASSET"] = assetPath.getBaseName();
-    filenameTemplateMap["$INPUT"] = _bakedInputMap[input->getName()];
-    filenameTemplateMap["$EXTENSION"] = _extension;
-    filenameTemplateMap["$MATERIAL"] = _material->getName();
-    filenameTemplateMap["$SHADINGMODEL"] = shader->getCategory();
-    filenameTemplateMap["$UDIM"] = udim;
-    filenameTemplateMap["$UDIMPREFIX"] = DEFAULT_UDIM_PREFIX;
-    return filenameTemplateMap;
-}
-
-bool TextureBaker::writeBakedImage(const BakedImage& baked, ImagePtr image)
-{
-    if (!_imageHandler->saveImage(baked.filename, image, true))
-    {
-        if (_outputStream)
-        {
-            *_outputStream << "Failed to write baked image: " << baked.filename.asString() << std::endl;
-        }
-        return false;
-    }
-
-    if (_outputStream)
-    {
-        *_outputStream << "Wrote baked image: " << baked.filename.asString() << std::endl;
-    }
-
-    return true;
-}
-
-void TextureBaker::bakeShaderInputs(NodePtr material, NodePtr shader, GenContext& context, const string& udim)
-{
-    _material = material;
-    
-    if (!shader)
-    {
-        return;
-    }
-
-    std::unordered_map<OutputPtr, InputPtr> bakedOutputMap;
-    for (InputPtr input : shader->getInputs())
-    {
-        OutputPtr output = input->getConnectedOutput();
-        if (output && !bakedOutputMap.count(output))
-        {
-            bakedOutputMap[output] = input;
-            _bakedInputMap[input->getName()] = input->getName();
-
-            // When possible, nodes with world-space outputs are applied outside of the baking process.
-            NodePtr worldSpaceNode = connectsToWorldSpaceNode(output);
-            if (worldSpaceNode)
-            {
-                output->setConnectedNode(worldSpaceNode->getConnectedNode("in"));
-                _worldSpaceNodes[input->getName()] = worldSpaceNode;
-            }
-            StringMap filenameTemplateMap = initializeFileTemplateMap(input, shader, udim);
-            bakeGraphOutput(output, context, filenameTemplateMap);
-        }
-        else if (bakedOutputMap.count(output))
-        {
-            // When the input shares the same output as a previously baked input, we use the already baked input.
-            _bakedInputMap[input->getName()] = bakedOutputMap[output]->getName();
-        }
-    }
-
-    // Release all images used to generate this set of shader inputs.
-    _imageHandler->clearImageCache();
-}
-
-void TextureBaker::bakeGraphOutput(OutputPtr output, GenContext& context, const StringMap& filenameTemplateMap)
-{
-    if (!output)
-    {
-        return;
-    }
-
-    ShaderPtr shader = _generator->generate("BakingShader", output, context);
-    createProgram(shader);
-
-    bool encodeSrgb = _colorSpace == SRGB_TEXTURE &&
-        (output->getType() == "color3" || output->getType() == "color4");
-    getFramebuffer()->setEncodeSrgb(encodeSrgb);
-
-    // Render and capture the requested image.
-    renderTextureSpace(getTextureSpaceMin(), getTextureSpaceMax());
-    string texturefilepath = generateTextureFilename(filenameTemplateMap);
-    captureImage(_frameCaptureImage);
-
-    // Construct a baked image record.
-    BakedImage baked;
-    baked.filename = texturefilepath;
-    if (_averageImages)
-    {
-        baked.uniformColor = _frameCaptureImage->getAverageColor();
-        baked.isUniform = true;
-    }
-    else if (_frameCaptureImage->isUniformColor(&baked.uniformColor))
-    {
-        baked.isUniform = true;
-    }
-    _bakedImageMap[output].push_back(baked);
-
-    // TODO: Write images to memory rather than to disk.
-    // Write non-uniform images to disk.
-    if (!baked.isUniform)
-    {
-        writeBakedImage(baked, _frameCaptureImage);
-    }
-}
-
-void TextureBaker::optimizeBakedTextures(NodePtr shader)
-{
-    if (!shader)
-    {
-        return;
-    }
-
-    // Check for fully uniform outputs.
-    for (auto& pair : _bakedImageMap)
-    {
-        bool outputIsUniform = true;
-        for (BakedImage& baked : pair.second)
-        {
-            if (!baked.isUniform || baked.uniformColor != pair.second[0].uniformColor)
-            {
-                outputIsUniform = false;
-                continue;
-            }
-        }
-        if (outputIsUniform)
-        {
-            BakedConstant bakedConstant;
-            bakedConstant.color = pair.second[0].uniformColor;
-            _bakedConstantMap[pair.first] = bakedConstant;
-        }
-    }
-
-    // Check for uniform outputs at their default values.
-    NodeDefPtr shaderNodeDef = shader->getNodeDef();
-    if (shaderNodeDef)
-    {
-        for (InputPtr shaderInput : shader->getInputs())
-        {
-            OutputPtr output = shaderInput->getConnectedOutput();
-            if (output && _bakedConstantMap.count(output))
-            {
-                InputPtr input = shaderNodeDef->getInput(shaderInput->getName());
-                if (input)
-                {
-                    Color4 uniformColor = _bakedConstantMap[output].color;
-                    string uniformColorString = getValueStringFromColor(uniformColor, input->getType());
-                    string defaultValueString = input->hasValue() ? input->getValue()->getValueString() : EMPTY_STRING;
-                    if (uniformColorString == defaultValueString)
-                    {
-                        _bakedConstantMap[output].isDefault = true;
-                    }
-                }
-            }
-        }
-    }
-
-    // Remove baked images that have been replaced by constant values.
-    for (auto& pair : _bakedConstantMap)
-    {
-        if (pair.second.isDefault || _optimizeConstants || _averageImages)
-        {
-            _bakedImageMap.erase(pair.first);
-        }
-    }
 }
-
-DocumentPtr TextureBaker::generateNewDocumentFromShader(NodePtr shader, const StringVec& udimSet)
-{
-    if (!shader)
-    {
-        return nullptr;
-    }
-
-    // Create document.
-    DocumentPtr bakedTextureDoc = createDocument();
-    if (shader->getDocument()->hasColorSpace())
-    {
-        bakedTextureDoc->setColorSpace(shader->getDocument()->getColorSpace());
-    }
-
-    // Create node graph and geometry info.
-    NodeGraphPtr bakedNodeGraph;
-    if (!_bakedImageMap.empty())
-    {
-        _bakedGraphName = bakedTextureDoc->createValidChildName(_bakedGraphName);
-        bakedNodeGraph = bakedTextureDoc->addNodeGraph(_bakedGraphName);
-        bakedNodeGraph->setColorSpace(_colorSpace);
-    }
-    _bakedGeomInfoName = bakedTextureDoc->createValidChildName(_bakedGeomInfoName);
-    GeomInfoPtr bakedGeom = !udimSet.empty() ? bakedTextureDoc->addGeomInfo(_bakedGeomInfoName) : nullptr;
-    if (bakedGeom)
-    {
-        bakedGeom->setGeomPropValue(UDIM_SET_PROPERTY, udimSet, "stringarray");
-    }
-
-    // Create a shader node.
-    NodePtr bakedShader = bakedTextureDoc->addNode(shader->getCategory(), shader->getName() + BAKED_POSTFIX, shader->getType());
-
-    // Optionally create a material node, connecting it to the new shader node.
-    if (_material)
-    {
-        string materialName = (_texTemplateOverrides.count("$MATERIAL"))? _texTemplateOverrides["$MATERIAL"] : _material->getName();
-        NodePtr bakedMaterial = bakedTextureDoc->addNode(_material->getCategory(), materialName + BAKED_POSTFIX, _material->getType());
-        for (auto sourceMaterialInput : _material->getInputs())
-        {
-            const string& sourceMaterialInputName = sourceMaterialInput->getName();
-            NodePtr upstreamShader = sourceMaterialInput->getConnectedNode();
-            if (upstreamShader && (upstreamShader->getNamePath() == shader->getNamePath()))
-            {
-                InputPtr bakedMaterialInput = bakedMaterial->getInput(sourceMaterialInputName);
-                if (!bakedMaterialInput)
-                {
-                    bakedMaterialInput = bakedMaterial->addInput(sourceMaterialInputName, sourceMaterialInput->getType());
-                }
-                bakedMaterialInput->setNodeName(bakedShader->getName());
-            }
-        }
-    }
-
-    // Create and connect inputs on the new shader node.
-    for (ValueElementPtr valueElem : shader->getChildrenOfType<ValueElement>())
-    {
-        // Get the source input and its connected output.
-        InputPtr sourceInput = valueElem->asA<Input>();
-        if (!sourceInput)
-        {
-            continue;
-        }
-
-        OutputPtr output = sourceInput->getConnectedOutput();
-
-        // Skip uniform outputs at their default values.
-        if (output && _bakedConstantMap.count(output) && _bakedConstantMap[output].isDefault)
-        {
-            continue;
-        }
-
-        // Find or create the baked input.
-        const string& sourceName = sourceInput->getName();
-        const string& sourceType = sourceInput->getType();
-        InputPtr bakedInput = bakedShader->getInput(sourceName);
-        if (!bakedInput)
-        {
-            bakedInput = bakedShader->addInput(sourceName, sourceType);
-        }
-
-        // Assign image or constant data to the baked input.
-        if (output)
-        {
-            // Store a constant value for uniform outputs.
-            if (_optimizeConstants && _bakedConstantMap.count(output))
-            {
-                Color4 uniformColor = _bakedConstantMap[output].color;
-                string uniformColorString = getValueStringFromColor(uniformColor, bakedInput->getType());
-                bakedInput->setValueString(uniformColorString);
-                if (bakedInput->getType() == "color3" || bakedInput->getType() == "color4")
-                {
-                    bakedInput->setColorSpace(_colorSpace);
-                }
-                continue;
-            }
-
-            if (!_bakedImageMap.empty())
-            {
-                // Add the image node.
-                NodePtr bakedImage = bakedNodeGraph->addNode("image", sourceName + BAKED_POSTFIX, sourceType);
-                InputPtr input = bakedImage->addInput("file", "filename");
-                StringMap filenameTemplateMap = initializeFileTemplateMap(bakedInput, shader, udimSet.empty() ? EMPTY_STRING : UDIM_TOKEN);
-                input->setValueString(generateTextureFilename(filenameTemplateMap));
-
-                // Reconstruct any world-space nodes that were excluded from the baking process.
-                auto worldSpacePair = _worldSpaceNodes.find(sourceInput->getName());
-                if (worldSpacePair != _worldSpaceNodes.end())
-                {
-                    NodePtr origWorldSpaceNode = worldSpacePair->second;
-                    if (origWorldSpaceNode)
-                    {
-                        NodePtr newWorldSpaceNode = bakedNodeGraph->addNode(origWorldSpaceNode->getCategory(), sourceName + BAKED_POSTFIX + "_map", sourceType);
-                        newWorldSpaceNode->copyContentFrom(origWorldSpaceNode);
-                        InputPtr mapInput = newWorldSpaceNode->getInput("in");
-                        if (mapInput)
-                        {
-                            mapInput->setNodeName(bakedImage->getName());
-                        }
-                        bakedImage = newWorldSpaceNode;
-                    }
-                }
-
-                // Add the graph output.
-                OutputPtr bakedOutput = bakedNodeGraph->addOutput(sourceName + "_output", sourceType);
-                bakedOutput->setConnectedNode(bakedImage);
-                bakedInput->setConnectedOutput(bakedOutput);
-            }
-        }
-        else
-        {
-            bakedInput->copyContentFrom(sourceInput);
-        }
-    }
-
-    // Generate uniform images and write to disk.
-    ImagePtr uniformImage = createUniformImage(4, 4, 4, _baseType, Color4());
-    for (const auto& pair : _bakedImageMap)
-    {
-        for (const BakedImage& baked : pair.second)
-        {
-            if (baked.isUniform)
-            {
-                uniformImage->setUniformColor(baked.uniformColor);
-                writeBakedImage(baked, uniformImage);
-            }
-        }
-    }
-
-    // Clear cached information after each material bake
-    _bakedImageMap.clear();
-    _bakedConstantMap.clear();
-    _worldSpaceNodes.clear();
-    _bakedInputMap.clear();
-    _material = nullptr;
-
-    // Return the baked document on success.
-    return bakedTextureDoc;
-}
-
-DocumentPtr TextureBaker::bakeMaterialToDoc(DocumentPtr doc, const FileSearchPath& searchPath, const string& materialPath, 
-                                            const StringVec& udimSet, string& documentName)
-{
-    if (_outputStream)
-    {
-        *_outputStream << "Processing material: " << materialPath << std::endl;
-    }
-
-    // Set up generator context for material
-    GenContext genContext(_generator);
-    genContext.getOptions().targetColorSpaceOverride = LIN_REC709;
-    genContext.getOptions().fileTextureVerticalFlip = true;
-    genContext.getOptions().targetDistanceUnit = _distanceUnit;
-
-    DefaultColorManagementSystemPtr cms = DefaultColorManagementSystem::create(genContext.getShaderGenerator().getTarget());
-    cms->loadLibrary(doc);
-    genContext.registerSourceCodeSearchPath(searchPath);
-    genContext.getShaderGenerator().setColorManagementSystem(cms);
-
-    // Compute the material tag set.
-    StringVec materialTags = udimSet;
-    if (materialTags.empty())
-    {
-        materialTags.push_back(EMPTY_STRING);
-    }
-
-    ElementPtr elem = doc->getDescendant(materialPath);
-    if (!elem || !elem->isA<Node>())
-    {
-        return nullptr;
-    }
-    NodePtr materialNode = elem->asA<Node>();
-
-    vector<NodePtr> shaderNodes = getShaderNodes(materialNode);
-    NodePtr shaderNode = shaderNodes.empty() ? nullptr : shaderNodes[0];
-    if (!shaderNode)
-    {
-        return nullptr;
-    }
-
-    StringResolverPtr resolver = StringResolver::create();
-
-    // Iterate over material tags.
-    for (const string& tag : materialTags)
-    {
-        // Always clear any cached implementations before generation.
-        genContext.clearNodeImplementations();
-
-        ShaderPtr hwShader = createShader("Shader", genContext, shaderNode);
-        if (!hwShader)
-        {
-            continue;
-        }
-        _imageHandler->setSearchPath(searchPath);
-        resolver->setUdimString(tag);
-        _imageHandler->setFilenameResolver(resolver);
-        bakeShaderInputs(materialNode, shaderNode, genContext, tag);
-
-        // Optimize baked textures.
-        optimizeBakedTextures(shaderNode);
-    }
-
-    // Link the baked material and textures in a MaterialX document.
-    documentName = shaderNode->getName();
-    return generateNewDocumentFromShader(shaderNode, udimSet);
-}
-
-void TextureBaker::bakeAllMaterials(DocumentPtr doc, const FileSearchPath& searchPath, const FilePath& outputFilename)
-{
-    if (_outputImagePath.isEmpty())
-    {
-        _outputImagePath = outputFilename.getParentPath();
-        if (!_outputImagePath.exists())
-        {
-            _outputImagePath.createDirectory();
-        }
-    }
-
-    std::vector<TypedElementPtr> renderableMaterials;
-    findRenderableElements(doc, renderableMaterials);
-
-    // Compute the UDIM set.
-    ValuePtr udimSetValue = doc->getGeomPropValue(UDIM_SET_PROPERTY);
-    StringVec udimSet;
-    if (udimSetValue && udimSetValue->isA<StringVec>())
-    {
-        udimSet = udimSetValue->asA<StringVec>();
-    }
-
-    // Bake all materials in documents to memory.
-    BakedDocumentVec bakedDocuments;
-    for (size_t i = 0; i < renderableMaterials.size(); i++)
-    {
-        if (_outputStream && i > 0)
-        {
-            *_outputStream << std::endl;
-        }
-
-        const TypedElementPtr& element = renderableMaterials[i];
-        string documentName;
-        DocumentPtr bakedMaterialDoc = bakeMaterialToDoc(doc, searchPath, element->getNamePath(), udimSet, documentName);
-        if (bakedMaterialDoc)
-        {
-            bakedDocuments.push_back(make_pair(documentName, bakedMaterialDoc));
-        }
-    }
-
-    // Write documents in memory to disk.
-    size_t bakeCount = bakedDocuments.size();
-    for (size_t i = 0; i < bakeCount; i++)
-    {
-        if (bakedDocuments[i].second)
-        {
-            FilePath writeFilename = outputFilename;
-
-            // Add additional filename decorations if there are multiple documents.
-            if (bakedDocuments.size() > 1)
-            {
-                const string extension = writeFilename.getExtension();
-                writeFilename.removeExtension();
-                string filenameSeparator = writeFilename.isDirectory()? EMPTY_STRING : "_";
-                writeFilename = FilePath(writeFilename.asString() + filenameSeparator + bakedDocuments[i].first + "." + extension);
-            }
-
-            writeToXmlFile(bakedDocuments[i].second, writeFilename);
-            if (_outputStream)
-            {
-                *_outputStream << "Wrote baked document: " << writeFilename.asString() << std::endl;
-            }
-        }
-    }
-}
-
-void TextureBaker::setupUnitSystem(DocumentPtr unitDefinitions)
-{
-    UnitTypeDefPtr distanceTypeDef = unitDefinitions ? unitDefinitions->getUnitTypeDef("distance") : nullptr;
-    UnitTypeDefPtr angleTypeDef = unitDefinitions ? unitDefinitions->getUnitTypeDef("angle") : nullptr;
-    if (!distanceTypeDef && !angleTypeDef)
-    {
-        return;
-    }
-
-    UnitSystemPtr unitSystem = UnitSystem::create(_generator->getTarget());
-    if (!unitSystem)
-    {
-        return;
-    }
-    _generator->setUnitSystem(unitSystem);
-    UnitConverterRegistryPtr registry = UnitConverterRegistry::create();
-    registry->addUnitConverter(distanceTypeDef, LinearUnitConverter::create(distanceTypeDef));
-    registry->addUnitConverter(angleTypeDef, LinearUnitConverter::create(angleTypeDef));
-    _generator->getUnitSystem()->loadLibrary(unitDefinitions);
-    _generator->getUnitSystem()->setUnitConverterRegistry(registry);
-}
-
 MATERIALX_NAMESPACE_END
diff --git a/source/MaterialXRenderGlsl/TextureBaker.h b/source/MaterialXRenderGlsl/TextureBaker.h
index fede01b1..b92c5689 100644
--- a/source/MaterialXRenderGlsl/TextureBaker.h
+++ b/source/MaterialXRenderGlsl/TextureBaker.h
@@ -3,8 +3,8 @@
 // SPDX-License-Identifier: Apache-2.0
 //
 
-#ifndef MATERIALX_TEXTUREBAKER
-#define MATERIALX_TEXTUREBAKER
+#ifndef MATERIALX_TEXTUREBAKER_GLSL
+#define MATERIALX_TEXTUREBAKER_GLSL
 
 /// @file
 /// Texture baking functionality
@@ -12,18 +12,18 @@
 #include <iostream>
 
 #include <MaterialXCore/Unit.h>
+#include <MaterialXRender/TextureBaker.h>
 
 #include <MaterialXRenderGlsl/Export.h>
 
 #include <MaterialXRenderGlsl/GlslRenderer.h>
 #include <MaterialXRenderGlsl/GLTextureHandler.h>
-
 #include <MaterialXGenGlsl/GlslShaderGenerator.h>
 
 MATERIALX_NAMESPACE_BEGIN
 
 /// A shared pointer to a TextureBaker
-using TextureBakerPtr = shared_ptr<class TextureBaker>;
+using TextureBakerPtr = shared_ptr<class TextureBakerGlsl>;
 
 /// A vector of baked documents with their associated names.
 using BakedDocumentVec = std::vector<std::pair<std::string, DocumentPtr>>;
@@ -32,269 +32,15 @@ using BakedDocumentVec = std::vector<std::pair<std::string, DocumentPtr>>;
 /// A helper class for baking procedural material content to textures.
 /// TODO: Add support for graphs containing geometric nodes such as position
 ///       and normal.
-class MX_RENDERGLSL_API TextureBaker : public GlslRenderer
+class MX_RENDERGLSL_API TextureBakerGlsl : public TextureBaker<GlslRenderer, GlslShaderGenerator>
 {
-  public:
+public:
     static TextureBakerPtr create(unsigned int width = 1024, unsigned int height = 1024, Image::BaseType baseType = Image::BaseType::UINT8)
     {
-        return TextureBakerPtr(new TextureBaker(width, height, baseType));
-    }
-
-    /// Set the file extension for baked textures.
-    void setExtension(const string& extension)
-    {
-        _extension = extension;
-    }
-
-    /// Return the file extension for baked textures.
-    const string& getExtension() const
-    {
-        return _extension;
-    }
-
-    /// Set the color space in which color textures are encoded.
-    ///
-    /// By default, this color space is srgb_texture, and color inputs are
-    /// automatically transformed to this space by the baker.  If another color
-    /// space is set, then the input graph is responsible for transforming
-    /// colors to this space.
-    void setColorSpace(const string& colorSpace)
-    {
-        _colorSpace = colorSpace;
-    }
-
-    /// Return the color space in which color textures are encoded.
-    const string& getColorSpace() const
-    {
-        return _colorSpace;
-    }
-
-    /// Set the distance unit to which textures are baked.  Defaults to meters.
-    void setDistanceUnit(const string& unitSpace)
-    {
-        _distanceUnit = unitSpace;
-    }
-
-    /// Return the distance unit to which textures are baked.
-    const string& getDistanceUnit() const
-    {
-        return _distanceUnit;
-    }
-
-    /// Set whether images should be averaged to generate constants.  Defaults to false.
-    void setAverageImages(bool enable)
-    {
-        _averageImages = enable;
-    }
-
-    /// Return whether images should be averaged to generate constants.
-    bool getAverageImages() const
-    {
-        return _averageImages;
-    }
-
-    /// Set whether uniform textures should be stored as constants.  Defaults to true.
-    void setOptimizeConstants(bool enable)
-    {
-        _optimizeConstants = enable;
-    }
-
-    /// Return whether uniform textures should be stored as constants.
-    bool getOptimizeConstants() const
-    {
-        return _optimizeConstants;
-    }
-
-    /// Set the output location for baked texture images.  Defaults to the root folder
-    /// of the destination material.
-    void setOutputImagePath(const FilePath& outputImagePath)
-    {
-        _outputImagePath = outputImagePath;
-    }
-
-    /// Get the current output location for baked texture images.
-    const FilePath& getOutputImagePath()
-    {
-        return _outputImagePath;
-    }
-
-    /// Set the name of the baked graph element.
-    void setBakedGraphName(const string& name)
-    {
-        _bakedGraphName= name;
-    }
-
-    /// Return the name of the baked graph element.
-    const string& getBakedGraphName() const
-    {
-        return _bakedGraphName;
-    }
-
-    /// Set the name of the baked geometry info element.
-    void setBakedGeomInfoName(const string& name)
-    {
-        _bakedGeomInfoName = name;
-    }
-
-    /// Return the name of the baked geometry info element.
-    const string& getBakedGeomInfoName() const
-    {
-        return _bakedGeomInfoName;
-    }
-
-    /// Get the texture filename template.
-    const string& getTextureFilenameTemplate() const
-    {
-        return _textureFilenameTemplate;
-    }
-
-    /// Set the texture filename template.
-    void setTextureFilenameTemplate(const string& filenameTemplate)
-    {
-        _textureFilenameTemplate = (filenameTemplate.find("$EXTENSION") == string::npos) ?
-            filenameTemplate + ".$EXTENSION" : filenameTemplate;
-    }
-
-    /// Set texFilenameOverrides if template variable exists.
-    void setFilenameTemplateVarOverride(const string& key, const string& value)
-    {
-        if (_permittedOverrides.count(key))
-        {
-            _texTemplateOverrides[key] = value;
-        }
-    }
-
-    /// Set the output stream for reporting progress and warnings.  Defaults to std::cout.
-    void setOutputStream(std::ostream* outputStream)
-    {
-        _outputStream = outputStream;
-    }
-
-    /// Return the output stream for reporting progress and warnings.
-    std::ostream* getOutputStream() const
-    {
-        return _outputStream;
-    }
-
-    /// Set whether to create a short name for baked images by hashing the baked image filenames
-    /// This is useful for file systems which may have a maximum limit on filename size.
-    /// By default names are not hashed.
-    void setHashImageNames(bool enable)
-    {
-        _hashImageNames = enable;
-    }
-
-    /// Return whether automatic baked texture resolution is set.
-    bool getHashImageNames() const
-    {
-        return _hashImageNames;
-    }
-
-    /// Set the minimum texcoords used in texture baking.  Defaults to 0, 0.
-    void setTextureSpaceMin(const Vector2& min)
-    {
-        _textureSpaceMin = min;
-    }
-
-    /// Return the minimum texcoords used in texture baking.
-    Vector2 getTextureSpaceMin() const
-    {
-        return _textureSpaceMin;
-    }
-
-    /// Set the maximum texcoords used in texture baking.  Defaults to 1, 1.
-    void setTextureSpaceMax(const Vector2& max)
-    {
-        _textureSpaceMax = max;
-    }
-
-    /// Return the maximum texcoords used in texture baking.
-    Vector2 getTextureSpaceMax() const
-    {
-        return _textureSpaceMax;
+        return TextureBakerPtr(new TextureBakerGlsl(width, height, baseType));
     }
-
-    /// Set up the unit definitions to be used in baking.
-    void setupUnitSystem(DocumentPtr unitDefinitions);
-
-    /// Bake textures for all graph inputs of the given shader.
-    void bakeShaderInputs(NodePtr material, NodePtr shader, GenContext& context, const string& udim = EMPTY_STRING);
-
-    /// Bake a texture for the given graph output.
-    void bakeGraphOutput(OutputPtr output, GenContext& context, const StringMap& filenameTemplateMap);
-
-    /// Optimize baked textures before writing.
-    void optimizeBakedTextures(NodePtr shader);
-
-    /// Bake material to document in memory and write baked textures to disk.
-    DocumentPtr bakeMaterialToDoc(DocumentPtr doc, const FileSearchPath& searchPath, const string& materialPath, 
-                                  const StringVec& udimSet, std::string& documentName);
-
-    /// Bake materials in the given document and write them to disk.  If multiple documents are written,
-    /// then the given output filename will be used as a template.
-    void bakeAllMaterials(DocumentPtr doc, const FileSearchPath& searchPath, const FilePath& outputFileName);
-
-  protected:
-    class BakedImage
-    {
-      public:
-        FilePath filename;
-        Color4 uniformColor;
-        bool isUniform = false;
-    };
-    class BakedConstant
-    {
-      public:
-        Color4 color;
-        bool isDefault = false;
-    };
-    using BakedImageVec = vector<BakedImage>;
-    using BakedImageMap = std::unordered_map<OutputPtr, BakedImageVec>;
-    using BakedConstantMap = std::unordered_map<OutputPtr, BakedConstant>;
-
-  protected:
-    TextureBaker(unsigned int width, unsigned int height, Image::BaseType baseType);
-
-    // Populate file template variable naming map
-    StringMap initializeFileTemplateMap(InputPtr input, NodePtr shader, const string& udim = EMPTY_STRING);
-
-    // Find first occurence of variable in filename from start index onwards
-    size_t findVarInTemplate(const string& filename, const string& var, size_t start = 0);
-
-    // Generate a texture filename for the given graph output.
-    FilePath generateTextureFilename(const StringMap& fileTemplateMap);
-
-    // Create document that links shader outputs to a material.
-    DocumentPtr generateNewDocumentFromShader(NodePtr shader, const StringVec& udimSet);
-
-    // Write a baked image to disk, returning true if the write was successful.
-    bool writeBakedImage(const BakedImage& baked, ImagePtr image);
-
-  protected:
-    string _extension;
-    string _colorSpace;
-    string _distanceUnit;
-    bool _averageImages;
-    bool _optimizeConstants;
-    FilePath _outputImagePath;
-    string _bakedGraphName;
-    string _bakedGeomInfoName;
-    string _textureFilenameTemplate;
-    std::ostream* _outputStream;
-    bool _hashImageNames;
-    Vector2 _textureSpaceMin;
-    Vector2 _textureSpaceMax;
-
-    ShaderGeneratorPtr _generator;
-    ConstNodePtr _material;
-    ImagePtr _frameCaptureImage;
-    BakedImageMap _bakedImageMap;
-    BakedConstantMap _bakedConstantMap;
-    StringSet _permittedOverrides;
-    StringMap _texTemplateOverrides;
-    StringMap _bakedInputMap;
-
-    std::unordered_map<string, NodePtr> _worldSpaceNodes;
+    
+    TextureBakerGlsl(unsigned int width, unsigned int height, Image::BaseType baseType);
 };
 
 MATERIALX_NAMESPACE_END
diff --git a/source/MaterialXRenderMsl/MslRenderer.h b/source/MaterialXRenderMsl/MslRenderer.h
index d3c8aabe..93b2beb2 100644
--- a/source/MaterialXRenderMsl/MslRenderer.h
+++ b/source/MaterialXRenderMsl/MslRenderer.h
@@ -13,6 +13,7 @@
 
 #include <MaterialXRenderMsl/MetalFramebuffer.h>
 #include <MaterialXRenderMsl/MSLPipelineStateObject.h>
+#include <MaterialXRenderMsl/MetalTextureHandler.h>
 
 #include <MaterialXRender/ShaderRenderer.h>
 
@@ -45,6 +46,13 @@ class MX_RENDERMSL_API MslRenderer : public ShaderRenderer
     /// Create a MSL renderer instance
     static MslRendererPtr create(unsigned int width = 512, unsigned int height = 512, Image::BaseType baseType = Image::BaseType::UINT8);
     
+    /// Create a texture handler for Metal textures
+    ImageHandlerPtr createImageHandler(ImageLoaderPtr imageLoader)
+    {
+        return MetalTextureHandler::create(_device, imageLoader);
+    }
+    
+    /// Returns Metal Device used for rendering
     id<MTLDevice> getMetalDevice() const;
 
     /// Destructor
diff --git a/source/MaterialXRenderMsl/TextureBaker.h b/source/MaterialXRenderMsl/TextureBaker.h
index 5626812b..e4f4f1e0 100644
--- a/source/MaterialXRenderMsl/TextureBaker.h
+++ b/source/MaterialXRenderMsl/TextureBaker.h
@@ -13,6 +13,8 @@
 
 #include <MaterialXCore/Unit.h>
 
+#include <MaterialXRender/TextureBaker.h>
+
 #include <MaterialXRenderMsl/Export.h>
 
 #include <MaterialXRenderMsl/MslRenderer.h>
@@ -23,7 +25,7 @@
 MATERIALX_NAMESPACE_BEGIN
 
 /// A shared pointer to a TextureBakerMsl
-using TextureBakerMslPtr = shared_ptr<class TextureBakerMsl>;
+using TextureBakerPtr = shared_ptr<class TextureBakerMsl>;
 
 /// A vector of baked documents with their associated names.
 using BakedDocumentVec = std::vector<std::pair<std::string, DocumentPtr>>;
@@ -32,271 +34,16 @@ using BakedDocumentVec = std::vector<std::pair<std::string, DocumentPtr>>;
 /// A helper class for baking procedural material content to textures.
 /// TODO: Add support for graphs containing geometric nodes such as position
 ///       and normal.
-class MX_RENDERMSL_API TextureBakerMsl : public MslRenderer
+class MX_RENDERMSL_API TextureBakerMsl : public TextureBaker<MslRenderer, MslShaderGenerator>
 {
   public:
-    static TextureBakerMslPtr create(id<MTLDevice> device, unsigned int width = 1024, unsigned int height = 1024, Image::BaseType baseType = Image::BaseType::UINT8)
-    {
-        return TextureBakerMslPtr(new TextureBakerMsl(device, width, height, baseType));
-    }
-
-    /// Set the file extension for baked textures.
-    void setExtension(const string& extension)
-    {
-        _extension = extension;
-    }
-
-    /// Return the file extension for baked textures.
-    const string& getExtension() const
-    {
-        return _extension;
-    }
-
-    /// Set the color space in which color textures are encoded.
-    ///
-    /// By default, this color space is srgb_texture, and color inputs are
-    /// automatically transformed to this space by the baker.  If another color
-    /// space is set, then the input graph is responsible for transforming
-    /// colors to this space.
-    void setColorSpace(const string& colorSpace)
-    {
-        _colorSpace = colorSpace;
-    }
-
-    /// Return the color space in which color textures are encoded.
-    const string& getColorSpace() const
+    static TextureBakerPtr create(unsigned int width = 1024, unsigned int height = 1024, Image::BaseType baseType = Image::BaseType::UINT8)
     {
-        return _colorSpace;
+        return TextureBakerPtr(new TextureBakerMsl(width, height, baseType));
     }
 
-    /// Set the distance unit to which textures are baked.  Defaults to meters.
-    void setDistanceUnit(const string& unitSpace)
-    {
-        _distanceUnit = unitSpace;
-    }
-
-    /// Return the distance unit to which textures are baked.
-    const string& getDistanceUnit() const
-    {
-        return _distanceUnit;
-    }
-
-    /// Set whether images should be averaged to generate constants.  Defaults to false.
-    void setAverageImages(bool enable)
-    {
-        _averageImages = enable;
-    }
-
-    /// Return whether images should be averaged to generate constants.
-    bool getAverageImages() const
-    {
-        return _averageImages;
-    }
-
-    /// Set whether uniform textures should be stored as constants.  Defaults to true.
-    void setOptimizeConstants(bool enable)
-    {
-        _optimizeConstants = enable;
-    }
-
-    /// Return whether uniform textures should be stored as constants.
-    bool getOptimizeConstants() const
-    {
-        return _optimizeConstants;
-    }
-
-    /// Set the output location for baked texture images.  Defaults to the root folder
-    /// of the destination material.
-    void setOutputImagePath(const FilePath& outputImagePath)
-    {
-        _outputImagePath = outputImagePath;
-    }
-
-    /// Get the current output location for baked texture images.
-    const FilePath& getOutputImagePath()
-    {
-        return _outputImagePath;
-    }
-
-    /// Set the name of the baked graph element.
-    void setBakedGraphName(const string& name)
-    {
-        _bakedGraphName= name;
-    }
-
-    /// Return the name of the baked graph element.
-    const string& getBakedGraphName() const
-    {
-        return _bakedGraphName;
-    }
-
-    /// Set the name of the baked geometry info element.
-    void setBakedGeomInfoName(const string& name)
-    {
-        _bakedGeomInfoName = name;
-    }
-
-    /// Return the name of the baked geometry info element.
-    const string& getBakedGeomInfoName() const
-    {
-        return _bakedGeomInfoName;
-    }
-
-    /// Get the texture filename template.
-    const string& getTextureFilenameTemplate() const
-    {
-        return _textureFilenameTemplate;
-    }
-
-    /// Set the texture filename template.
-    void setTextureFilenameTemplate(const string& filenameTemplate)
-    {
-        _textureFilenameTemplate = (filenameTemplate.find("$EXTENSION") == string::npos) ?
-            filenameTemplate + ".$EXTENSION" : filenameTemplate;
-    }
-
-    /// Set texFilenameOverrides if template variable exists.
-    void setFilenameTemplateVarOverride(const string& key, const string& value)
-    {
-        if (_permittedOverrides.count(key))
-        {
-            _texTemplateOverrides[key] = value;
-        }
-    }
-
-    /// Set the output stream for reporting progress and warnings.  Defaults to std::cout.
-    void setOutputStream(std::ostream* outputStream)
-    {
-        _outputStream = outputStream;
-    }
-
-    /// Return the output stream for reporting progress and warnings.
-    std::ostream* getOutputStream() const
-    {
-        return _outputStream;
-    }
-
-    /// Set whether to create a short name for baked images by hashing the baked image filenames
-    /// This is useful for file systems which may have a maximum limit on filename size.
-    /// By default names are not hashed.
-    void setHashImageNames(bool enable)
-    {
-        _hashImageNames = enable;
-    }
-
-    /// Return whether automatic baked texture resolution is set.
-    bool getHashImageNames() const
-    {
-        return _hashImageNames;
-    }
-
-    /// Set the minimum texcoords used in texture baking.  Defaults to 0, 0.
-    void setTextureSpaceMin(const Vector2& min)
-    {
-        _textureSpaceMin = min;
-    }
-
-    /// Return the minimum texcoords used in texture baking.
-    Vector2 getTextureSpaceMin() const
-    {
-        return _textureSpaceMin;
-    }
-
-    /// Set the maximum texcoords used in texture baking.  Defaults to 1, 1.
-    void setTextureSpaceMax(const Vector2& max)
-    {
-        _textureSpaceMax = max;
-    }
-
-    /// Return the maximum texcoords used in texture baking.
-    Vector2 getTextureSpaceMax() const
-    {
-        return _textureSpaceMax;
-    }
-
-    /// Set up the unit definitions to be used in baking.
-    void setupUnitSystem(DocumentPtr unitDefinitions);
-
-    /// Bake textures for all graph inputs of the given shader.
-    void bakeShaderInputs(NodePtr material, NodePtr shader, GenContext& context, const string& udim = EMPTY_STRING);
-
-    /// Bake a texture for the given graph output.
-    void bakeGraphOutput(OutputPtr output, GenContext& context, const StringMap& filenameTemplateMap);
-
-    /// Optimize baked textures before writing.
-    void optimizeBakedTextures(NodePtr shader);
-
-    /// Bake material to document in memory and write baked textures to disk.
-    DocumentPtr bakeMaterialToDoc(DocumentPtr doc, const FileSearchPath& searchPath, const string& materialPath, 
-                                  const StringVec& udimSet, std::string& documentName);
-
-    /// Bake materials in the given document and write them to disk.  If multiple documents are written,
-    /// then the given output filename will be used as a template.
-    void bakeAllMaterials(DocumentPtr doc, const FileSearchPath& searchPath, const FilePath& outputFileName);
-
   protected:
-    class BakedImage
-    {
-      public:
-        FilePath filename;
-        Color4 uniformColor;
-        bool isUniform = false;
-    };
-    class BakedConstant
-    {
-      public:
-        Color4 color;
-        bool isDefault = false;
-    };
-    using BakedImageVec = vector<BakedImage>;
-    using BakedImageMap = std::unordered_map<OutputPtr, BakedImageVec>;
-    using BakedConstantMap = std::unordered_map<OutputPtr, BakedConstant>;
-
-  protected:
-    TextureBakerMsl(id<MTLDevice> device, unsigned int width, unsigned int height, Image::BaseType baseType);
-
-    // Populate file template variable naming map
-    StringMap initializeFileTemplateMap(InputPtr input, NodePtr shader, const string& udim = EMPTY_STRING);
-
-    // Find first occurence of variable in filename from start index onwards
-    size_t findVarInTemplate(const string& filename, const string& var, size_t start = 0);
-
-    // Generate a texture filename for the given graph output.
-    FilePath generateTextureFilename(const StringMap& fileTemplateMap);
-
-    // Create document that links shader outputs to a material.
-    DocumentPtr generateNewDocumentFromShader(NodePtr shader, const StringVec& udimSet);
-
-    // Write a baked image to disk, returning true if the write was successful.
-    bool writeBakedImage(const BakedImage& baked, ImagePtr image);
-
-  protected:
-    string _extension;
-    string _colorSpace;
-    string _distanceUnit;
-    bool _averageImages;
-    bool _optimizeConstants;
-    FilePath _outputImagePath;
-    string _bakedGraphName;
-    string _bakedGeomInfoName;
-    string _textureFilenameTemplate;
-    std::ostream* _outputStream;
-    bool _hashImageNames;
-    Vector2 _textureSpaceMin;
-    Vector2 _textureSpaceMax;
-
-    ShaderGeneratorPtr _generator;
-    ConstNodePtr _material;
-    ImagePtr _frameCaptureImage;
-    BakedImageMap _bakedImageMap;
-    BakedConstantMap _bakedConstantMap;
-    StringSet _permittedOverrides;
-    StringMap _texTemplateOverrides;
-    StringMap _bakedInputMap;
-
-    std::unordered_map<string, NodePtr> _worldSpaceNodes;
-    
-    id<MTLDevice> _device;
+    TextureBakerMsl(unsigned int width, unsigned int height, Image::BaseType baseType);
 };
 
 MATERIALX_NAMESPACE_END
diff --git a/source/MaterialXRenderMsl/TextureBaker.mm b/source/MaterialXRenderMsl/TextureBaker.mm
index 0a0cc704..4c8d32ba 100644
--- a/source/MaterialXRenderMsl/TextureBaker.mm
+++ b/source/MaterialXRenderMsl/TextureBaker.mm
@@ -15,622 +15,9 @@
 
 MATERIALX_NAMESPACE_BEGIN
 
-namespace {
-
-const string SRGB_TEXTURE = "srgb_texture";
-const string LIN_REC709 = "lin_rec709";
-const string BAKED_POSTFIX = "_baked";
-const string SHADER_PREFIX = "SR_";
-const string DEFAULT_UDIM_PREFIX = "_";
-
-string getValueStringFromColor(const Color4& color, const string& type)
-{
-    if (type == "color4" || type == "vector4")
-    {
-        return toValueString(color);
-    }
-    if (type == "color3" || type == "vector3")
-    {
-        return toValueString(Vector3(color[0], color[1], color[2]));
-    }
-    if (type == "vector2")
-    {
-        return toValueString(Vector2(color[0], color[1]));
-    }
-    if (type == "float")
-    {
-        return toValueString(color[0]);
-    }
-    return EMPTY_STRING;
-}
-
-} // anonymous namespace
-
-TextureBakerMsl::TextureBakerMsl(id<MTLDevice> device, unsigned int width, unsigned int height, Image::BaseType baseType) :
-    MslRenderer(width, height, baseType),
-    _distanceUnit("meter"),
-    _averageImages(false),
-    _optimizeConstants(true),
-    _bakedGraphName("NG_baked"),
-    _bakedGeomInfoName("GI_baked"),
-    _textureFilenameTemplate("$MATERIAL_$SHADINGMODEL_$INPUT$UDIMPREFIX$UDIM.$EXTENSION"),
-    _outputStream(&std::cout),
-    _hashImageNames(false),
-    _textureSpaceMin(0.0f),
-    _textureSpaceMax(1.0f),
-    _generator(MslShaderGenerator::create()),
-    _permittedOverrides({ "$ASSET", "$MATERIAL", "$UDIMPREFIX" }),
-    _device(device)
-{
-    if (baseType == Image::BaseType::UINT8)
-    {
-#if MATERIALX_BUILD_OIIO
-        _extension = ImageLoader::TIFF_EXTENSION;
-#else
-        _extension = ImageLoader::PNG_EXTENSION;
-#endif
-        _colorSpace = SRGB_TEXTURE;
-    }
-    else
-    {
-#if MATERIALX_BUILD_OIIO
-        _extension = ImageLoader::EXR_EXTENSION;
-#else
-        _extension = ImageLoader::HDR_EXTENSION;
-#endif
-        _colorSpace = LIN_REC709;
-    }
-
-    // Initialize our base renderer.
-    MslRenderer::initialize();
-    
-    _device = device;
-
-    // Initialize our image handler.
-    _imageHandler = MetalTextureHandler::create(device, StbImageLoader::create());
-#if MATERIALX_BUILD_OIIO
-    _imageHandler->addLoader(OiioImageLoader::create());
-#endif
-
-    // Create our dedicated frame capture image.
-    _frameCaptureImage = Image::create(width, height, 4, baseType);
-    _frameCaptureImage->createResourceBuffer();
-}
-
-size_t TextureBakerMsl::findVarInTemplate(const string& filename, const string& var, size_t start)
+TextureBakerMsl::TextureBakerMsl(unsigned int width, unsigned int height, Image::BaseType baseType) :
+    TextureBaker<MslRenderer, MslShaderGenerator>(width, height, baseType)
 {
-    size_t i = filename.find(var, start);
-    if (var == "$UDIM" && i != string::npos)
-    {
-        size_t udimPrefix = filename.find("$UDIMPREFIX", start);
-        if (i == udimPrefix)
-        {
-            i = filename.find(var, i + 1);
-        }
-    }
-    return i;
-}
-
-FilePath TextureBakerMsl::generateTextureFilename(const StringMap& filenameTemplateMap)
-{
-    string bakedImageName = _textureFilenameTemplate;
-
-    for (auto& pair : filenameTemplateMap)
-    {
-        string replacement = (_texTemplateOverrides.count(pair.first)) ?
-            _texTemplateOverrides[pair.first] : pair.second;
-        replacement = (filenameTemplateMap.at("$UDIM").empty() && pair.first == "$UDIMPREFIX") ?
-            EMPTY_STRING : replacement;
-
-        for (size_t i = 0; (i = findVarInTemplate(bakedImageName, pair.first, i)) != string::npos; i++)
-        {
-            bakedImageName.replace(i, pair.first.length(), replacement);
-        }
-    }
-
-    if (_hashImageNames)
-    {
-        std::stringstream hashStream;
-        hashStream << std::hash<std::string>{}(bakedImageName);
-        hashStream << "." + getExtension();
-        bakedImageName = hashStream.str();
-    }
-    return _outputImagePath / bakedImageName;
-}
-
-StringMap TextureBakerMsl::initializeFileTemplateMap(InputPtr input, NodePtr shader, const string& udim)
-{
-    FilePath assetPath = FilePath(shader->getActiveSourceUri());
-    assetPath.removeExtension();
-    StringMap filenameTemplateMap;
-    filenameTemplateMap["$ASSET"] = assetPath.getBaseName();
-    filenameTemplateMap["$INPUT"] = _bakedInputMap[input->getName()];
-    filenameTemplateMap["$EXTENSION"] = _extension;
-    filenameTemplateMap["$MATERIAL"] = _material->getName();
-    filenameTemplateMap["$SHADINGMODEL"] = shader->getCategory();
-    filenameTemplateMap["$UDIM"] = udim;
-    filenameTemplateMap["$UDIMPREFIX"] = DEFAULT_UDIM_PREFIX;
-    return filenameTemplateMap;
-}
-
-bool TextureBakerMsl::writeBakedImage(const BakedImage& baked, ImagePtr image)
-{
-    if (!_imageHandler->saveImage(baked.filename, image, false))
-    {
-        if (_outputStream)
-        {
-            *_outputStream << "Failed to write baked image: " << baked.filename.asString() << std::endl;
-        }
-        return false;
-    }
-
-    if (_outputStream)
-    {
-        *_outputStream << "Wrote baked image: " << baked.filename.asString() << std::endl;
-    }
-
-    return true;
-}
-
-void TextureBakerMsl::bakeShaderInputs(NodePtr material, NodePtr shader, GenContext& context, const string& udim)
-{
-    _material = material;
-    
-    if (!shader)
-    {
-        return;
-    }
-
-    std::unordered_map<OutputPtr, InputPtr> bakedOutputMap;
-    for (InputPtr input : shader->getInputs())
-    {
-        OutputPtr output = input->getConnectedOutput();
-        if (output && !bakedOutputMap.count(output))
-        {
-            bakedOutputMap[output] = input;
-            _bakedInputMap[input->getName()] = input->getName();
-
-            // When possible, nodes with world-space outputs are applied outside of the baking process.
-            NodePtr worldSpaceNode = connectsToWorldSpaceNode(output);
-            if (worldSpaceNode)
-            {
-                output->setConnectedNode(worldSpaceNode->getConnectedNode("in"));
-                _worldSpaceNodes[input->getName()] = worldSpaceNode;
-            }
-            StringMap filenameTemplateMap = initializeFileTemplateMap(input, shader, udim);
-            bakeGraphOutput(output, context, filenameTemplateMap);
-        }
-        else if (bakedOutputMap.count(output))
-        {
-            // When the input shares the same output as a previously baked input, we use the already baked input.
-            _bakedInputMap[input->getName()] = bakedOutputMap[output]->getName();
-        }
-    }
-
-    // Release all images used to generate this set of shader inputs.
-    _imageHandler->clearImageCache();
-}
-
-void TextureBakerMsl::bakeGraphOutput(OutputPtr output, GenContext& context, const StringMap& filenameTemplateMap)
-{
-    if (!output)
-    {
-        return;
-    }
-
-    ShaderPtr shader = _generator->generate("BakingShader", output, context);
-    
-    bool encodeSrgb = _colorSpace == SRGB_TEXTURE &&
-        (output->getType() == "color3" || output->getType() == "color4");
-    
-    if(getFramebuffer()->getEncodeSrgb() != encodeSrgb)
-    {
-        getFramebuffer()->setEncodeSrgb(encodeSrgb);
-        createFrameBuffer(encodeSrgb);
-    }
-    
-    createProgram(shader);
-    
-    // Render and capture the requested image.
-    renderTextureSpace(getTextureSpaceMin(), getTextureSpaceMax());
-    string texturefilepath = generateTextureFilename(filenameTemplateMap);
-    captureImage(_frameCaptureImage);
-
-    // Construct a baked image record.
-    BakedImage baked;
-    baked.filename = texturefilepath;
-    if (_averageImages)
-    {
-        baked.uniformColor = _frameCaptureImage->getAverageColor();
-        baked.isUniform = true;
-    }
-    else if (_frameCaptureImage->isUniformColor(&baked.uniformColor))
-    {
-        baked.isUniform = true;
-    }
-    _bakedImageMap[output].push_back(baked);
-
-    // TODO: Write images to memory rather than to disk.
-    // Write non-uniform images to disk.
-    if (!baked.isUniform)
-    {
-        writeBakedImage(baked, _frameCaptureImage);
-    }
-}
-
-void TextureBakerMsl::optimizeBakedTextures(NodePtr shader)
-{
-    if (!shader)
-    {
-        return;
-    }
-
-    // Check for fully uniform outputs.
-    for (auto& pair : _bakedImageMap)
-    {
-        bool outputIsUniform = true;
-        for (BakedImage& baked : pair.second)
-        {
-            if (!baked.isUniform || baked.uniformColor != pair.second[0].uniformColor)
-            {
-                outputIsUniform = false;
-                continue;
-            }
-        }
-        if (outputIsUniform)
-        {
-            BakedConstant bakedConstant;
-            bakedConstant.color = pair.second[0].uniformColor;
-            _bakedConstantMap[pair.first] = bakedConstant;
-        }
-    }
-
-    // Check for uniform outputs at their default values.
-    NodeDefPtr shaderNodeDef = shader->getNodeDef();
-    if (shaderNodeDef)
-    {
-        for (InputPtr shaderInput : shader->getInputs())
-        {
-            OutputPtr output = shaderInput->getConnectedOutput();
-            if (output && _bakedConstantMap.count(output))
-            {
-                InputPtr input = shaderNodeDef->getInput(shaderInput->getName());
-                if (input)
-                {
-                    Color4 uniformColor = _bakedConstantMap[output].color;
-                    string uniformColorString = getValueStringFromColor(uniformColor, input->getType());
-                    string defaultValueString = input->hasValue() ? input->getValue()->getValueString() : EMPTY_STRING;
-                    if (uniformColorString == defaultValueString)
-                    {
-                        _bakedConstantMap[output].isDefault = true;
-                    }
-                }
-            }
-        }
-    }
-
-    // Remove baked images that have been replaced by constant values.
-    for (auto& pair : _bakedConstantMap)
-    {
-        if (pair.second.isDefault || _optimizeConstants || _averageImages)
-        {
-            _bakedImageMap.erase(pair.first);
-        }
-    }
-}
-
-DocumentPtr TextureBakerMsl::generateNewDocumentFromShader(NodePtr shader, const StringVec& udimSet)
-{
-    if (!shader)
-    {
-        return nullptr;
-    }
-
-    // Create document.
-    DocumentPtr bakedTextureDoc = createDocument();
-    if (shader->getDocument()->hasColorSpace())
-    {
-        bakedTextureDoc->setColorSpace(shader->getDocument()->getColorSpace());
-    }
-
-    // Create node graph and geometry info.
-    NodeGraphPtr bakedNodeGraph;
-    if (!_bakedImageMap.empty())
-    {
-        _bakedGraphName = bakedTextureDoc->createValidChildName(_bakedGraphName);
-        bakedNodeGraph = bakedTextureDoc->addNodeGraph(_bakedGraphName);
-        bakedNodeGraph->setColorSpace(_colorSpace);
-    }
-    _bakedGeomInfoName = bakedTextureDoc->createValidChildName(_bakedGeomInfoName);
-    GeomInfoPtr bakedGeom = !udimSet.empty() ? bakedTextureDoc->addGeomInfo(_bakedGeomInfoName) : nullptr;
-    if (bakedGeom)
-    {
-        bakedGeom->setGeomPropValue(UDIM_SET_PROPERTY, udimSet, "stringarray");
-    }
-
-    // Create a shader node.
-    NodePtr bakedShader = bakedTextureDoc->addNode(shader->getCategory(), shader->getName() + BAKED_POSTFIX, shader->getType());
-
-    // Optionally create a material node, connecting it to the new shader node.
-    if (_material)
-    {
-        string materialName = (_texTemplateOverrides.count("$MATERIAL"))? _texTemplateOverrides["$MATERIAL"] : _material->getName();
-        NodePtr bakedMaterial = bakedTextureDoc->addNode(_material->getCategory(), materialName + BAKED_POSTFIX, _material->getType());
-        for (auto sourceMaterialInput : _material->getInputs())
-        {
-            const string& sourceMaterialInputName = sourceMaterialInput->getName();
-            NodePtr upstreamShader = sourceMaterialInput->getConnectedNode();
-            if (upstreamShader && (upstreamShader->getNamePath() == shader->getNamePath()))
-            {
-                InputPtr bakedMaterialInput = bakedMaterial->getInput(sourceMaterialInputName);
-                if (!bakedMaterialInput)
-                {
-                    bakedMaterialInput = bakedMaterial->addInput(sourceMaterialInputName, sourceMaterialInput->getType());
-                }
-                bakedMaterialInput->setNodeName(bakedShader->getName());
-            }
-        }
-    }
-
-    // Create and connect inputs on the new shader node.
-    for (ValueElementPtr valueElem : shader->getChildrenOfType<ValueElement>())
-    {
-        // Get the source input and its connected output.
-        InputPtr sourceInput = valueElem->asA<Input>();
-        if (!sourceInput)
-        {
-            continue;
-        }
-
-        OutputPtr output = sourceInput->getConnectedOutput();
-
-        // Skip uniform outputs at their default values.
-        if (output && _bakedConstantMap.count(output) && _bakedConstantMap[output].isDefault)
-        {
-            continue;
-        }
-
-        // Find or create the baked input.
-        const string& sourceName = sourceInput->getName();
-        const string& sourceType = sourceInput->getType();
-        InputPtr bakedInput = bakedShader->getInput(sourceName);
-        if (!bakedInput)
-        {
-            bakedInput = bakedShader->addInput(sourceName, sourceType);
-        }
-
-        // Assign image or constant data to the baked input.
-        if (output)
-        {
-            // Store a constant value for uniform outputs.
-            if (_optimizeConstants && _bakedConstantMap.count(output))
-            {
-                Color4 uniformColor = _bakedConstantMap[output].color;
-                string uniformColorString = getValueStringFromColor(uniformColor, bakedInput->getType());
-                bakedInput->setValueString(uniformColorString);
-                if (bakedInput->getType() == "color3" || bakedInput->getType() == "color4")
-                {
-                    bakedInput->setColorSpace(_colorSpace);
-                }
-                continue;
-            }
-
-            if (!_bakedImageMap.empty())
-            {
-                // Add the image node.
-                NodePtr bakedImage = bakedNodeGraph->addNode("image", sourceName + BAKED_POSTFIX, sourceType);
-                InputPtr input = bakedImage->addInput("file", "filename");
-                StringMap filenameTemplateMap = initializeFileTemplateMap(bakedInput, shader, udimSet.empty() ? EMPTY_STRING : UDIM_TOKEN);
-                input->setValueString(generateTextureFilename(filenameTemplateMap));
-
-                // Reconstruct any world-space nodes that were excluded from the baking process.
-                auto worldSpacePair = _worldSpaceNodes.find(sourceInput->getName());
-                if (worldSpacePair != _worldSpaceNodes.end())
-                {
-                    NodePtr origWorldSpaceNode = worldSpacePair->second;
-                    if (origWorldSpaceNode)
-                    {
-                        NodePtr newWorldSpaceNode = bakedNodeGraph->addNode(origWorldSpaceNode->getCategory(), sourceName + BAKED_POSTFIX + "_map", sourceType);
-                        newWorldSpaceNode->copyContentFrom(origWorldSpaceNode);
-                        InputPtr mapInput = newWorldSpaceNode->getInput("in");
-                        if (mapInput)
-                        {
-                            mapInput->setNodeName(bakedImage->getName());
-                        }
-                        bakedImage = newWorldSpaceNode;
-                    }
-                }
-
-                // Add the graph output.
-                OutputPtr bakedOutput = bakedNodeGraph->addOutput(sourceName + "_output", sourceType);
-                bakedOutput->setConnectedNode(bakedImage);
-                bakedInput->setConnectedOutput(bakedOutput);
-            }
-        }
-        else
-        {
-            bakedInput->copyContentFrom(sourceInput);
-        }
-    }
-
-    // Generate uniform images and write to disk.
-    ImagePtr uniformImage = createUniformImage(4, 4, 4, _baseType, Color4());
-    for (const auto& pair : _bakedImageMap)
-    {
-        for (const BakedImage& baked : pair.second)
-        {
-            if (baked.isUniform)
-            {
-                uniformImage->setUniformColor(baked.uniformColor);
-                writeBakedImage(baked, uniformImage);
-            }
-        }
-    }
-
-    // Clear cached information after each material bake
-    _bakedImageMap.clear();
-    _bakedConstantMap.clear();
-    _worldSpaceNodes.clear();
-    _bakedInputMap.clear();
-    _material = nullptr;
-
-    // Return the baked document on success.
-    return bakedTextureDoc;
-}
-
-DocumentPtr TextureBakerMsl::bakeMaterialToDoc(DocumentPtr doc, const FileSearchPath& searchPath, const string& materialPath,
-                                            const StringVec& udimSet, string& documentName)
-{
-    if (_outputStream)
-    {
-        *_outputStream << "Processing material: " << materialPath << std::endl;
-    }
-
-    // Set up generator context for material
-    GenContext genContext(_generator);
-    genContext.getOptions().targetColorSpaceOverride = LIN_REC709;
-    genContext.getOptions().fileTextureVerticalFlip = true;
-    genContext.getOptions().targetDistanceUnit = _distanceUnit;
-
-    DefaultColorManagementSystemPtr cms = DefaultColorManagementSystem::create(genContext.getShaderGenerator().getTarget());
-    cms->loadLibrary(doc);
-    genContext.registerSourceCodeSearchPath(searchPath);
-    genContext.getShaderGenerator().setColorManagementSystem(cms);
-
-    // Compute the material tag set.
-    StringVec materialTags = udimSet;
-    if (materialTags.empty())
-    {
-        materialTags.push_back(EMPTY_STRING);
-    }
-
-    ElementPtr elem = doc->getDescendant(materialPath);
-    if (!elem || !elem->isA<Node>())
-    {
-        return nullptr;
-    }
-    NodePtr materialNode = elem->asA<Node>();
-
-    vector<NodePtr> shaderNodes = getShaderNodes(materialNode);
-    NodePtr shaderNode = shaderNodes.empty() ? nullptr : shaderNodes[0];
-    if (!shaderNode)
-    {
-        return nullptr;
-    }
-
-    StringResolverPtr resolver = StringResolver::create();
-
-    // Iterate over material tags.
-    for (const string& tag : materialTags)
-    {
-        // Always clear any cached implementations before generation.
-        genContext.clearNodeImplementations();
-
-        ShaderPtr hwShader = createShader("Shader", genContext, shaderNode);
-        if (!hwShader)
-        {
-            continue;
-        }
-        _imageHandler->setSearchPath(searchPath);
-        resolver->setUdimString(tag);
-        _imageHandler->setFilenameResolver(resolver);
-        bakeShaderInputs(materialNode, shaderNode, genContext, tag);
-
-        // Optimize baked textures.
-        optimizeBakedTextures(shaderNode);
-    }
-
-    // Link the baked material and textures in a MaterialX document.
-    documentName = shaderNode->getName();
-    return generateNewDocumentFromShader(shaderNode, udimSet);
-}
-
-void TextureBakerMsl::bakeAllMaterials(DocumentPtr doc, const FileSearchPath& searchPath, const FilePath& outputFilename)
-{
-    if (_outputImagePath.isEmpty())
-    {
-        _outputImagePath = outputFilename.getParentPath();
-        if (!_outputImagePath.exists())
-        {
-            _outputImagePath.createDirectory();
-        }
-    }
-
-    std::vector<TypedElementPtr> renderableMaterials;
-    findRenderableElements(doc, renderableMaterials);
-
-    // Compute the UDIM set.
-    ValuePtr udimSetValue = doc->getGeomPropValue(UDIM_SET_PROPERTY);
-    StringVec udimSet;
-    if (udimSetValue && udimSetValue->isA<StringVec>())
-    {
-        udimSet = udimSetValue->asA<StringVec>();
-    }
-
-    // Bake all materials in documents to memory.
-    BakedDocumentVec bakedDocuments;
-    for (size_t i = 0; i < renderableMaterials.size(); i++)
-    {
-        if (_outputStream && i > 0)
-        {
-            *_outputStream << std::endl;
-        }
-
-        const TypedElementPtr& element = renderableMaterials[i];
-        string documentName;
-        DocumentPtr bakedMaterialDoc = bakeMaterialToDoc(doc, searchPath, element->getNamePath(), udimSet, documentName);
-        if (bakedMaterialDoc)
-        {
-            bakedDocuments.push_back(make_pair(documentName, bakedMaterialDoc));
-        }
-    }
-
-    // Write documents in memory to disk.
-    size_t bakeCount = bakedDocuments.size();
-    for (size_t i = 0; i < bakeCount; i++)
-    {
-        if (bakedDocuments[i].second)
-        {
-            FilePath writeFilename = outputFilename;
-
-            // Add additional filename decorations if there are multiple documents.
-            if (bakedDocuments.size() > 1)
-            {
-                const string extension = writeFilename.getExtension();
-                writeFilename.removeExtension();
-                string filenameSeparator = writeFilename.isDirectory()? EMPTY_STRING : "_";
-                writeFilename = FilePath(writeFilename.asString() + filenameSeparator + bakedDocuments[i].first + "." + extension);
-            }
-
-            writeToXmlFile(bakedDocuments[i].second, writeFilename);
-            if (_outputStream)
-            {
-                *_outputStream << "Wrote baked document: " << writeFilename.asString() << std::endl;
-            }
-        }
-    }
-}
-
-void TextureBakerMsl::setupUnitSystem(DocumentPtr unitDefinitions)
-{
-    UnitTypeDefPtr distanceTypeDef = unitDefinitions ? unitDefinitions->getUnitTypeDef("distance") : nullptr;
-    UnitTypeDefPtr angleTypeDef = unitDefinitions ? unitDefinitions->getUnitTypeDef("angle") : nullptr;
-    if (!distanceTypeDef && !angleTypeDef)
-    {
-        return;
-    }
-
-    UnitSystemPtr unitSystem = UnitSystem::create(_generator->getTarget());
-    if (!unitSystem)
-    {
-        return;
-    }
-    _generator->setUnitSystem(unitSystem);
-    UnitConverterRegistryPtr registry = UnitConverterRegistry::create();
-    registry->addUnitConverter(distanceTypeDef, LinearUnitConverter::create(distanceTypeDef));
-    registry->addUnitConverter(angleTypeDef, LinearUnitConverter::create(angleTypeDef));
-    _generator->getUnitSystem()->loadLibrary(unitDefinitions);
-    _generator->getUnitSystem()->setUnitConverterRegistry(registry);
 }
 
 MATERIALX_NAMESPACE_END
diff --git a/source/MaterialXTest/MaterialXRenderGlsl/RenderGlsl.cpp b/source/MaterialXTest/MaterialXRenderGlsl/RenderGlsl.cpp
index 01c01bc5..1a82af0a 100644
--- a/source/MaterialXTest/MaterialXRenderGlsl/RenderGlsl.cpp
+++ b/source/MaterialXTest/MaterialXRenderGlsl/RenderGlsl.cpp
@@ -6,6 +6,9 @@
 #include <MaterialXTest/External/Catch/catch.hpp>
 #include <MaterialXTest/MaterialXRender/RenderUtil.h>
 
+#include <MaterialXGenGlsl/GlslShaderGenerator.h>
+#include <MaterialXRenderGlsl/GlslRenderer.h>
+#include <MaterialXRenderGlsl/GLTextureHandler.h>
 #include <MaterialXRenderGlsl/TextureBaker.h>
 
 #include <MaterialXRender/GeometryHandler.h>
@@ -120,7 +123,7 @@ void GlslShaderRenderTester::createRenderer(std::ostream& log)
 
         // Set image handler on renderer
         mx::StbImageLoaderPtr stbLoader = mx::StbImageLoader::create();
-        mx::ImageHandlerPtr imageHandler = mx::GLTextureHandler::create(stbLoader);
+        mx::ImageHandlerPtr imageHandler = _renderer->createImageHandler(stbLoader);
 #if defined(MATERIALX_BUILD_OIIO)
         mx::OiioImageLoaderPtr oiioLoader = mx::OiioImageLoader::create();
         imageHandler->addLoader(oiioLoader);
@@ -421,7 +424,7 @@ void GlslShaderRenderTester::runBake(mx::DocumentPtr doc, const mx::FileSearchPa
     const unsigned bakeHeight = std::max(bakeOptions.resolution, maxImageSize.second);
 
     mx::Image::BaseType baseType = bakeOptions.hdr ? mx::Image::BaseType::FLOAT : mx::Image::BaseType::UINT8;
-    mx::TextureBakerPtr baker = mx::TextureBaker::create(bakeWidth, bakeHeight, baseType);
+    mx::TextureBakerPtr baker = mx::TextureBakerGlsl::create(bakeWidth, bakeHeight, baseType);
     baker->setupUnitSystem(doc);
     baker->setImageHandler(_renderer->getImageHandler());
     baker->setOptimizeConstants(true);
diff --git a/source/MaterialXTest/MaterialXRenderMsl/RenderMsl.mm b/source/MaterialXTest/MaterialXRenderMsl/RenderMsl.mm
index d39fe2cc..7a76ae08 100644
--- a/source/MaterialXTest/MaterialXRenderMsl/RenderMsl.mm
+++ b/source/MaterialXTest/MaterialXRenderMsl/RenderMsl.mm
@@ -131,7 +131,7 @@ void MslShaderRenderTester::createRenderer(std::ostream& log)
         // Set image handler on renderer
         mx::StbImageLoaderPtr stbLoader = mx::StbImageLoader::create();
         mx::ImageHandlerPtr imageHandler =
-            mx::MetalTextureHandler::create(_device, stbLoader);
+            _renderer->createImageHandler(stbLoader);
 #if defined(MATERIALX_BUILD_OIIO)
         mx::OiioImageLoaderPtr oiioLoader = mx::OiioImageLoader::create();
         imageHandler->addLoader(oiioLoader);
@@ -431,7 +431,7 @@ void MslShaderRenderTester::runBake(mx::DocumentPtr doc, const mx::FileSearchPat
     const unsigned bakeHeight = std::max(bakeOptions.resolution, maxImageSize.second);
 
     mx::Image::BaseType baseType = bakeOptions.hdr ? mx::Image::BaseType::FLOAT : mx::Image::BaseType::UINT8;
-    mx::TextureBakerMslPtr baker = mx::TextureBakerMsl::create(_device, bakeWidth, bakeHeight, baseType);
+    mx::TextureBakerPtr baker = mx::TextureBakerMsl::create(bakeWidth, bakeHeight, baseType);
     baker->setupUnitSystem(doc);
     baker->setImageHandler(_renderer->getImageHandler());
     baker->setOptimizeConstants(true);
diff --git a/source/MaterialXView/ViewerMSL.mm b/source/MaterialXView/ViewerMSL.mm
index 7be2f7bf..6465eeeb 100644
--- a/source/MaterialXView/ViewerMSL.mm
+++ b/source/MaterialXView/ViewerMSL.mm
@@ -479,7 +479,7 @@ void Viewer::bakeTextures()
 
         // Construct a texture baker.
         mx::Image::BaseType baseType = _bakeHdr ? mx::Image::BaseType::FLOAT : mx::Image::BaseType::UINT8;
-        mx::TextureBakerMslPtr baker = mx::TextureBakerMsl::create(MTL(device), bakeWidth, bakeHeight, baseType);
+        mx::TextureBakerPtr baker = mx::TextureBakerMsl::create(bakeWidth, bakeHeight, baseType);
         baker->setupUnitSystem(_stdLib);
         baker->setDistanceUnit(_genContext.getOptions().targetDistanceUnit);
         baker->setAverageImages(_bakeAverage);
-- 
2.37.0

From 7c60198358639929389b8af6a8d7881c1a9f3cc3 Mon Sep 17 00:00:00 2001
From: Morteza Mostajab <smostajabodaveh@apple.com>
Date: Tue, 7 Mar 2023 13:25:53 +0000
Subject: [PATCH] correcting indentations

---
 source/MaterialXGenMsl/MslShaderGenerator.cpp | 110 +++++++++---------
 1 file changed, 55 insertions(+), 55 deletions(-)

diff --git a/source/MaterialXGenMsl/MslShaderGenerator.cpp b/source/MaterialXGenMsl/MslShaderGenerator.cpp
index 6cd7526d..9e054485 100644
--- a/source/MaterialXGenMsl/MslShaderGenerator.cpp
+++ b/source/MaterialXGenMsl/MslShaderGenerator.cpp
@@ -411,19 +411,19 @@ void MslShaderGenerator::emitGlobalVariables(GenContext& context,
         situation == EMIT_GLOBAL_SCOPE_CONTEXT_CONSTRUCTOR_INIT;
 
     std::string separator = "";
-DEFINE_SHADER_STAGE(stage, Stage::PIXEL)
-    {
-    if(globalContextMembers)
-    {
-        emitLine("vec4 gl_FragCoord", stage);
-    }
-    if(globalContextConstructorInit)
+    DEFINE_SHADER_STAGE(stage, Stage::PIXEL)
     {
-        emitString("gl_FragCoord(", stage);
-        emitLine(stage.getInputBlock(HW::VERTEX_DATA).getInstance() + ".pos)", stage, false);
-        separator = ",";
+        if(globalContextMembers)
+        {
+            emitLine("vec4 gl_FragCoord", stage);
+        }
+        if(globalContextConstructorInit)
+        {
+            emitString("gl_FragCoord(", stage);
+            emitLine(stage.getInputBlock(HW::VERTEX_DATA).getInstance() + ".pos)", stage, false);
+            separator = ",";
+        }
     }
-}
 
     {
         auto vertex_inputs = isVertexShader ? stage.getInputBlock(HW::VERTEX_INPUTS)
@@ -888,7 +888,7 @@ void MslShaderGenerator::emitInputs(GenContext& context, ShaderStage& stage, con
     
     DEFINE_SHADER_STAGE(stage, Stage::PIXEL)
     {
-    emitLine("float4 pos [[position]]", stage);
+        emitLine("float4 pos [[position]]", stage);
     }
     
     for (size_t i=0; i<inputs.size(); ++i)
@@ -897,10 +897,10 @@ void MslShaderGenerator::emitInputs(GenContext& context, ShaderStage& stage, con
         line += context.getShaderGenerator().getSyntax().getTypeName(inputs[i]->getType());
         line += " " + inputs[i]->getName() + " ";
         DEFINE_SHADER_STAGE(stage, Stage::VERTEX)
-    {
-        line += "[[attribute(";
-        line += std::to_string(i);
-        line += ")]]";
+        {
+            line += "[[attribute(";
+            line += std::to_string(i);
+            line += ")]]";
         };
         
         emitLine(line, stage, true);
@@ -913,17 +913,17 @@ void MslShaderGenerator::emitInputs(GenContext& context, ShaderStage& stage, con
 
 void MslShaderGenerator::emitInputs(GenContext& context, ShaderStage& stage) const
 {
-DEFINE_SHADER_STAGE(stage, Stage::VERTEX)
+    DEFINE_SHADER_STAGE(stage, Stage::VERTEX)
     {
-    const VariableBlock& vertexInputs = stage.getInputBlock(HW::VERTEX_INPUTS);
-    emitInputs(context, stage, vertexInputs);
-}
+        const VariableBlock& vertexInputs = stage.getInputBlock(HW::VERTEX_INPUTS);
+        emitInputs(context, stage, vertexInputs);
+    }
 
-DEFINE_SHADER_STAGE(stage, Stage::PIXEL)
+    DEFINE_SHADER_STAGE(stage, Stage::PIXEL)
     {
-    const VariableBlock& vertexData = stage.getInputBlock(HW::VERTEX_DATA);
-    emitInputs(context, stage, vertexData);
-}
+        const VariableBlock& vertexData = stage.getInputBlock(HW::VERTEX_DATA);
+        emitInputs(context, stage, vertexData);
+    }
 }
 
 void MslShaderGenerator::emitOutputs(GenContext& context, ShaderStage& stage) const
@@ -935,10 +935,10 @@ void MslShaderGenerator::emitOutputs(GenContext& context, ShaderStage& stage) co
         {
             emitLine("struct " + outputs.getName(), stage, false);
             emitScopeBegin(stage);
-DEFINE_SHADER_STAGE(stage, Stage::VERTEX)
-    {
-            emitLine("float4 pos [[position]]", stage, true);
-}
+            DEFINE_SHADER_STAGE(stage, Stage::VERTEX)
+            {
+                emitLine("float4 pos [[position]]", stage, true);
+            }
             emitVariableDeclarations(outputs, EMPTY_STRING, Syntax::SEMICOLON, context, stage, false);
             emitScopeEnd(stage, true, false);
             emitLineBreak(stage);
@@ -955,18 +955,18 @@ DEFINE_SHADER_STAGE(stage, Stage::VERTEX)
         }
     };
     
-DEFINE_SHADER_STAGE(stage, Stage::VERTEX)
+    DEFINE_SHADER_STAGE(stage, Stage::VERTEX)
     {
-    const VariableBlock& vertexData = stage.getOutputBlock(HW::VERTEX_DATA);
-    emitOutputsOfShaderSource(vertexData);
-}
+        const VariableBlock& vertexData = stage.getOutputBlock(HW::VERTEX_DATA);
+        emitOutputsOfShaderSource(vertexData);
+    }
 
-DEFINE_SHADER_STAGE(stage, Stage::PIXEL)
+    DEFINE_SHADER_STAGE(stage, Stage::PIXEL)
     {
-    emitComment("Pixel shader outputs", stage);
-    const VariableBlock& outputs = stage.getOutputBlock(HW::PIXEL_OUTPUTS);
-    emitOutputsOfShaderSource(outputs);
-}
+        emitComment("Pixel shader outputs", stage);
+        const VariableBlock& outputs = stage.getOutputBlock(HW::PIXEL_OUTPUTS);
+        emitOutputsOfShaderSource(outputs);
+    }
 }
 
 HwResourceBindingContextPtr MslShaderGenerator::getResourceBindingContext(GenContext& context) const
@@ -1315,33 +1315,33 @@ void MslShaderGenerator::emitPixelStage(const ShaderGraph& graph, GenContext& co
 
 void MslShaderGenerator::emitLightFunctionDefinitions(const ShaderGraph& graph, GenContext& context, ShaderStage& stage) const
 {
-DEFINE_SHADER_STAGE(stage, Stage::PIXEL)
-    {
-
-    // Emit Light functions if requested
-    if (requiresLighting(graph) && context.getOptions().hwMaxActiveLightSources > 0)
+    DEFINE_SHADER_STAGE(stage, Stage::PIXEL)
     {
-        // For surface shaders we need light shaders
-        if (graph.hasClassification(ShaderNode::Classification::SHADER | ShaderNode::Classification::SURFACE))
+        
+        // Emit Light functions if requested
+        if (requiresLighting(graph) && context.getOptions().hwMaxActiveLightSources > 0)
         {
-            // Emit functions for all bound light shaders
-            HwLightShadersPtr lightShaders = context.getUserData<HwLightShaders>(HW::USER_DATA_LIGHT_SHADERS);
-            if (lightShaders)
+            // For surface shaders we need light shaders
+            if (graph.hasClassification(ShaderNode::Classification::SHADER | ShaderNode::Classification::SURFACE))
             {
-                for (const auto& it : lightShaders->get())
+                // Emit functions for all bound light shaders
+                HwLightShadersPtr lightShaders = context.getUserData<HwLightShaders>(HW::USER_DATA_LIGHT_SHADERS);
+                if (lightShaders)
+                {
+                    for (const auto& it : lightShaders->get())
+                    {
+                        emitFunctionDefinition(*it.second, context, stage);
+                    }
+                }
+                // Emit functions for light sampling
+                for (const auto& it : _lightSamplingNodes)
                 {
-                    emitFunctionDefinition(*it.second, context, stage);
+                    emitFunctionDefinition(*it, context, stage);
                 }
             }
-            // Emit functions for light sampling
-            for (const auto& it : _lightSamplingNodes)
-            {
-                emitFunctionDefinition(*it, context, stage);
-            }
         }
     }
 }
-}
 
 void MslShaderGenerator::toVec4(const TypeDesc* type, string& variable)
 {
-- 
2.37.0

From 4468f100c208ebfa9e96ccb38b3dc0ec3f9f9e8e Mon Sep 17 00:00:00 2001
From: Morteza Mostajab <smostajabodaveh@apple.com>
Date: Tue, 7 Mar 2023 13:50:39 +0000
Subject: [PATCH] Removed bindUniformLocation as not needed for Metal PSO

---
 .../MSLPipelineStateObject.h                  |  3 -
 .../MSLPipelineStateObject.mm                 | 83 ++-----------------
 2 files changed, 9 insertions(+), 77 deletions(-)

diff --git a/source/MaterialXRenderMsl/MSLPipelineStateObject.h b/source/MaterialXRenderMsl/MSLPipelineStateObject.h
index fcd29835..6a230dce 100644
--- a/source/MaterialXRenderMsl/MSLPipelineStateObject.h
+++ b/source/MaterialXRenderMsl/MSLPipelineStateObject.h
@@ -277,9 +277,6 @@ class MX_RENDERMSL_API MslProgram
     // Utility to map a MaterialX type to an METAL type
     static MTLDataType mapTypeToMetalType(const TypeDesc* type);
 
-    // Bind a value to the uniform at the given location.
-    void bindUniformLocation(int location, ConstValuePtr value);
-
   private:
     // Stages used to create program
     // Map of stage name and its source code
diff --git a/source/MaterialXRenderMsl/MSLPipelineStateObject.mm b/source/MaterialXRenderMsl/MSLPipelineStateObject.mm
index 2f3a7984..39506ae7 100644
--- a/source/MaterialXRenderMsl/MSLPipelineStateObject.mm
+++ b/source/MaterialXRenderMsl/MSLPipelineStateObject.mm
@@ -683,17 +683,10 @@ void MslProgram::bindLighting(LightHandlerPtr lightHandler, ImageHandlerPtr imag
 
     const MslProgram::InputMap& uniformList = getUniformsList();
 
-    // Bind a couple of lights if can find the light information
-    int location = 0;
-
     // Set the number of active light sources
     size_t lightCount = lightHandler->getLightSources().size();
     auto input = uniformList.find(HW::NUM_ACTIVE_LIGHT_SOURCES);
-    if (input != uniformList.end())
-    {
-        location = input->second->location;
-    }
-    else
+    if (input == uniformList.end())
     {
         // No lighting information so nothing further to do
         lightCount = 0;
@@ -813,57 +806,6 @@ void MslProgram::bindLighting(LightHandlerPtr lightHandler, ImageHandlerPtr imag
                     albedoTable,
                     samplingProperties);
     }
-    
-    const vector<NodePtr> lightList = lightHandler->getLightSources();
-    const std::unordered_map<string, unsigned int>& ids = lightHandler->getLightIdMap();
-
-    size_t index = 0;
-    for (const auto& light : lightList)
-    {
-        auto nodeDef = light->getNodeDef();
-        if (!nodeDef)
-        {
-            continue;
-        }
-        const string& nodeDefName = nodeDef->getName();
-        const string prefix = HW::LIGHT_DATA_INSTANCE + "[" + std::to_string(index) + "]";
-
-        // Set light type id
-        bool boundType = false;
-        input = uniformList.find(prefix + ".type");
-        if (input != uniformList.end())
-        {
-            location = input->second->location;
-            if (location >= 0)
-            {
-                auto it = ids.find(nodeDefName);
-                if (it != ids.end())
-                {
-                    boundType = true;
-                }
-            }
-        }
-        if (!boundType)
-        {
-            continue;
-        }
-
-        // Set all inputs
-        for (const auto& lightInput : light->getInputs())
-        {
-            // Make sure we have a value to set
-            if (lightInput->hasValue())
-            {
-                input = uniformList.find(prefix + "." + lightInput->getName());
-                if (input != uniformList.end())
-                {
-                    bindUniformLocation(input->second->location, lightInput->getValue());
-                }
-            }
-        }
-
-        ++index;
-    }
 }
 
 bool MslProgram::hasUniform(const string& name)
@@ -891,21 +833,14 @@ void MslProgram::bindUniform(const string& name, ConstValuePtr value, bool error
         {
             bindUniform(globalNameMapping->second, value, errorIfMissing);
         }
-    }
-}
-
-void MslProgram::bindUniformLocation(int location, ConstValuePtr value)
-{
-    if (_pso == nil)
-    {
-        const string errorType("MSL bind uniform error.");
-        StringVec errors;
-        errors.push_back("Cannot bind without a valid program");
-        throw ExceptionRenderError(errorType, errors);
-    }
-
-    if (location >= 0 && value->getValueString() != EMPTY_STRING)
-    {
+        else
+        {
+            if (errorIfMissing)
+            {
+                throw ExceptionRenderError("Unknown uniform: " + name);
+            }
+            return;
+        }
     }
 }
 
-- 
2.37.0

From 4fd85370b7034b6a917d75e814210394dae2267a Mon Sep 17 00:00:00 2001
From: Morteza Mostajab <smostajabodaveh@apple.com>
Date: Tue, 7 Mar 2023 14:32:57 +0000
Subject: [PATCH] Fixing texture baker problem in Metal tests Refactoring Metal
 frame buffer to have only one code path generating render target.

---
 source/MaterialXRender/TextureBaker.inl       |  8 ++--
 source/MaterialXRenderMsl/MetalFramebuffer.h  | 10 ++++-
 source/MaterialXRenderMsl/MetalFramebuffer.mm | 42 ++++++++-----------
 3 files changed, 29 insertions(+), 31 deletions(-)

diff --git a/source/MaterialXRender/TextureBaker.inl b/source/MaterialXRender/TextureBaker.inl
index 1cbd9efb..14604281 100644
--- a/source/MaterialXRender/TextureBaker.inl
+++ b/source/MaterialXRender/TextureBaker.inl
@@ -220,14 +220,14 @@ void TextureBaker<Renderer, ShaderGen>::bakeGraphOutput(OutputPtr output, GenCon
     {
         return;
     }
-
-    ShaderPtr shader = _generator->generate("BakingShader", output, context);
-    Renderer::createProgram(shader);
-
+    
     bool encodeSrgb = _colorSpace == SRGB_TEXTURE &&
         (output->getType() == "color3" || output->getType() == "color4");
     Renderer::getFramebuffer()->setEncodeSrgb(encodeSrgb);
 
+    ShaderPtr shader = _generator->generate("BakingShader", output, context);
+    Renderer::createProgram(shader);
+
     // Render and capture the requested image.
     Renderer::renderTextureSpace(getTextureSpaceMin(), getTextureSpaceMax());
     string texturefilepath = generateTextureFilename(filenameTemplateMap);
diff --git a/source/MaterialXRenderMsl/MetalFramebuffer.h b/source/MaterialXRenderMsl/MetalFramebuffer.h
index 6eef97fb..b243d069 100644
--- a/source/MaterialXRenderMsl/MetalFramebuffer.h
+++ b/source/MaterialXRenderMsl/MetalFramebuffer.h
@@ -40,13 +40,19 @@ class MX_RENDERMSL_API MetalFramebuffer
     virtual ~MetalFramebuffer();
 
     /// Resize the framebuffer
-    void resize(unsigned int width, unsigned int height);
+    void resize(unsigned int width, unsigned int height, bool forceRecreate = false,
+                MTLPixelFormat pixelFormat = MTLPixelFormatInvalid,
+                id<MTLTexture> extColorTexture = nil);
 
     /// Set the encode sRGB flag, which controls whether values written
     /// to the framebuffer are encoded to the sRGB color space.
     void setEncodeSrgb(bool encode)
     {
-        _encodeSrgb = encode;
+        if(encode != _encodeSrgb)
+        {
+            _encodeSrgb = encode;
+            resize(_width, _height, true);
+        }
     }
 
     /// Return the encode sRGB flag.
diff --git a/source/MaterialXRenderMsl/MetalFramebuffer.mm b/source/MaterialXRenderMsl/MetalFramebuffer.mm
index 877af263..eb8cd27e 100644
--- a/source/MaterialXRenderMsl/MetalFramebuffer.mm
+++ b/source/MaterialXRenderMsl/MetalFramebuffer.mm
@@ -39,8 +39,8 @@ MetalFramebuffer::MetalFramebuffer(id<MTLDevice> device,
                                    id<MTLTexture> colorTexture,
                                    bool encodeSrgb,
                                    MTLPixelFormat pixelFormat) :
-    _width(width),
-    _height(height),
+    _width(0),
+    _height(0),
     _channelCount(channelCount),
     _baseType(baseType),
     _encodeSrgb(encodeSrgb),
@@ -51,24 +51,7 @@ MetalFramebuffer::MetalFramebuffer(id<MTLDevice> device,
     StringVec errors;
     const string errorType("Metal target creation failure.");
 
-    // Convert texture format to Metal
-    MTLDataType    dataType;
-    if(pixelFormat == MTLPixelFormatInvalid)
-        MetalTextureHandler::mapTextureFormatToMetal(baseType, channelCount, _encodeSrgb, dataType, pixelFormat);
-    
-    MTLTextureDescriptor* texDescriptor = [MTLTextureDescriptor
-                                           texture2DDescriptorWithPixelFormat:pixelFormat width:_width height:_height mipmapped:NO];
-    [texDescriptor setStorageMode:MTLStorageModePrivate];
-    [texDescriptor setUsage:MTLTextureUsageRenderTarget|MTLTextureUsageShaderRead];
-    
-    if(colorTexture == nil)
-    {
-        _colorTexture = [device newTextureWithDescriptor:texDescriptor];
-    }
-    
-    texDescriptor.pixelFormat = MTLPixelFormatDepth32Float;
-    [texDescriptor setUsage:MTLTextureUsageRenderTarget];
-    _depthTexture = [device newTextureWithDescriptor:texDescriptor];
+    resize(width, height, true, pixelFormat, colorTexture);
 }
 
 MetalFramebuffer::~MetalFramebuffer()
@@ -77,25 +60,34 @@ MetalFramebuffer::~MetalFramebuffer()
     [_depthTexture release];
 }
 
-void MetalFramebuffer::resize(unsigned int width, unsigned int height)
+void MetalFramebuffer::resize(unsigned int width, unsigned int height, bool forceRecreate,
+                              MTLPixelFormat pixelFormat,
+                              id<MTLTexture> extColorTexture)
 {
     if (width * height <= 0)
     {
         return;
     }
-    if (width != _width || _height != height)
+    if (width != _width || _height != height || forceRecreate)
     {
         // Convert texture format to Metal
-        MTLPixelFormat pixelFormat;
         MTLDataType    dataType;
-        MetalTextureHandler::mapTextureFormatToMetal(_baseType, _channelCount, true, dataType, pixelFormat);
+        if(pixelFormat == MTLPixelFormatInvalid)
+            MetalTextureHandler::mapTextureFormatToMetal(_baseType, _channelCount, _encodeSrgb, dataType, pixelFormat);
 
         MTLTextureDescriptor* texDescriptor = [MTLTextureDescriptor
                                                texture2DDescriptorWithPixelFormat:pixelFormat width:_width height:_height mipmapped:NO];
         [texDescriptor setStorageMode:MTLStorageModePrivate];
         [texDescriptor setUsage:MTLTextureUsageRenderTarget|MTLTextureUsageShaderRead];
         
-        _colorTexture = [_device newTextureWithDescriptor:texDescriptor];
+        if(extColorTexture == nil)
+        {
+            _colorTexture = [_device newTextureWithDescriptor:texDescriptor];
+        }
+        else
+        {
+            _colorTexture = extColorTexture;
+        }
         
         texDescriptor.pixelFormat = MTLPixelFormatDepth32Float;
         [texDescriptor setUsage:MTLTextureUsageRenderTarget];
-- 
2.37.0

From 0b9c2c4320d2f9e1495257fff917bfab4ad8a637 Mon Sep 17 00:00:00 2001
From: Morteza Mostajab <smostajabodaveh@apple.com>
Date: Tue, 7 Mar 2023 14:55:29 +0000
Subject: [PATCH] Fixes baked textures being flipped when rendering with metal

---
 source/MaterialXRender/TextureBaker.h         | 4 +++-
 source/MaterialXRender/TextureBaker.inl       | 7 ++++---
 source/MaterialXRenderGlsl/TextureBaker.cpp   | 2 +-
 source/MaterialXRenderMsl/MetalFramebuffer.mm | 5 ++++-
 source/MaterialXRenderMsl/TextureBaker.mm     | 2 +-
 5 files changed, 13 insertions(+), 7 deletions(-)

diff --git a/source/MaterialXRender/TextureBaker.h b/source/MaterialXRender/TextureBaker.h
index 7f52f7e4..107f8544 100644
--- a/source/MaterialXRender/TextureBaker.h
+++ b/source/MaterialXRender/TextureBaker.h
@@ -246,7 +246,7 @@ class MX_RENDER_API TextureBaker : public Renderer
     using BakedConstantMap = std::unordered_map<OutputPtr, BakedConstant>;
 
   protected:
-    TextureBaker(unsigned int width, unsigned int height, Image::BaseType baseType);
+    TextureBaker(unsigned int width, unsigned int height, Image::BaseType baseType, bool flipSavedImage);
 
     // Populate file template variable naming map
     StringMap initializeFileTemplateMap(InputPtr input, NodePtr shader, const string& udim = EMPTY_STRING);
@@ -288,6 +288,8 @@ class MX_RENDER_API TextureBaker : public Renderer
     StringMap _bakedInputMap;
 
     std::unordered_map<string, NodePtr> _worldSpaceNodes;
+    
+    bool _flipSavedImage;
 };
 
 MATERIALX_NAMESPACE_END
diff --git a/source/MaterialXRender/TextureBaker.inl b/source/MaterialXRender/TextureBaker.inl
index 14604281..5b853ced 100644
--- a/source/MaterialXRender/TextureBaker.inl
+++ b/source/MaterialXRender/TextureBaker.inl
@@ -46,7 +46,7 @@ string TextureBaker<Renderer, ShaderGen>::getValueStringFromColor(const Color4&
 }
 
 template<typename Renderer, typename ShaderGen>
-TextureBaker<Renderer, ShaderGen>::TextureBaker(unsigned int width, unsigned int height, Image::BaseType baseType) :
+TextureBaker<Renderer, ShaderGen>::TextureBaker(unsigned int width, unsigned int height, Image::BaseType baseType, bool flipSavedImage) :
     Renderer(width, height, baseType),
     _distanceUnit("meter"),
     _averageImages(false),
@@ -59,7 +59,8 @@ TextureBaker<Renderer, ShaderGen>::TextureBaker(unsigned int width, unsigned int
     _textureSpaceMin(0.0f),
     _textureSpaceMax(1.0f),
     _generator(ShaderGen::create()),
-    _permittedOverrides({ "$ASSET", "$MATERIAL", "$UDIMPREFIX" })
+    _permittedOverrides({ "$ASSET", "$MATERIAL", "$UDIMPREFIX" }),
+    _flipSavedImage(flipSavedImage)
 {
     if (baseType == Image::BaseType::UINT8)
     {
@@ -156,7 +157,7 @@ StringMap TextureBaker<Renderer, ShaderGen>::initializeFileTemplateMap(InputPtr
 template<typename Renderer, typename ShaderGen>
 bool TextureBaker<Renderer, ShaderGen>::writeBakedImage(const BakedImage& baked, ImagePtr image)
 {
-    if (!Renderer::_imageHandler->saveImage(baked.filename, image, true))
+    if (!Renderer::_imageHandler->saveImage(baked.filename, image, _flipSavedImage))
     {
         if (_outputStream)
         {
diff --git a/source/MaterialXRenderGlsl/TextureBaker.cpp b/source/MaterialXRenderGlsl/TextureBaker.cpp
index 85bceca8..6db0982e 100644
--- a/source/MaterialXRenderGlsl/TextureBaker.cpp
+++ b/source/MaterialXRenderGlsl/TextureBaker.cpp
@@ -15,7 +15,7 @@
 
 MATERIALX_NAMESPACE_BEGIN
 TextureBakerGlsl::TextureBakerGlsl(unsigned int width, unsigned int height, Image::BaseType baseType) :
-    TextureBaker<GlslRenderer, GlslShaderGenerator>(width, height, baseType)
+    TextureBaker<GlslRenderer, GlslShaderGenerator>(width, height, baseType, true)
 {
 }
 MATERIALX_NAMESPACE_END
diff --git a/source/MaterialXRenderMsl/MetalFramebuffer.mm b/source/MaterialXRenderMsl/MetalFramebuffer.mm
index eb8cd27e..c62f50da 100644
--- a/source/MaterialXRenderMsl/MetalFramebuffer.mm
+++ b/source/MaterialXRenderMsl/MetalFramebuffer.mm
@@ -76,7 +76,10 @@ void MetalFramebuffer::resize(unsigned int width, unsigned int height, bool forc
             MetalTextureHandler::mapTextureFormatToMetal(_baseType, _channelCount, _encodeSrgb, dataType, pixelFormat);
 
         MTLTextureDescriptor* texDescriptor = [MTLTextureDescriptor
-                                               texture2DDescriptorWithPixelFormat:pixelFormat width:_width height:_height mipmapped:NO];
+                                               texture2DDescriptorWithPixelFormat:pixelFormat
+                                               width:width
+                                               height:height
+                                               mipmapped:NO];
         [texDescriptor setStorageMode:MTLStorageModePrivate];
         [texDescriptor setUsage:MTLTextureUsageRenderTarget|MTLTextureUsageShaderRead];
         
diff --git a/source/MaterialXRenderMsl/TextureBaker.mm b/source/MaterialXRenderMsl/TextureBaker.mm
index 4c8d32ba..682d2ffa 100644
--- a/source/MaterialXRenderMsl/TextureBaker.mm
+++ b/source/MaterialXRenderMsl/TextureBaker.mm
@@ -16,7 +16,7 @@
 MATERIALX_NAMESPACE_BEGIN
 
 TextureBakerMsl::TextureBakerMsl(unsigned int width, unsigned int height, Image::BaseType baseType) :
-    TextureBaker<MslRenderer, MslShaderGenerator>(width, height, baseType)
+    TextureBaker<MslRenderer, MslShaderGenerator>(width, height, baseType, false)
 {
 }
 
-- 
2.37.0

From 3fc87da4dec823bcd4504483b5a1b9c3d0b303a2 Mon Sep 17 00:00:00 2001
From: Morteza Mostajab <smostajabodaveh@apple.com>
Date: Tue, 7 Mar 2023 15:17:56 +0000
Subject: [PATCH] moved math-scalar-operators, and MetalTexture class to
 external metal files.

---
 .../genmsl/lib/mx_matscalaroperators.metal    |  55 ++++++++++
 libraries/stdlib/genmsl/lib/mx_texture.metal  |  30 ++++++
 source/MaterialXGenMsl/MslShaderGenerator.cpp | 101 ++----------------
 source/MaterialXGenMsl/MslShaderGenerator.h   |   4 +-
 .../MaterialXGenMsl/CMakeLists.txt            |   5 +-
 5 files changed, 96 insertions(+), 99 deletions(-)
 create mode 100644 libraries/stdlib/genmsl/lib/mx_matscalaroperators.metal
 create mode 100644 libraries/stdlib/genmsl/lib/mx_texture.metal

diff --git a/libraries/stdlib/genmsl/lib/mx_matscalaroperators.metal b/libraries/stdlib/genmsl/lib/mx_matscalaroperators.metal
new file mode 100644
index 00000000..2b32a457
--- /dev/null
+++ b/libraries/stdlib/genmsl/lib/mx_matscalaroperators.metal
@@ -0,0 +1,55 @@
+float3x3 operator+(float3x3 a, float b)
+{
+    return a + float3x3(b,b,b,b,b,b,b,b,b);
+}
+
+float4x4 operator+(float4x4 a, float b)
+{
+    return a + float4x4(b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b);
+}
+
+float3x3 operator-(float3x3 a, float b)
+{
+    return a - float3x3(b,b,b,b,b,b,b,b,b);
+}
+
+float4x4 operator-(float4x4 a, float b)
+{
+    return a - float4x4(b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b);
+}
+
+float3x3 operator/(float3x3 a, float3x3 b)
+{
+    for(int i = 0; i < 3; ++i)
+        for(int j = 0; j < 3; ++j)
+            a[i][j] /= b[i][j];
+
+    return a;
+}
+
+float4x4 operator/(float4x4 a, float4x4 b)
+{
+    for(int i = 0; i < 4; ++i)
+        for(int j = 0; j < 4; ++j)
+            a[i][j] /= b[i][j];
+
+    return a;
+}
+
+float3x3 operator/(float3x3 a, float b)
+{
+    for(int i = 0; i < 3; ++i)
+        for(int j = 0; j < 3; ++j)
+            a[i][j] /= b;
+
+    return a;
+}
+
+float4x4 operator/(float4x4 a, float b)
+{
+    for(int i = 0; i < 4; ++i)
+        for(int j = 0; j < 4; ++j)
+            a[i][j] /= b;
+
+    return a;
+}
diff --git a/libraries/stdlib/genmsl/lib/mx_texture.metal b/libraries/stdlib/genmsl/lib/mx_texture.metal
new file mode 100644
index 00000000..479a8836
--- /dev/null
+++ b/libraries/stdlib/genmsl/lib/mx_texture.metal
@@ -0,0 +1,30 @@
+struct MetalTexture
+{
+    texture2d<float> tex;
+    sampler s;
+    int get_width() { return tex.get_width(); }
+    int get_height() { return tex.get_height(); }
+    int get_num_mip_levels() { return tex.get_num_mip_levels(); }
+};
+
+int get_width(MetalTexture mtlTex) { return mtlTex.get_width(); }
+
+float4 texture(MetalTexture mtlTex, float2 uv)
+{
+    return mtlTex.tex.sample(mtlTex.s, uv);
+}
+
+float4 textureLod(MetalTexture mtlTex, float2 uv, float lod)
+{
+    return mtlTex.tex.sample(mtlTex.s, uv, level(lod));
+}
+
+int2 textureSize(MetalTexture mtlTex, int mipLevel)
+{
+    return int2(mtlTex.get_width(), mtlTex.get_height());
+}
+
+int texture_mips(MetalTexture mtlTex)
+{
+    return mtlTex.tex.get_num_mip_levels();
+}
diff --git a/source/MaterialXGenMsl/MslShaderGenerator.cpp b/source/MaterialXGenMsl/MslShaderGenerator.cpp
index 9e054485..1c161285 100644
--- a/source/MaterialXGenMsl/MslShaderGenerator.cpp
+++ b/source/MaterialXGenMsl/MslShaderGenerator.cpp
@@ -820,41 +820,9 @@ void MslShaderGenerator::emitConstantBufferDeclarations(GenContext& context,
     }
 }
 
-void MslShaderGenerator::emitMetalTextureClass(ShaderStage& stage) const
+void MslShaderGenerator::emitMetalTextureClass(GenContext& context, ShaderStage& stage) const
 {
-    emitLine(R"(
-struct MetalTexture
-{
-    texture2d<float> tex;
-    sampler s;
-    int get_width() { return tex.get_width(); }
-    int get_height() { return tex.get_height(); }
-    int get_num_mip_levels() { return tex.get_num_mip_levels(); }
-};
-
-int get_width(MetalTexture mtlTex) { return mtlTex.get_width(); }
-
-float4 texture(MetalTexture mtlTex, float2 uv)
-{
-    return mtlTex.tex.sample(mtlTex.s, uv);
-}
-
-float4 textureLod(MetalTexture mtlTex, float2 uv, float lod)
-{
-    return mtlTex.tex.sample(mtlTex.s, uv, level(lod));
-}
-
-int2 textureSize(MetalTexture mtlTex, int mipLevel)
-{
-    return int2(mtlTex.get_width(), mtlTex.get_height());
-}
-
-int texture_mips(MetalTexture mtlTex)
-{
-    return mtlTex.tex.get_num_mip_levels();
-}
-
-)", stage);
+    emitLibraryInclude("stdlib/genmsl/lib/mx_texture.metal", context, stage);
 }
 
 void MslShaderGenerator::emitLightData(GenContext& context, ShaderStage& stage) const
@@ -988,66 +956,9 @@ bool MslShaderGenerator::requiresLighting(const ShaderGraph& graph) const
     return isBsdf || isLitSurfaceShader;
 }
 
-string MslShaderGenerator::MathMatrixScalarMathOperators() const
-{
-    return R"(
-float3x3 operator+(float3x3 a, float b)
-{
-    return a + float3x3(b,b,b,b,b,b,b,b,b);
-}
-
-float4x4 operator+(float4x4 a, float b)
-{
-    return a + float4x4(b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b);
-}
-
-float3x3 operator-(float3x3 a, float b)
-{
-    return a - float3x3(b,b,b,b,b,b,b,b,b);
-}
-
-float4x4 operator-(float4x4 a, float b)
-{
-    return a - float4x4(b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b);
-}
-
-float3x3 operator/(float3x3 a, float3x3 b)
-{
-    for(int i = 0; i < 3; ++i)
-        for(int j = 0; j < 3; ++j)
-            a[i][j] /= b[i][j];
-
-    return a;
-}
-
-float4x4 operator/(float4x4 a, float4x4 b)
+void MslShaderGenerator::emitMathMatrixScalarMathOperators(GenContext& context, ShaderStage& stage) const
 {
-    for(int i = 0; i < 4; ++i)
-        for(int j = 0; j < 4; ++j)
-            a[i][j] /= b[i][j];
-
-    return a;
-}
-
-float3x3 operator/(float3x3 a, float b)
-{
-    for(int i = 0; i < 3; ++i)
-        for(int j = 0; j < 3; ++j)
-            a[i][j] /= b;
-
-    return a;
-}
-
-float4x4 operator/(float4x4 a, float b)
-{
-    for(int i = 0; i < 4; ++i)
-        for(int j = 0; j < 4; ++j)
-            a[i][j] /= b;
-
-    return a;
-}
-
-)";
+    emitLibraryInclude("stdlib/genmsl/lib/mx_matscalaroperators.metal", context, stage);
 }
 
 void MslShaderGenerator::emitPixelStage(const ShaderGraph& graph, GenContext& context, ShaderStage& stage) const
@@ -1062,7 +973,7 @@ void MslShaderGenerator::emitPixelStage(const ShaderGraph& graph, GenContext& co
     }
     emitLineBreak(stage);
 
-    emitMetalTextureClass(stage);
+    emitMetalTextureClass(context, stage);
     
     // Add type definitions
     emitTypeDefinitions(context, stage);
@@ -1104,7 +1015,7 @@ void MslShaderGenerator::emitPixelStage(const ShaderGraph& graph, GenContext& co
         }
     }
     
-    emitLine(MathMatrixScalarMathOperators(), stage);
+    emitMathMatrixScalarMathOperators(context, stage);
     emitLine("struct GlobalContext", stage, false);
     emitScopeBegin(stage);
     {
diff --git a/source/MaterialXGenMsl/MslShaderGenerator.h b/source/MaterialXGenMsl/MslShaderGenerator.h
index 93bbaa3f..940cecef 100644
--- a/source/MaterialXGenMsl/MslShaderGenerator.h
+++ b/source/MaterialXGenMsl/MslShaderGenerator.h
@@ -61,14 +61,14 @@ class MX_GENMSL_API MslShaderGenerator : public HwShaderGenerator
     virtual void emitVertexStage(const ShaderGraph& graph, GenContext& context, ShaderStage& stage) const;
     virtual void emitPixelStage(const ShaderGraph& graph, GenContext& context, ShaderStage& stage) const;
 
-    virtual void emitMetalTextureClass(ShaderStage& stage) const;
+    virtual void emitMetalTextureClass(GenContext& context, ShaderStage& stage) const;
     virtual void emitDirectives(GenContext& context, ShaderStage& stage) const;
     virtual void emitConstants(GenContext& context, ShaderStage& stage) const;
     virtual void emitLightData(GenContext& context, ShaderStage& stage) const;
     virtual void emitInputs(GenContext& context, ShaderStage& stage) const;
     virtual void emitOutputs(GenContext& context, ShaderStage& stage) const;
     
-    virtual string MathMatrixScalarMathOperators() const;
+    virtual void emitMathMatrixScalarMathOperators(GenContext& context, ShaderStage& stage) const;
     virtual void MetalizeGeneratedShader(ShaderStage& shaderStage) const;
  
     void emitConstantBufferDeclarations(GenContext& context,
diff --git a/source/MaterialXTest/MaterialXGenMsl/CMakeLists.txt b/source/MaterialXTest/MaterialXGenMsl/CMakeLists.txt
index bd08a83e..d5c17a2f 100644
--- a/source/MaterialXTest/MaterialXGenMsl/CMakeLists.txt
+++ b/source/MaterialXTest/MaterialXGenMsl/CMakeLists.txt
@@ -1,10 +1,11 @@
 file(GLOB_RECURSE source "${CMAKE_CURRENT_SOURCE_DIR}/*.cpp")
 file(GLOB_RECURSE headers "${CMAKE_CURRENT_SOURCE_DIR}/*.h")
+file(GLOB_RECURSE objc_source "")
 if(APPLE)
-    file(GLOB_RECURSE source "${CMAKE_CURRENT_SOURCE_DIR}/*.mm")
+    file(GLOB_RECURSE objc_source "${CMAKE_CURRENT_SOURCE_DIR}/*.mm")
 endif()
 
-target_sources(MaterialXTest PUBLIC ${source} ${headers})
+target_sources(MaterialXTest PUBLIC ${source} ${headers} ${objc_source})
 
 add_tests("${source}")
 
-- 
2.37.0

